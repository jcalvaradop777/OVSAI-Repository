"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-plotly.js";
exports.ids = ["vendor-chunks/react-plotly.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-plotly.js/factory.js":
/*!*************************************************!*\
  !*** ./node_modules/react-plotly.js/factory.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = plotComponentFactory;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// The naming convention is:\n//   - events are attached as `'plotly_' + eventName.toLowerCase()`\n//   - react props are `'on' + eventName`\nvar eventNames = ['AfterExport', 'AfterPlot', 'Animated', 'AnimatingFrame', 'AnimationInterrupted', 'AutoSize', 'BeforeExport', 'BeforeHover', 'ButtonClicked', 'Click', 'ClickAnnotation', 'Deselect', 'DoubleClick', 'Framework', 'Hover', 'LegendClick', 'LegendDoubleClick', 'Relayout', 'Relayouting', 'Restyle', 'Redraw', 'Selected', 'Selecting', 'SliderChange', 'SliderEnd', 'SliderStart', 'SunburstClick', 'Transitioning', 'TransitionInterrupted', 'Unhover', 'WebGlContextLost'];\nvar updateEvents = ['plotly_restyle', 'plotly_redraw', 'plotly_relayout', 'plotly_relayouting', 'plotly_doubleclick', 'plotly_animated', 'plotly_sunburstclick']; // Check if a window is available since SSR (server-side rendering)\n// breaks unnecessarily if you try to use it server-side.\n\nvar isBrowser = typeof window !== 'undefined';\n\nfunction plotComponentFactory(Plotly) {\n  var PlotlyComponent = /*#__PURE__*/function (_Component) {\n    _inherits(PlotlyComponent, _Component);\n\n    var _super = _createSuper(PlotlyComponent);\n\n    function PlotlyComponent(props) {\n      var _this;\n\n      _classCallCheck(this, PlotlyComponent);\n\n      _this = _super.call(this, props);\n      _this.p = Promise.resolve();\n      _this.resizeHandler = null;\n      _this.handlers = {};\n      _this.syncWindowResize = _this.syncWindowResize.bind(_assertThisInitialized(_this));\n      _this.syncEventHandlers = _this.syncEventHandlers.bind(_assertThisInitialized(_this));\n      _this.attachUpdateEvents = _this.attachUpdateEvents.bind(_assertThisInitialized(_this));\n      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n      _this.handleUpdate = _this.handleUpdate.bind(_assertThisInitialized(_this));\n      _this.figureCallback = _this.figureCallback.bind(_assertThisInitialized(_this));\n      _this.updatePlotly = _this.updatePlotly.bind(_assertThisInitialized(_this));\n      return _this;\n    }\n\n    _createClass(PlotlyComponent, [{\n      key: \"updatePlotly\",\n      value: function updatePlotly(shouldInvokeResizeHandler, figureCallbackFunction, shouldAttachUpdateEvents) {\n        var _this2 = this;\n\n        this.p = this.p.then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          if (!_this2.el) {\n            throw new Error('Missing element reference');\n          } // eslint-disable-next-line consistent-return\n\n\n          return Plotly.react(_this2.el, {\n            data: _this2.props.data,\n            layout: _this2.props.layout,\n            config: _this2.props.config,\n            frames: _this2.props.frames\n          });\n        }).then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          _this2.syncWindowResize(shouldInvokeResizeHandler);\n\n          _this2.syncEventHandlers();\n\n          _this2.figureCallback(figureCallbackFunction);\n\n          if (shouldAttachUpdateEvents) {\n            _this2.attachUpdateEvents();\n          }\n        })[\"catch\"](function (err) {\n          if (_this2.props.onError) {\n            _this2.props.onError(err);\n          }\n        });\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.unmounting = false;\n        this.updatePlotly(true, this.props.onInitialized, true);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this.unmounting = false; // frames *always* changes identity so fall back to check length only :(\n\n        var numPrevFrames = prevProps.frames && prevProps.frames.length ? prevProps.frames.length : 0;\n        var numNextFrames = this.props.frames && this.props.frames.length ? this.props.frames.length : 0;\n        var figureChanged = !(prevProps.layout === this.props.layout && prevProps.data === this.props.data && prevProps.config === this.props.config && numNextFrames === numPrevFrames);\n        var revisionDefined = prevProps.revision !== void 0;\n        var revisionChanged = prevProps.revision !== this.props.revision;\n\n        if (!figureChanged && (!revisionDefined || revisionDefined && !revisionChanged)) {\n          return;\n        }\n\n        this.updatePlotly(false, this.props.onUpdate, false);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.unmounting = true;\n        this.figureCallback(this.props.onPurge);\n\n        if (this.resizeHandler && isBrowser) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n\n        this.removeUpdateEvents();\n        Plotly.purge(this.el);\n      }\n    }, {\n      key: \"attachUpdateEvents\",\n      value: function attachUpdateEvents() {\n        var _this3 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this3.el.on(updateEvent, _this3.handleUpdate);\n        });\n      }\n    }, {\n      key: \"removeUpdateEvents\",\n      value: function removeUpdateEvents() {\n        var _this4 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this4.el.removeListener(updateEvent, _this4.handleUpdate);\n        });\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this.figureCallback(this.props.onUpdate);\n      }\n    }, {\n      key: \"figureCallback\",\n      value: function figureCallback(callback) {\n        if (typeof callback === 'function') {\n          var _this$el = this.el,\n              data = _this$el.data,\n              layout = _this$el.layout;\n          var frames = this.el._transitionData ? this.el._transitionData._frames : null;\n          var figure = {\n            data: data,\n            layout: layout,\n            frames: frames\n          };\n          callback(figure, this.el);\n        }\n      }\n    }, {\n      key: \"syncWindowResize\",\n      value: function syncWindowResize(invoke) {\n        var _this5 = this;\n\n        if (!isBrowser) {\n          return;\n        }\n\n        if (this.props.useResizeHandler && !this.resizeHandler) {\n          this.resizeHandler = function () {\n            return Plotly.Plots.resize(_this5.el);\n          };\n\n          window.addEventListener('resize', this.resizeHandler);\n\n          if (invoke) {\n            this.resizeHandler();\n          }\n        } else if (!this.props.useResizeHandler && this.resizeHandler) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n      }\n    }, {\n      key: \"getRef\",\n      value: function getRef(el) {\n        this.el = el;\n\n        if (this.props.debug && isBrowser) {\n          window.gd = this.el;\n        }\n      } // Attach and remove event handlers as they're added or removed from props:\n\n    }, {\n      key: \"syncEventHandlers\",\n      value: function syncEventHandlers() {\n        var _this6 = this;\n\n        eventNames.forEach(function (eventName) {\n          var prop = _this6.props['on' + eventName];\n          var handler = _this6.handlers[eventName];\n          var hasHandler = Boolean(handler);\n\n          if (prop && !hasHandler) {\n            _this6.addEventHandler(eventName, prop);\n          } else if (!prop && hasHandler) {\n            // Needs to be removed:\n            _this6.removeEventHandler(eventName);\n          } else if (prop && hasHandler && prop !== handler) {\n            // replace the handler\n            _this6.removeEventHandler(eventName);\n\n            _this6.addEventHandler(eventName, prop);\n          }\n        });\n      }\n    }, {\n      key: \"addEventHandler\",\n      value: function addEventHandler(eventName, prop) {\n        this.handlers[eventName] = prop;\n        this.el.on(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n      }\n    }, {\n      key: \"removeEventHandler\",\n      value: function removeEventHandler(eventName) {\n        this.el.removeListener(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n        delete this.handlers[eventName];\n      }\n    }, {\n      key: \"getPlotlyEventName\",\n      value: function getPlotlyEventName(eventName) {\n        return 'plotly_' + eventName.toLowerCase();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          id: this.props.divId,\n          style: this.props.style,\n          ref: this.getRef,\n          className: this.props.className\n        });\n      }\n    }]);\n\n    return PlotlyComponent;\n  }(_react.Component);\n\n  PlotlyComponent.propTypes = {\n    data: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    config: _propTypes[\"default\"].object,\n    layout: _propTypes[\"default\"].object,\n    frames: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    revision: _propTypes[\"default\"].number,\n    onInitialized: _propTypes[\"default\"].func,\n    onPurge: _propTypes[\"default\"].func,\n    onError: _propTypes[\"default\"].func,\n    onUpdate: _propTypes[\"default\"].func,\n    debug: _propTypes[\"default\"].bool,\n    style: _propTypes[\"default\"].object,\n    className: _propTypes[\"default\"].string,\n    useResizeHandler: _propTypes[\"default\"].bool,\n    divId: _propTypes[\"default\"].string\n  };\n  eventNames.forEach(function (eventName) {\n    PlotlyComponent.propTypes['on' + eventName] = _propTypes[\"default\"].func;\n  });\n  PlotlyComponent.defaultProps = {\n    debug: false,\n    useResizeHandler: false,\n    data: [],\n    style: {\n      position: 'relative',\n      display: 'inline-block'\n    }\n  };\n  return PlotlyComponent;\n}\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL2ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIscUNBQXFDLG1CQUFPLENBQUMsd0dBQU87O0FBRXBELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZOztBQUU1RCx1Q0FBdUMsdUNBQXVDOztBQUU5RSxpREFBaUQsZ0RBQWdELHVDQUF1QyxzQ0FBc0Msb0ZBQW9GLDREQUE0RDs7QUFFOVQscURBQXFELDZDQUE2QyxjQUFjLDhFQUE4RSxTQUFTLG9CQUFvQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIseUJBQXlCLGFBQWEsMEJBQTBCOztBQUUzeEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHOztBQUU1WSxpQ0FBaUMsMEdBQTBHLGlCQUFpQixhQUFhOztBQUV6SyxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GOztBQUUxUCx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCw4QkFBOEIsdUdBQXVHLG1EQUFtRDs7QUFFeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0s7QUFDbEs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2xjYW5fY2VzdGVhbXVwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBsb3RseS5qcy9mYWN0b3J5LmpzPzIyYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxvdENvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIFRoZSBuYW1pbmcgY29udmVudGlvbiBpczpcbi8vICAgLSBldmVudHMgYXJlIGF0dGFjaGVkIGFzIGAncGxvdGx5XycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKWBcbi8vICAgLSByZWFjdCBwcm9wcyBhcmUgYCdvbicgKyBldmVudE5hbWVgXG52YXIgZXZlbnROYW1lcyA9IFsnQWZ0ZXJFeHBvcnQnLCAnQWZ0ZXJQbG90JywgJ0FuaW1hdGVkJywgJ0FuaW1hdGluZ0ZyYW1lJywgJ0FuaW1hdGlvbkludGVycnVwdGVkJywgJ0F1dG9TaXplJywgJ0JlZm9yZUV4cG9ydCcsICdCZWZvcmVIb3ZlcicsICdCdXR0b25DbGlja2VkJywgJ0NsaWNrJywgJ0NsaWNrQW5ub3RhdGlvbicsICdEZXNlbGVjdCcsICdEb3VibGVDbGljaycsICdGcmFtZXdvcmsnLCAnSG92ZXInLCAnTGVnZW5kQ2xpY2snLCAnTGVnZW5kRG91YmxlQ2xpY2snLCAnUmVsYXlvdXQnLCAnUmVsYXlvdXRpbmcnLCAnUmVzdHlsZScsICdSZWRyYXcnLCAnU2VsZWN0ZWQnLCAnU2VsZWN0aW5nJywgJ1NsaWRlckNoYW5nZScsICdTbGlkZXJFbmQnLCAnU2xpZGVyU3RhcnQnLCAnU3VuYnVyc3RDbGljaycsICdUcmFuc2l0aW9uaW5nJywgJ1RyYW5zaXRpb25JbnRlcnJ1cHRlZCcsICdVbmhvdmVyJywgJ1dlYkdsQ29udGV4dExvc3QnXTtcbnZhciB1cGRhdGVFdmVudHMgPSBbJ3Bsb3RseV9yZXN0eWxlJywgJ3Bsb3RseV9yZWRyYXcnLCAncGxvdGx5X3JlbGF5b3V0JywgJ3Bsb3RseV9yZWxheW91dGluZycsICdwbG90bHlfZG91YmxlY2xpY2snLCAncGxvdGx5X2FuaW1hdGVkJywgJ3Bsb3RseV9zdW5idXJzdGNsaWNrJ107IC8vIENoZWNrIGlmIGEgd2luZG93IGlzIGF2YWlsYWJsZSBzaW5jZSBTU1IgKHNlcnZlci1zaWRlIHJlbmRlcmluZylcbi8vIGJyZWFrcyB1bm5lY2Vzc2FyaWx5IGlmIHlvdSB0cnkgdG8gdXNlIGl0IHNlcnZlci1zaWRlLlxuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIHBsb3RDb21wb25lbnRGYWN0b3J5KFBsb3RseSkge1xuICB2YXIgUGxvdGx5Q29tcG9uZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFBsb3RseUNvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBsb3RseUNvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBQbG90bHlDb21wb25lbnQocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsb3RseUNvbXBvbmVudCk7XG5cbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgICAgX3RoaXMucCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XG4gICAgICBfdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgX3RoaXMuc3luY1dpbmRvd1Jlc2l6ZSA9IF90aGlzLnN5bmNXaW5kb3dSZXNpemUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5zeW5jRXZlbnRIYW5kbGVycyA9IF90aGlzLnN5bmNFdmVudEhhbmRsZXJzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuYXR0YWNoVXBkYXRlRXZlbnRzID0gX3RoaXMuYXR0YWNoVXBkYXRlRXZlbnRzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuZ2V0UmVmID0gX3RoaXMuZ2V0UmVmLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuaGFuZGxlVXBkYXRlID0gX3RoaXMuaGFuZGxlVXBkYXRlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuZmlndXJlQ2FsbGJhY2sgPSBfdGhpcy5maWd1cmVDYWxsYmFjay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLnVwZGF0ZVBsb3RseSA9IF90aGlzLnVwZGF0ZVBsb3RseS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGxvdGx5Q29tcG9uZW50LCBbe1xuICAgICAga2V5OiBcInVwZGF0ZVBsb3RseVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBsb3RseShzaG91bGRJbnZva2VSZXNpemVIYW5kbGVyLCBmaWd1cmVDYWxsYmFja0Z1bmN0aW9uLCBzaG91bGRBdHRhY2hVcGRhdGVFdmVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5wID0gdGhpcy5wLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczIudW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3RoaXMyLmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZWxlbWVudCByZWZlcmVuY2UnKTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXG5cbiAgICAgICAgICByZXR1cm4gUGxvdGx5LnJlYWN0KF90aGlzMi5lbCwge1xuICAgICAgICAgICAgZGF0YTogX3RoaXMyLnByb3BzLmRhdGEsXG4gICAgICAgICAgICBsYXlvdXQ6IF90aGlzMi5wcm9wcy5sYXlvdXQsXG4gICAgICAgICAgICBjb25maWc6IF90aGlzMi5wcm9wcy5jb25maWcsXG4gICAgICAgICAgICBmcmFtZXM6IF90aGlzMi5wcm9wcy5mcmFtZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi51bm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMyLnN5bmNXaW5kb3dSZXNpemUoc2hvdWxkSW52b2tlUmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICBfdGhpczIuc3luY0V2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgICAgIF90aGlzMi5maWd1cmVDYWxsYmFjayhmaWd1cmVDYWxsYmFja0Z1bmN0aW9uKTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdHRhY2hVcGRhdGVFdmVudHMpIHtcbiAgICAgICAgICAgIF90aGlzMi5hdHRhY2hVcGRhdGVFdmVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChfdGhpczIucHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgX3RoaXMyLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVQbG90bHkodHJ1ZSwgdGhpcy5wcm9wcy5vbkluaXRpYWxpemVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICB0aGlzLnVubW91bnRpbmcgPSBmYWxzZTsgLy8gZnJhbWVzICphbHdheXMqIGNoYW5nZXMgaWRlbnRpdHkgc28gZmFsbCBiYWNrIHRvIGNoZWNrIGxlbmd0aCBvbmx5IDooXG5cbiAgICAgICAgdmFyIG51bVByZXZGcmFtZXMgPSBwcmV2UHJvcHMuZnJhbWVzICYmIHByZXZQcm9wcy5mcmFtZXMubGVuZ3RoID8gcHJldlByb3BzLmZyYW1lcy5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgbnVtTmV4dEZyYW1lcyA9IHRoaXMucHJvcHMuZnJhbWVzICYmIHRoaXMucHJvcHMuZnJhbWVzLmxlbmd0aCA/IHRoaXMucHJvcHMuZnJhbWVzLmxlbmd0aCA6IDA7XG4gICAgICAgIHZhciBmaWd1cmVDaGFuZ2VkID0gIShwcmV2UHJvcHMubGF5b3V0ID09PSB0aGlzLnByb3BzLmxheW91dCAmJiBwcmV2UHJvcHMuZGF0YSA9PT0gdGhpcy5wcm9wcy5kYXRhICYmIHByZXZQcm9wcy5jb25maWcgPT09IHRoaXMucHJvcHMuY29uZmlnICYmIG51bU5leHRGcmFtZXMgPT09IG51bVByZXZGcmFtZXMpO1xuICAgICAgICB2YXIgcmV2aXNpb25EZWZpbmVkID0gcHJldlByb3BzLnJldmlzaW9uICE9PSB2b2lkIDA7XG4gICAgICAgIHZhciByZXZpc2lvbkNoYW5nZWQgPSBwcmV2UHJvcHMucmV2aXNpb24gIT09IHRoaXMucHJvcHMucmV2aXNpb247XG5cbiAgICAgICAgaWYgKCFmaWd1cmVDaGFuZ2VkICYmICghcmV2aXNpb25EZWZpbmVkIHx8IHJldmlzaW9uRGVmaW5lZCAmJiAhcmV2aXNpb25DaGFuZ2VkKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUGxvdGx5KGZhbHNlLCB0aGlzLnByb3BzLm9uVXBkYXRlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlndXJlQ2FsbGJhY2sodGhpcy5wcm9wcy5vblB1cmdlKTtcblxuICAgICAgICBpZiAodGhpcy5yZXNpemVIYW5kbGVyICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW92ZVVwZGF0ZUV2ZW50cygpO1xuICAgICAgICBQbG90bHkucHVyZ2UodGhpcy5lbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImF0dGFjaFVwZGF0ZUV2ZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaFVwZGF0ZUV2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVsIHx8ICF0aGlzLmVsLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZUV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmVsLm9uKHVwZGF0ZUV2ZW50LCBfdGhpczMuaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZVVwZGF0ZUV2ZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwZGF0ZUV2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVsIHx8ICF0aGlzLmVsLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZUV2ZW50KSB7XG4gICAgICAgICAgX3RoaXM0LmVsLnJlbW92ZUxpc3RlbmVyKHVwZGF0ZUV2ZW50LCBfdGhpczQuaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5maWd1cmVDYWxsYmFjayh0aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlndXJlQ2FsbGJhY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWd1cmVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgICAgZGF0YSA9IF90aGlzJGVsLmRhdGEsXG4gICAgICAgICAgICAgIGxheW91dCA9IF90aGlzJGVsLmxheW91dDtcbiAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5lbC5fdHJhbnNpdGlvbkRhdGEgPyB0aGlzLmVsLl90cmFuc2l0aW9uRGF0YS5fZnJhbWVzIDogbnVsbDtcbiAgICAgICAgICB2YXIgZmlndXJlID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgZnJhbWVzOiBmcmFtZXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrKGZpZ3VyZSwgdGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3luY1dpbmRvd1Jlc2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNXaW5kb3dSZXNpemUoaW52b2tlKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMudXNlUmVzaXplSGFuZGxlciAmJiAhdGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFBsb3RseS5QbG90cy5yZXNpemUoX3RoaXM1LmVsKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICBpZiAoaW52b2tlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJvcHMudXNlUmVzaXplSGFuZGxlciAmJiB0aGlzLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFJlZlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZihlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGVidWcgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgd2luZG93LmdkID0gdGhpcy5lbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBdHRhY2ggYW5kIHJlbW92ZSBldmVudCBoYW5kbGVycyBhcyB0aGV5J3JlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSBwcm9wczpcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzeW5jRXZlbnRIYW5kbGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wID0gX3RoaXM2LnByb3BzWydvbicgKyBldmVudE5hbWVdO1xuICAgICAgICAgIHZhciBoYW5kbGVyID0gX3RoaXM2LmhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgdmFyIGhhc0hhbmRsZXIgPSBCb29sZWFuKGhhbmRsZXIpO1xuXG4gICAgICAgICAgaWYgKHByb3AgJiYgIWhhc0hhbmRsZXIpIHtcbiAgICAgICAgICAgIF90aGlzNi5hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBwcm9wKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9wICYmIGhhc0hhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIE5lZWRzIHRvIGJlIHJlbW92ZWQ6XG4gICAgICAgICAgICBfdGhpczYucmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wICYmIGhhc0hhbmRsZXIgJiYgcHJvcCAhPT0gaGFuZGxlcikge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgX3RoaXM2LnJlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUpO1xuXG4gICAgICAgICAgICBfdGhpczYuYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRIYW5kbGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcHJvcCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0gPSBwcm9wO1xuICAgICAgICB0aGlzLmVsLm9uKHRoaXMuZ2V0UGxvdGx5RXZlbnROYW1lKGV2ZW50TmFtZSksIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50SGFuZGxlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVMaXN0ZW5lcih0aGlzLmdldFBsb3RseUV2ZW50TmFtZShldmVudE5hbWUpLCB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0pO1xuICAgICAgICBkZWxldGUgdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQbG90bHlFdmVudE5hbWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbG90bHlFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiAncGxvdGx5XycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgaWQ6IHRoaXMucHJvcHMuZGl2SWQsXG4gICAgICAgICAgc3R5bGU6IHRoaXMucHJvcHMuc3R5bGUsXG4gICAgICAgICAgcmVmOiB0aGlzLmdldFJlZixcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQbG90bHlDb21wb25lbnQ7XG4gIH0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbiAgUGxvdGx5Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5hcnJheU9mKF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm9iamVjdCksXG4gICAgY29uZmlnOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gICAgbGF5b3V0OiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gICAgZnJhbWVzOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5hcnJheU9mKF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm9iamVjdCksXG4gICAgcmV2aXNpb246IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgICBvbkluaXRpYWxpemVkOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5mdW5jLFxuICAgIG9uUHVyZ2U6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICAgb25FcnJvcjogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uZnVuYyxcbiAgICBvblVwZGF0ZTogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uZnVuYyxcbiAgICBkZWJ1ZzogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uYm9vbCxcbiAgICBzdHlsZTogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uc3RyaW5nLFxuICAgIHVzZVJlc2l6ZUhhbmRsZXI6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmJvb2wsXG4gICAgZGl2SWQ6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLnN0cmluZ1xuICB9O1xuICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIFBsb3RseUNvbXBvbmVudC5wcm9wVHlwZXNbJ29uJyArIGV2ZW50TmFtZV0gPSBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5mdW5jO1xuICB9KTtcbiAgUGxvdGx5Q29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgdXNlUmVzaXplSGFuZGxlcjogZmFsc2UsXG4gICAgZGF0YTogW10sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICB9XG4gIH07XG4gIHJldHVybiBQbG90bHlDb21wb25lbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-plotly.js/react-plotly.js":
/*!******************************************************!*\
  !*** ./node_modules/react-plotly.js/react-plotly.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ \"(ssr)/./node_modules/react-plotly.js/factory.js\"));\n\nvar _plotly = _interopRequireDefault(__webpack_require__(/*! plotly.js/dist/plotly */ \"(ssr)/./node_modules/plotly.js/dist/plotly.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar PlotComponent = (0, _factory[\"default\"])(_plotly[\"default\"]);\nvar _default = PlotComponent;\nexports[\"default\"] = _default;\n//# sourceMappingURL=react-plotly.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL3JlYWN0LXBsb3RseS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHNDQUFzQyxtQkFBTyxDQUFDLGtFQUFXOztBQUV6RCxxQ0FBcUMsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRXBFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2xjYW5fY2VzdGVhbXVwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBsb3RseS5qcy9yZWFjdC1wbG90bHkuanM/Y2IwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2ZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZhY3RvcnlcIikpO1xuXG52YXIgX3Bsb3RseSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInBsb3RseS5qcy9kaXN0L3Bsb3RseVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgUGxvdENvbXBvbmVudCA9ICgwLCBfZmFjdG9yeVtcImRlZmF1bHRcIl0pKF9wbG90bHlbXCJkZWZhdWx0XCJdKTtcbnZhciBfZGVmYXVsdCA9IFBsb3RDb21wb25lbnQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcGxvdGx5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/react-plotly.js\n");

/***/ })

};
;