"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@maptiler";
exports.ids = ["vendor-chunks/@maptiler"];
exports.modules = {

/***/ "(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.css":
/*!**********************************************************!*\
  !*** ./node_modules/@maptiler/sdk/dist/maptiler-sdk.css ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"5100ecd4251c\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2xjYW5fY2VzdGVhbXVwLy4vbm9kZV9tb2R1bGVzL0BtYXB0aWxlci9zZGsvZGlzdC9tYXB0aWxlci1zZGsuY3NzPzU2YTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI1MTAwZWNkNDI1MWNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@maptiler/client/dist/maptiler-client.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientConfig: () => (/* binding */ ClientConfig),\n/* harmony export */   LanguageGeocoding: () => (/* binding */ LanguageGeocoding),\n/* harmony export */   MapStyle: () => (/* binding */ MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* binding */ MapStyleVariant),\n/* harmony export */   ReferenceMapStyle: () => (/* binding */ ReferenceMapStyle),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* binding */ bufferToPixelDataBrowser),\n/* harmony export */   circumferenceAtLatitude: () => (/* binding */ circumferenceAtLatitude),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   coordinates: () => (/* binding */ coordinates),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   elevation: () => (/* binding */ elevation),\n/* harmony export */   expandMapStyle: () => (/* binding */ expandMapStyle),\n/* harmony export */   geocoding: () => (/* binding */ geocoding),\n/* harmony export */   geolocation: () => (/* binding */ geolocation),\n/* harmony export */   getAutoLanguageGeocoding: () => (/* binding */ getAutoLanguageGeocoding),\n/* harmony export */   getBufferToPixelDataParser: () => (/* binding */ getBufferToPixelDataParser),\n/* harmony export */   getTileCache: () => (/* binding */ getTileCache),\n/* harmony export */   mapStylePresetList: () => (/* binding */ mapStylePresetList),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   misc: () => (/* binding */ misc),\n/* harmony export */   staticMaps: () => (/* binding */ staticMaps),\n/* harmony export */   styleToStyle: () => (/* binding */ styleToStyle)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n\n\nfunction tryGettingFetch() {\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n  return null;\n}\nclass ClientConfig {\n  constructor() {\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n    /**\n     * The fetch function. To be set if in Node < 18, otherwise\n     * will be automatically resolved.\n     */\n    this._fetch = tryGettingFetch();\n    /**\n     * Number of tiles to keep in cache\n     */\n    this.tileCacheSize = 200;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    this._fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return this._fetch;\n  }\n}\nconst config = new ClientConfig();\n\nconst LanguageGeocoding = {\n  AUTO: \"auto\",\n  ALBANIAN: \"sq\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\"\n};\nconst languageCodeSet = new Set(Object.values(LanguageGeocoding));\nfunction getAutoLanguageGeocoding() {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n  }\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).filter((l) => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : LanguageGeocoding.ENGLISH;\n}\n\nasync function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\"\n    );\n  }\n  return config.fetch(resource, options);\n}\n\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\"\n};\nObject.freeze(defaults);\n\nclass ServiceError extends Error {\n  constructor(res, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n    this.res = res;\n  }\n}\n\nconst customMessages$4 = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction addLanguageGeocodingOptions(searchParams, options) {\n  const { language } = options;\n  if (language == void 0) {\n    return;\n  }\n  const languages = Array.from(\n    new Set(\n      (Array.isArray(language) ? language : [language]).map(\n        (lang) => lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang\n      )\n    )\n  ).join(\",\");\n  searchParams.set(\"language\", languages);\n}\nfunction addCommonForwardAndReverseGeocodingOptions(searchParams, options) {\n  const { apiKey, limit, types, excludeTypes } = options;\n  searchParams.set(\"key\", apiKey ?? config.apiKey);\n  if (limit != void 0) {\n    searchParams.set(\"limit\", String(limit));\n  }\n  if (types != void 0) {\n    searchParams.set(\"types\", types.join(\",\"));\n  }\n  if (excludeTypes != void 0) {\n    searchParams.set(\"excludeTypes\", String(excludeTypes));\n  }\n  addLanguageGeocodingOptions(searchParams, options);\n}\nfunction addForwardGeocodingOptions(searchParams, options) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n  const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;\n  if (bbox != void 0) {\n    searchParams.set(\"bbox\", bbox.join(\",\"));\n  }\n  if (proximity != void 0) {\n    searchParams.set(\n      \"proximity\",\n      proximity === \"ip\" ? proximity : proximity.join(\",\")\n    );\n  }\n  if (country != void 0) {\n    searchParams.set(\"country\", country.join(\",\"));\n  }\n  if (fuzzyMatch != void 0) {\n    searchParams.set(\"fuzzyMatch\", fuzzyMatch ? \"true\" : \"false\");\n  }\n  if (autocomplete != void 0) {\n    searchParams.set(\"autocomplete\", autocomplete ? \"true\" : \"false\");\n  }\n}\nasync function forward(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n  const { searchParams } = endpoint;\n  addForwardGeocodingOptions(searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function reverse(position, options = {}) {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL\n  );\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function byId(id, options = {}) {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function batch$1(queries, options = {}) {\n  if (!queries.length) {\n    return [];\n  }\n  const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(\";\");\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL\n  );\n  const { searchParams } = endpoint;\n  addForwardGeocodingOptions(searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return queries.length === 1 ? [obj] : obj;\n}\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch: batch$1,\n  language: LanguageGeocoding\n};\n\nconst customMessages$3 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function info(options = {}) {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$3 ? customMessages$3[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst geolocation = {\n  info\n};\n\nconst customMessages$2 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function search(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function transform(positions, options = {}) {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(\";\");\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations) ? options.operations : [options.operations]).join(\"|\")\n    );\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst coordinates = {\n  search,\n  transform\n};\n\nconst customMessages$1 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function get(dataId, options = {}) {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$1 ? customMessages$1[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst data = {\n  get\n};\n\nfunction expandMapStyle(style) {\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n  return expandedStyle;\n}\nclass MapStyleVariant {\n  constructor(name, variantType, id, referenceStyle, description, imageURL) {\n    this.name = name;\n    this.variantType = variantType;\n    this.id = id;\n    this.referenceStyle = referenceStyle;\n    this.description = description;\n    this.imageURL = imageURL;\n  }\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  getFullName() {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType() {\n    return this.variantType;\n  }\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get the human-friendly description\n   */\n  getDescription() {\n    return this.description;\n  }\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle() {\n    return this.referenceStyle;\n  }\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return this.referenceStyle.getVariant(variantType);\n  }\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants() {\n    return this.referenceStyle.getVariants().filter((v) => v !== this);\n  }\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL() {\n    return this.imageURL;\n  }\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL() {\n    return expandMapStyle(this.getId());\n  }\n}\nclass ReferenceMapStyle {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Variants that belong to this reference style, key being the reference type\n     */\n    this.variants = {};\n    /**\n     * Variants that belong to this reference style, ordered by relevance\n     */\n    this.orderedVariants = [];\n  }\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return variantType in this.variants;\n  }\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];\n  }\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants() {\n    return Object.values(this.variants);\n  }\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant() {\n    return this.orderedVariants[0];\n  }\n}\nconst mapStylePresetList = [\n  {\n    referenceStyleID: \"STREETS\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BASIC\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  }\n];\nfunction makeReferenceStyleProxy(referenceStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop)) {\n        return target.getVariant(prop);\n      }\n      if (prop.toString().toUpperCase() === prop) {\n        return referenceStyle.getDefaultVariant();\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction buildMapStyles() {\n  const mapStyle = {};\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)\n    );\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name,\n        // name\n        variantInfo.variantType,\n        // variantType\n        variantInfo.id,\n        // id\n        refStyle,\n        // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL\n        // imageURL\n      );\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\nconst MapStyle = buildMapStyles();\n\nfunction extractLineStrings(geoJson) {\n  const lineStrings = [];\n  function extractFromGeometry(geometry) {\n    if (geometry.type === \"LineString\" || geometry.type === \"MultiLineString\") {\n      lineStrings.push(geometry);\n    }\n  }\n  function extractFromFeature(feature) {\n    if (feature.geometry) {\n      extractFromGeometry(feature.geometry);\n    }\n  }\n  function extractFromFeatureCollection(collection) {\n    for (const feature of collection.features) {\n      if (feature.type === \"Feature\") {\n        extractFromFeature(feature);\n      } else if (feature.type === \"FeatureCollection\") {\n        extractFromFeatureCollection(feature);\n      }\n    }\n  }\n  if (geoJson.type === \"Feature\") {\n    extractFromFeature(geoJson);\n  } else if (geoJson.type === \"FeatureCollection\") {\n    extractFromFeatureCollection(geoJson);\n  } else {\n    extractFromGeometry(geoJson);\n  }\n  return lineStrings;\n}\nfunction getSqSegDist(p, p1, p2) {\n  let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  let maxSqDist = sqTolerance, index;\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance) {\n  if (points.length <= 2) {\n    return points;\n  }\n  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\nconst misc = {\n  extractLineStrings,\n  simplify\n};\n\nfunction staticMapMarkerToString(marker, includeColor = true) {\n  let str = `${marker[0]},${marker[1]}`;\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n  return str;\n}\nfunction simplifyAndStringify(path, maxNbChar = 3e3) {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 5e-6;\n  const toleranceStep = 1e-5;\n  while (str.length > maxNbChar) {\n    const simplerPath = misc.simplify(path, tolerance);\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n  return str;\n}\nfunction centered(center, zoom, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction bounded(boundingBox, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction automatic(options = {}) {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic\n};\n\nconst EARTH_RADIUS = 63710088e-1;\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;\nfunction longitudeToMercatorX(lng) {\n  return (180 + lng) / 360;\n}\nfunction latitudeToMercatorY(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nfunction wgs84ToMercator(position) {\n  const wrappedPos = wrapWgs84(position);\n  return [\n    longitudeToMercatorX(wrappedPos[0]),\n    latitudeToMercatorY(wrappedPos[1])\n  ];\n}\nfunction mercatorXToLongitude(x) {\n  return x * 360 - 180;\n}\nfunction mercatorYToLatitude(y) {\n  const y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nfunction mercatorToWgs84(position) {\n  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];\n}\nfunction haversineDistanceWgs84(from, to) {\n  const rad = Math.PI / 180;\n  const lat1 = from[1] * rad;\n  const lat2 = to[1] * rad;\n  const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);\n  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));\n  return maxMeters;\n}\nfunction haversineCumulatedDistanceWgs84(positions) {\n  const cumulatedDistance = Array(positions.length);\n  cumulatedDistance[0] = 0;\n  const l = cumulatedDistance.length;\n  for (let i = 1; i < l; i++) {\n    cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];\n  }\n  return cumulatedDistance;\n}\nfunction wrapWgs84(position) {\n  const lng = position[0];\n  const lat = position[1];\n  const d = 360;\n  const w = ((lng + 180) % d + d) % d - 180;\n  const wrapLong = w === -180 ? 180 : w;\n  return [wrapLong, lat];\n}\nfunction circumferenceAtLatitude(latitude) {\n  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\n}\nfunction mercatorToTileIndex(position, zoom, strict = true) {\n  const numberOfTilePerAxis = 2 ** zoom;\n  const fIndex = [\n    position[0] * numberOfTilePerAxis,\n    position[1] * numberOfTilePerAxis\n  ];\n  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;\n}\nfunction wgs84ToTileIndex(position, zoom, strict = true) {\n  const merc = wgs84ToMercator(position);\n  return mercatorToTileIndex(merc, zoom, strict);\n}\nfunction toRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction toDegrees(radians) {\n  return radians * 180 / Math.PI;\n}\nfunction haversineIntermediateWgs84(pos1, pos2, ratio) {\n  const d = haversineDistanceWgs84(pos1, pos2);\n  const \\u03BB1 = toRadians(pos1[0]);\n  const \\u03C61 = toRadians(pos1[1]);\n  const \\u03BB2 = toRadians(pos2[0]);\n  const \\u03C62 = toRadians(pos2[1]);\n  const \\u03B4 = d / EARTH_RADIUS;\n  const a = Math.sin((1 - ratio) * \\u03B4) / Math.sin(\\u03B4);\n  const b = Math.sin(ratio * \\u03B4) / Math.sin(\\u03B4);\n  const x = a * Math.cos(\\u03C61) * Math.cos(\\u03BB1) + b * Math.cos(\\u03C62) * Math.cos(\\u03BB2);\n  const y = a * Math.cos(\\u03C61) * Math.sin(\\u03BB1) + b * Math.cos(\\u03C62) * Math.sin(\\u03BB2);\n  const z = a * Math.sin(\\u03C61) + b * Math.sin(\\u03C62);\n  const \\u03C63 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const \\u03BB3 = Math.atan2(y, x);\n  return [toDegrees(\\u03BB3), toDegrees(\\u03C63)];\n}\nconst math = {\n  EARTH_RADIUS,\n  EARTH_CIRCUMFERENCE,\n  longitudeToMercatorX,\n  latitudeToMercatorY,\n  wgs84ToMercator,\n  mercatorXToLongitude,\n  mercatorYToLatitude,\n  mercatorToWgs84,\n  haversineDistanceWgs84,\n  wrapWgs84,\n  circumferenceAtLatitude,\n  mercatorToTileIndex,\n  wgs84ToTileIndex,\n  toRadians,\n  toDegrees,\n  haversineIntermediateWgs84,\n  haversineCumulatedDistanceWgs84\n};\n\nlet tileCache = null;\nfunction getTileCache() {\n  if (!tileCache) {\n    tileCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ maxSize: config.tileCacheSize });\n  }\n  return tileCache;\n}\nasync function bufferToPixelDataBrowser(buff) {\n  const blob = new Blob([buff]);\n  const imageBitmap = await createImageBitmap(blob);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = imageBitmap.width;\n  canvas.height = imageBitmap.height;\n  ctx.drawImage(imageBitmap, 0, 0);\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  return {\n    pixels: imageData.data,\n    width: canvas.width,\n    height: canvas.height,\n    components: imageData.data.length / (canvas.width * canvas.height)\n  };\n}\nfunction getBufferToPixelDataParser() {\n  if (config.bufferToPixelData) {\n    return config.bufferToPixelData;\n  }\n  if (typeof window !== \"undefined\") {\n    return bufferToPixelDataBrowser;\n  }\n  throw new Error(\n    \"An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`\"\n  );\n}\n\nconst terrainTileJsonURL = \"tiles/terrain-rgb-v2/tiles.json\";\nlet terrainTileJson = null;\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function fetchTerrainTileJson(apiKey) {\n  const endpoint = new URL(terrainTileJsonURL, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (res.ok) {\n    terrainTileJson = await res.json();\n    return terrainTileJson;\n  } else {\n    if (!res.ok) {\n      throw new ServiceError(res, customMessages[res.status] ?? \"\");\n    }\n  }\n}\nasync function at(position, options = {}) {\n  const apiKey = options.apiKey ?? config.apiKey;\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndex = math.wgs84ToTileIndex(position, zoom, false);\n  const tileX = ~~tileIndex[0];\n  const tileY = ~~tileIndex[1];\n  if (!terrainTileJson.tiles.length) {\n    throw new Error(\"Terrain tileJSON tile list is empty.\");\n  }\n  const tileID = `terrain_${zoom.toString()}_${tileX.toString()}_${tileY.toString()}`;\n  let tilePixelData;\n  const cache = getTileCache();\n  if (cache.has(tileID)) {\n    tilePixelData = cache.get(tileID);\n  } else {\n    const tileURL = terrainTileJson.tiles[0].replace(\"{x}\", tileX.toString()).replace(\"{y}\", tileY.toString()).replace(\"{z}\", zoom.toString());\n    const tileRes = await callFetch(tileURL);\n    if (!tileRes.ok) {\n      throw new ServiceError(tileRes, customMessages[tileRes.status] ?? \"\");\n    }\n    const tileBuff = await tileRes.arrayBuffer();\n    const tileParser = getBufferToPixelDataParser();\n    tilePixelData = await tileParser(tileBuff);\n    cache.set(tileID, tilePixelData);\n  }\n  const pixelX = ~~(tilePixelData.width * (tileIndex[0] % 1));\n  const pixelY = ~~(tilePixelData.height * (tileIndex[1] % 1));\n  const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n  const R = tilePixelData.pixels[pixelDataIndex];\n  const G = tilePixelData.pixels[pixelDataIndex + 1];\n  const B = tilePixelData.pixels[pixelDataIndex + 2];\n  const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n  return [position[0], position[1], elevation2];\n}\nasync function batch(positions, options = {}) {\n  const apiKey = options.apiKey ?? config.apiKey;\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n  const tileParser = getBufferToPixelDataParser();\n  const tileURLSchema = terrainTileJson.tiles[0];\n  const cache = getTileCache();\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndicesFloats = positions.map(\n    (position) => math.wgs84ToTileIndex(position, zoom, false)\n  );\n  const tileIndicesInteger = tileIndicesFloats.map((index) => [\n    ~~index[0],\n    ~~index[1]\n  ]);\n  const tileIDs = tileIndicesInteger.map(\n    (index) => `terrain_${zoom.toString()}_${index[0].toString()}_${index[1].toString()}`\n  );\n  const uniqueTilesToFetch = Array.from(\n    new Set(tileIDs.filter((tileID) => !cache.has(tileID)))\n  ).map((tileID) => tileID.split(\"_\").slice(1));\n  const tileURLs = uniqueTilesToFetch.map(\n    (zxy) => tileURLSchema.replace(\"{x}\", zxy[1].toString()).replace(\"{y}\", zxy[2].toString()).replace(\"{z}\", zxy[0].toString())\n  );\n  const promisesFetchTiles = tileURLs.map((url) => callFetch(url));\n  const resTiles = await Promise.allSettled(promisesFetchTiles);\n  const fulfilledRes = resTiles.map(\n    (el) => el.status === \"fulfilled\" ? el.value : null\n  ).filter((res) => res);\n  const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);\n  if (fulfilledRes.length !== promisesFetchTiles.length) {\n    throw new Error(\"Some tiles could not be fetched.\");\n  }\n  if (fulfilledRButNotOkRes.length) {\n    throw new ServiceError(\n      fulfilledRButNotOkRes[0],\n      customMessages[fulfilledRButNotOkRes[0].status] ?? \"\"\n    );\n  }\n  const tileArrayBuffers = await Promise.all(\n    fulfilledRes.map((res) => res.arrayBuffer())\n  );\n  if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) {\n    throw new Error(\"Some tiles are not available.\");\n  }\n  const tilePixelDatas = await Promise.all(\n    tileArrayBuffers.map((buff) => tileParser(buff))\n  );\n  tilePixelDatas.forEach((tilePixelData, i) => {\n    const zxy = uniqueTilesToFetch[i];\n    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;\n    cache.set(tileID, tilePixelData);\n  });\n  const elevatedPositions = positions.map((position, i) => {\n    const tileID = tileIDs[i];\n    const tileIndexFloat = tileIndicesFloats[i];\n    const tilePixelData = cache.get(tileID);\n    const pixelX = Math.min(\n      Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)),\n      tilePixelData.width - 1\n    );\n    const pixelY = Math.min(\n      Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)),\n      tilePixelData.height - 1\n    );\n    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n    const R = tilePixelData.pixels[pixelDataIndex];\n    const G = tilePixelData.pixels[pixelDataIndex + 1];\n    const B = tilePixelData.pixels[pixelDataIndex + 2];\n    const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n    return [position[0], position[1], ~~(elevation2 * 1e3) / 1e3];\n  });\n  if (options.smoothingKernelSize) {\n    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;\n    const elevations = elevatedPositions.map((pos) => pos[2]);\n    const kernelSpan = ~~(kernelSize / 2);\n    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {\n      let sum = 0;\n      for (let j = 0; j < kernelSize; j += 1) {\n        const elev = elevations[i - kernelSpan + j];\n        sum += elev;\n      }\n      sum /= kernelSize;\n      elevatedPositions[i][2] = sum;\n    }\n  }\n  return elevatedPositions;\n}\nasync function fromLineString(ls, options = {}) {\n  if (ls.type !== \"LineString\") {\n    throw new Error(\"The provided object is not a GeoJSON LineString\");\n  }\n  const clone = structuredClone(ls);\n  const elevatedPositions = await batch(clone.coordinates, options);\n  clone.coordinates = elevatedPositions;\n  return clone;\n}\nasync function fromMultiLineString(ls, options = {}) {\n  if (ls.type !== \"MultiLineString\") {\n    throw new Error(\"The provided object is not a GeoJSON MultiLineString\");\n  }\n  const clone = structuredClone(ls);\n  const multiLengths = clone.coordinates.map((poss) => poss.length);\n  const flattenPositions = clone.coordinates.flat();\n  const flattenPositionsElevated = await batch(flattenPositions, options);\n  const result = [];\n  let index = 0;\n  for (const length of multiLengths) {\n    result.push(flattenPositionsElevated.slice(index, index + length));\n    index += length;\n  }\n  clone.coordinates = result;\n  return clone;\n}\nconst elevation = {\n  at,\n  batch,\n  fromLineString,\n  fromMultiLineString\n};\n\n\n//# sourceMappingURL=maptiler-client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2NsaWVudC9kaXN0L21hcHRpbGVyLWNsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTLDhCQUE4QixXQUFXLElBQUksY0FBYztBQUM3RjtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzFGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzVztBQUN0VyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZvbGNhbl9jZXN0ZWFtdXAvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2NsaWVudC9kaXN0L21hcHRpbGVyLWNsaWVudC5tanM/YmYxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUXVpY2tMUlUgZnJvbSAncXVpY2stbHJ1JztcblxuZnVuY3Rpb24gdHJ5R2V0dGluZ0ZldGNoKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmV0Y2guYmluZChzZWxmKTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuZmV0Y2gpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmZldGNoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgQ2xpZW50Q29uZmlnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZldGNoIGZ1bmN0aW9uLiBUbyBiZSBzZXQgaWYgaW4gTm9kZSA8IDE4LCBvdGhlcndpc2VcbiAgICAgKiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgdGhpcy5fZmV0Y2ggPSB0cnlHZXR0aW5nRmV0Y2goKTtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGlsZXMgdG8ga2VlcCBpbiBjYWNoZVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlU2l6ZSA9IDIwMDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAqL1xuICBzZXQgYXBpS2V5KGspIHtcbiAgICB0aGlzLl9hcGlLZXkgPSBrO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICovXG4gIGdldCBhcGlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdGhlIGN1c3RvbSBmZXRjaCBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG9uZVxuICAgKi9cbiAgc2V0IGZldGNoKGYpIHtcbiAgICB0aGlzLl9mZXRjaCA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmV0Y2ggZnVjbnRpb25cbiAgICovXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2g7XG4gIH1cbn1cbmNvbnN0IGNvbmZpZyA9IG5ldyBDbGllbnRDb25maWcoKTtcblxuY29uc3QgTGFuZ3VhZ2VHZW9jb2RpbmcgPSB7XG4gIEFVVE86IFwiYXV0b1wiLFxuICBBTEJBTklBTjogXCJzcVwiLFxuICBBUkFCSUM6IFwiYXJcIixcbiAgQVJNRU5JQU46IFwiaHlcIixcbiAgQVpFUkJBSUpBTkk6IFwiYXpcIixcbiAgQkVMT1JVU1NJQU46IFwiYmVcIixcbiAgQk9TTklBTjogXCJic1wiLFxuICBCUkVUT046IFwiYnJcIixcbiAgQlVMR0FSSUFOOiBcImJnXCIsXG4gIENBVEFMQU46IFwiY2FcIixcbiAgQ0hJTkVTRTogXCJ6aFwiLFxuICBDUk9BVElBTjogXCJoclwiLFxuICBDWkVDSDogXCJjc1wiLFxuICBEQU5JU0g6IFwiZGFcIixcbiAgRFVUQ0g6IFwibmxcIixcbiAgRU5HTElTSDogXCJlblwiLFxuICBFU1BFUkFOVE86IFwiZW9cIixcbiAgRVNUT05JQU46IFwiZXRcIixcbiAgRklOTklTSDogXCJmaVwiLFxuICBGUkVOQ0g6IFwiZnJcIixcbiAgRlJJU0lBTjogXCJmeVwiLFxuICBHRU9SR0lBTjogXCJrYVwiLFxuICBHRVJNQU46IFwiZGVcIixcbiAgR1JFRUs6IFwiZWxcIixcbiAgSEVCUkVXOiBcImhlXCIsXG4gIEhVTkdBUklBTjogXCJodVwiLFxuICBJQ0VMQU5ESUM6IFwiaXNcIixcbiAgSVJJU0g6IFwiZ2FcIixcbiAgSVRBTElBTjogXCJpdFwiLFxuICBKQVBBTkVTRTogXCJqYVwiLFxuICBLQU5OQURBOiBcImtuXCIsXG4gIEtBWkFLSDogXCJra1wiLFxuICBLT1JFQU46IFwia29cIixcbiAgUk9NQU5fTEFUSU46IFwibGFcIixcbiAgTEFUVklBTjogXCJsdlwiLFxuICBMSVRIVUFOSUFOOiBcImx0XCIsXG4gIExVWEVNQk9VUkdJU0g6IFwibGJcIixcbiAgTUFDRURPTklBTjogXCJta1wiLFxuICBNQUxURVNFOiBcIm10XCIsXG4gIE5PUldFR0lBTjogXCJub1wiLFxuICBQT0xJU0g6IFwicGxcIixcbiAgUE9SVFVHVUVTRTogXCJwdFwiLFxuICBST01BTklBTjogXCJyb1wiLFxuICBST01BTlNIOiBcInJtXCIsXG4gIFJVU1NJQU46IFwicnVcIixcbiAgU0NPVFRJU0hfR0FFTElDOiBcImdkXCIsXG4gIFNFUkJJQU5fQ1lSSUxMSUM6IFwic3JcIixcbiAgU0xPVkFLOiBcInNrXCIsXG4gIFNMT1ZFTkU6IFwic2xcIixcbiAgU1BBTklTSDogXCJlc1wiLFxuICBTV0VESVNIOiBcInN2XCIsXG4gIFRIQUk6IFwidGhcIixcbiAgVFVSS0lTSDogXCJ0clwiLFxuICBVS1JBSU5JQU46IFwidWtcIixcbiAgV0VMU0g6IFwiY3lcIlxufTtcbmNvbnN0IGxhbmd1YWdlQ29kZVNldCA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhMYW5ndWFnZUdlb2NvZGluZykpO1xuZnVuY3Rpb24gZ2V0QXV0b0xhbmd1YWdlR2VvY29kaW5nKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnNwbGl0KFwiLVwiKVswXTtcbiAgfVxuICBjb25zdCBjYW5kaXRhdGVsYW5ncyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldChuYXZpZ2F0b3IubGFuZ3VhZ2VzLm1hcCgobCkgPT4gbC5zcGxpdChcIi1cIilbMF0pKVxuICApLmZpbHRlcigobCkgPT4gbGFuZ3VhZ2VDb2RlU2V0LmhhcyhsKSk7XG4gIHJldHVybiBjYW5kaXRhdGVsYW5ncy5sZW5ndGggPyBjYW5kaXRhdGVsYW5nc1swXSA6IExhbmd1YWdlR2VvY29kaW5nLkVOR0xJU0g7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChjb25maWcuZmV0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBmZXRjaCBmdW5jdGlvbiB3YXMgbm90IGZvdW5kLiBJZiBvbiBOb2RlSlMgPCAxOCBwbGVhc2Ugc3BlY2lmeSB0aGUgZmV0Y2ggZnVuY3Rpb24gd2l0aCBjb25maWcuZmV0Y2hcIlxuICAgICk7XG4gIH1cbiAgaWYgKG5ldyBVUkwocmVzb3VyY2UpLnNlYXJjaFBhcmFtcy5nZXQoXCJrZXlcIikudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleSBpcyBtaXNzaW5nLiBTZXQgaXQgaW4gYGNvbmZpZy5hcGlLZXlgIG9yIGdldCBvbmUgZm9yIGZyZWUgYXQgaHR0cHM6Ly9tYXB0aWxlci5jb21cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5mZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBtYXB0aWxlckFwaVVSTDogXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vXCIsXG4gIG1hcFN0eWxlOiBcInN0cmVldHMtdjJcIlxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdHMpO1xuXG5jbGFzcyBTZXJ2aWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcywgY3VzdG9tTWVzc2FnZSA9IFwiXCIpIHtcbiAgICBzdXBlcihcbiAgICAgIGBDYWxsIHRvIGVucG9pbnQgJHtyZXMudXJsfSBmYWlsZWQgd2l0aCB0aGUgc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzfS4gJHtjdXN0b21NZXNzYWdlfWBcbiAgICApO1xuICAgIHRoaXMucmVzID0gcmVzO1xuICB9XG59XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDQgPSB7XG4gIDQwMDogXCJRdWVyeSB0b28gbG9uZyAvIEludmFsaWQgcGFyYW1ldGVyc1wiLFxuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCB7IGxhbmd1YWdlIH0gPSBvcHRpb25zO1xuICBpZiAobGFuZ3VhZ2UgPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxhbmd1YWdlcyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldChcbiAgICAgIChBcnJheS5pc0FycmF5KGxhbmd1YWdlKSA/IGxhbmd1YWdlIDogW2xhbmd1YWdlXSkubWFwKFxuICAgICAgICAobGFuZykgPT4gbGFuZyA9PT0gTGFuZ3VhZ2VHZW9jb2RpbmcuQVVUTyA/IGdldEF1dG9MYW5ndWFnZUdlb2NvZGluZygpIDogbGFuZ1xuICAgICAgKVxuICAgIClcbiAgKS5qb2luKFwiLFwiKTtcbiAgc2VhcmNoUGFyYW1zLnNldChcImxhbmd1YWdlXCIsIGxhbmd1YWdlcyk7XG59XG5mdW5jdGlvbiBhZGRDb21tb25Gb3J3YXJkQW5kUmV2ZXJzZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYXBpS2V5LCBsaW1pdCwgdHlwZXMsIGV4Y2x1ZGVUeXBlcyB9ID0gb3B0aW9ucztcbiAgc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBhcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGlmIChsaW1pdCAhPSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gIH1cbiAgaWYgKHR5cGVzICE9IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJ0eXBlc1wiLCB0eXBlcy5qb2luKFwiLFwiKSk7XG4gIH1cbiAgaWYgKGV4Y2x1ZGVUeXBlcyAhPSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZXhjbHVkZVR5cGVzXCIsIFN0cmluZyhleGNsdWRlVHlwZXMpKTtcbiAgfVxuICBhZGRMYW5ndWFnZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucykge1xuICBhZGRDb21tb25Gb3J3YXJkQW5kUmV2ZXJzZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbiAgY29uc3QgeyBiYm94LCBwcm94aW1pdHksIGNvdW50cnksIGZ1enp5TWF0Y2gsIGF1dG9jb21wbGV0ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGJib3ggIT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImJib3hcIiwgYmJveC5qb2luKFwiLFwiKSk7XG4gIH1cbiAgaWYgKHByb3hpbWl0eSAhPSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgXCJwcm94aW1pdHlcIixcbiAgICAgIHByb3hpbWl0eSA9PT0gXCJpcFwiID8gcHJveGltaXR5IDogcHJveGltaXR5LmpvaW4oXCIsXCIpXG4gICAgKTtcbiAgfVxuICBpZiAoY291bnRyeSAhPSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiY291bnRyeVwiLCBjb3VudHJ5LmpvaW4oXCIsXCIpKTtcbiAgfVxuICBpZiAoZnV6enlNYXRjaCAhPSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZnV6enlNYXRjaFwiLCBmdXp6eU1hdGNoID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICB9XG4gIGlmIChhdXRvY29tcGxldGUgIT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImF1dG9jb21wbGV0ZVwiLCBhdXRvY29tcGxldGUgPyBcInRydWVcIiA6IFwiZmFsc2VcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZvcndhcmQocXVlcnksIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSBcInN0cmluZ1wiIHx8IHF1ZXJ5LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcXVlcnkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBnZW9jb2RpbmcvJHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfS5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gZW5kcG9pbnQ7XG4gIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzJDRbcmVzLnN0YXR1c10gPz8gXCJcIik7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIG9iajtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJldmVyc2UocG9zaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocG9zaXRpb24pIHx8IHBvc2l0aW9uLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcG9zaXRpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBmb3JtIFtsbmcsIGxhdF0uXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgZ2VvY29kaW5nLyR7cG9zaXRpb25bMF19LCR7cG9zaXRpb25bMV19Lmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGFkZENvbW1vbkZvcndhcmRBbmRSZXZlcnNlR2VvY29kaW5nT3B0aW9ucyhlbmRwb2ludC5zZWFyY2hQYXJhbXMsIG9wdGlvbnMpO1xuICBjb25zdCB1cmxXaXRoUGFyYW1zID0gZW5kcG9pbnQudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKHVybFdpdGhQYXJhbXMpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IocmVzLCBjdXN0b21NZXNzYWdlcyQ0W3Jlcy5zdGF0dXNdID8/IFwiXCIpO1xuICB9XG4gIGNvbnN0IG9iaiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIHJldHVybiBvYmo7XG59XG5hc3luYyBmdW5jdGlvbiBieUlkKGlkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKGBnZW9jb2RpbmcvJHtpZH0uanNvbmAsIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMKTtcbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgYWRkTGFuZ3VhZ2VHZW9jb2RpbmdPcHRpb25zKGVuZHBvaW50LnNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzJDRbcmVzLnN0YXR1c10gPz8gXCJcIik7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIG9iajtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhdGNoJDEocXVlcmllcywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgam9pbmVkUXVlcnkgPSBxdWVyaWVzLm1hcCgocXVlcnkpID0+IGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSkpLmpvaW4oXCI7XCIpO1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYGdlb2NvZGluZy8ke2pvaW5lZFF1ZXJ5fS5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gZW5kcG9pbnQ7XG4gIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzJDRbcmVzLnN0YXR1c10gPz8gXCJcIik7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIHF1ZXJpZXMubGVuZ3RoID09PSAxID8gW29ial0gOiBvYmo7XG59XG5jb25zdCBnZW9jb2RpbmcgPSB7XG4gIGZvcndhcmQsXG4gIHJldmVyc2UsXG4gIGJ5SWQsXG4gIGJhdGNoOiBiYXRjaCQxLFxuICBsYW5ndWFnZTogTGFuZ3VhZ2VHZW9jb2Rpbmdcbn07XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDMgPSB7XG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBpbmZvKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoYGdlb2xvY2F0aW9uL2lwLmpzb25gLCBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTCk7XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMyA/IGN1c3RvbU1lc3NhZ2VzJDNbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgZ2VvbG9jYXRpb24gPSB7XG4gIGluZm9cbn07XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDIgPSB7XG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBzZWFyY2gocXVlcnksIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSBcInN0cmluZ1wiIHx8IHF1ZXJ5LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcXVlcnkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBjb29yZGluYXRlcy9zZWFyY2gvJHtxdWVyeX0uanNvbmAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgaWYgKFwibGltaXRcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwidHJhbnNmb3JtYXRpb25zXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBcInRyYW5zZm9ybWF0aW9uc1wiLFxuICAgICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbnMudG9TdHJpbmcoKVxuICAgICk7XG4gIH1cbiAgaWYgKFwiZXhwb3J0c1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwiZXhwb3J0c1wiLCBvcHRpb25zLmV4cG9ydHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgY29uc3QgdXJsV2l0aFBhcmFtcyA9IGVuZHBvaW50LnRvU3RyaW5nKCk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaCh1cmxXaXRoUGFyYW1zKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKFxuICAgICAgcmVzLFxuICAgICAgcmVzLnN0YXR1cyBpbiBjdXN0b21NZXNzYWdlcyQyID8gY3VzdG9tTWVzc2FnZXMkMltyZXMuc3RhdHVzXSA6IFwiXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IG9iaiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIHJldHVybiBvYmo7XG59XG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9zaXRpb25zLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY29vcmRpbmF0ZXNTdHIgPSAoQXJyYXkuaXNBcnJheShwb3NpdGlvbnNbMF0pID8gcG9zaXRpb25zIDogW3Bvc2l0aW9uc10pLm1hcCgoY29vcmQpID0+IGAke2Nvb3JkWzBdfSwke2Nvb3JkWzFdfWApLmpvaW4oXCI7XCIpO1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYGNvb3JkaW5hdGVzL3RyYW5zZm9ybS8ke2Nvb3JkaW5hdGVzU3RyfS5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICBpZiAoXCJzb3VyY2VDcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInNfc3JzXCIsIG9wdGlvbnMuc291cmNlQ3JzLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcInRhcmdldENyc1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwidF9zcnNcIiwgb3B0aW9ucy50YXJnZXRDcnMudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwib3BlcmF0aW9uc1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgXCJvcHNcIixcbiAgICAgIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3BlcmF0aW9ucykgPyBvcHRpb25zLm9wZXJhdGlvbnMgOiBbb3B0aW9ucy5vcGVyYXRpb25zXSkuam9pbihcInxcIilcbiAgICApO1xuICB9XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMiA/IGN1c3RvbU1lc3NhZ2VzJDJbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgY29vcmRpbmF0ZXMgPSB7XG4gIHNlYXJjaCxcbiAgdHJhbnNmb3JtXG59O1xuXG5jb25zdCBjdXN0b21NZXNzYWdlcyQxID0ge1xuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0KGRhdGFJZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZGF0YUlkICE9PSBcInN0cmluZ1wiIHx8IGRhdGFJZC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgSUQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBkYXRhLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFJZCl9L2ZlYXR1cmVzLmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMSA/IGN1c3RvbU1lc3NhZ2VzJDFbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgZGF0YSA9IHtcbiAgZ2V0XG59O1xuXG5mdW5jdGlvbiBleHBhbmRNYXBTdHlsZShzdHlsZSkge1xuICBjb25zdCBtYXB0aWxlckRvbWFpblJlZ2V4ID0gL15tYXB0aWxlcjpcXC9cXC8oLiopLztcbiAgbGV0IG1hdGNoO1xuICBjb25zdCB0cmltbWVkID0gc3R5bGUudHJpbSgpO1xuICBsZXQgZXhwYW5kZWRTdHlsZTtcbiAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdHJpbW1lZC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICBleHBhbmRlZFN0eWxlID0gdHJpbW1lZDtcbiAgfSBlbHNlIGlmICgobWF0Y2ggPSBtYXB0aWxlckRvbWFpblJlZ2V4LmV4ZWModHJpbW1lZCkpICE9PSBudWxsKSB7XG4gICAgZXhwYW5kZWRTdHlsZSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWFwcy8ke21hdGNoWzFdfS9zdHlsZS5qc29uYDtcbiAgfSBlbHNlIHtcbiAgICBleHBhbmRlZFN0eWxlID0gYGh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9tYXBzLyR7dHJpbW1lZH0vc3R5bGUuanNvbmA7XG4gIH1cbiAgcmV0dXJuIGV4cGFuZGVkU3R5bGU7XG59XG5jbGFzcyBNYXBTdHlsZVZhcmlhbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YXJpYW50VHlwZSwgaWQsIHJlZmVyZW5jZVN0eWxlLCBkZXNjcmlwdGlvbiwgaW1hZ2VVUkwpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmFyaWFudFR5cGUgPSB2YXJpYW50VHlwZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5yZWZlcmVuY2VTdHlsZSA9IHJlZmVyZW5jZVN0eWxlO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB0aGlzLmltYWdlVVJMID0gaW1hZ2VVUkw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4tZnJpZW5kbHkgbmFtZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnJlZmVyZW5jZVN0eWxlLmdldE5hbWUoKX0gJHt0aGlzLm5hbWV9YDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YXJpYW50IHR5cGUgKGVnLiBcIkRFRkFVTFRcIiwgXCJEQVJLXCIsIFwiUEFTVEVMXCIsIGV0Yy4pXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhbnRUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIGlkXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbi1mcmllbmRseSBkZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVmZXJlbmNlIHN0eWxlIHRoaXMgdmFyaWFudCBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRSZWZlcmVuY2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YXJpYW50IG9mIGEgZ2l2ZW4gdHlwZSBleGlzdHMgZm9yIF90aGlzXyB2YXJpYW50c1xuICAgKiAoZWcuIGlmIHRoaXMgaXMgYSBcIkRBUktcIiwgdGhlbiB3ZSBjYW4gY2hlY2sgaWYgdGhlcmUgaXMgYSBcIkxJR0hUXCIgdmFyaWFudCBvZiBpdClcbiAgICogQHBhcmFtIHZhcmlhbnRUeXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBoYXNWYXJpYW50KHZhcmlhbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlU3R5bGUuaGFzVmFyaWFudCh2YXJpYW50VHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSB2YXJpYW50IG9mIGEgZ2l2ZW4gdHlwZS4gSWYgbm90IGZvdW5kLCB3aWxsIHJldHVybiB0aGUgXCJERUZBVUxUXCIgdmFyaWFudC5cbiAgICogKGVnLiBfdGhpc18gXCJEQVJLXCIgdmFyaWFudCBkb2VzIG5vdCBoYXZlIGFueSBcIlBBU1RFTFwiIHZhcmlhbnQsIHRoZW4gdGhlIFwiREVGQVVMVFwiIGlzIHJldHVybmVkKVxuICAgKiBAcGFyYW0gdmFyaWFudFR5cGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFZhcmlhbnQodmFyaWFudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VTdHlsZS5nZXRWYXJpYW50KHZhcmlhbnRUeXBlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgdmFyaWFudHMgZm9yIF90aGlzXyB2YXJpYW50cywgZXhjZXB0IF90aGlzXyBjdXJyZW50IG9uZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlU3R5bGUuZ2V0VmFyaWFudHMoKS5maWx0ZXIoKHYpID0+IHYgIT09IHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIFVSTCB0aGF0IHJlcHJlc2VudCBfdGhpc18gdmFyaWFudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0SW1hZ2VVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VVUkw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgYXMgdXNhYmxlIGJ5IE1hcExpYnJlLCBhIHN0cmluZyAoVVJMKSBvciBhIHBsYWluIHN0eWxlIGRlc2NyaXB0aW9uIChTdHlsZVNwZWNpZmljYXRpb24pXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRFeHBhbmRlZFN0eWxlVVJMKCkge1xuICAgIHJldHVybiBleHBhbmRNYXBTdHlsZSh0aGlzLmdldElkKCkpO1xuICB9XG59XG5jbGFzcyBSZWZlcmVuY2VNYXBTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGlkKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgLyoqXG4gICAgICogVmFyaWFudHMgdGhhdCBiZWxvbmcgdG8gdGhpcyByZWZlcmVuY2Ugc3R5bGUsIGtleSBiZWluZyB0aGUgcmVmZXJlbmNlIHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnZhcmlhbnRzID0ge307XG4gICAgLyoqXG4gICAgICogVmFyaWFudHMgdGhhdCBiZWxvbmcgdG8gdGhpcyByZWZlcmVuY2Ugc3R5bGUsIG9yZGVyZWQgYnkgcmVsZXZhbmNlXG4gICAgICovXG4gICAgdGhpcy5vcmRlcmVkVmFyaWFudHMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbi1mcmllbmRseSBuYW1lIG9mIHRoaXMgcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgX3RoaXNfIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHZhcmlhbnQgdG8gX3RoaXNfIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcGFyYW0gdlxuICAgKi9cbiAgYWRkVmFyaWFudCh2KSB7XG4gICAgdGhpcy52YXJpYW50c1t2LmdldFR5cGUoKV0gPSB2O1xuICAgIHRoaXMub3JkZXJlZFZhcmlhbnRzLnB1c2godik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgZ2l2ZW4gdmFyaWFudCB0eXBlIGV4aXN0cyBmb3IgdGhpcyByZWZlcmVuY2Ugc3R5bGVcbiAgICogQHBhcmFtIHZhcmlhbnRUeXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBoYXNWYXJpYW50KHZhcmlhbnRUeXBlKSB7XG4gICAgcmV0dXJuIHZhcmlhbnRUeXBlIGluIHRoaXMudmFyaWFudHM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGdpdmVuIHZhcmlhbnQuIElmIHRoZSBnaXZlbiB0eXBlIG9mIHZhcmlhbnQgZG9lcyBub3QgZXhpc3QgZm9yIHRoaXMgcmVmZXJlbmNlIHN0eWxlLFxuICAgKiB0aGVuIHRoZSBtb3N0IHJlbGV2YW50IGRlZmF1bHQgdmFyaWFudCBpcyByZXR1cm5lZCBpbnN0ZWFkXG4gICAqIEBwYXJhbSB2YXJpYW50VHlwZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmFyaWFudCh2YXJpYW50VHlwZSkge1xuICAgIHJldHVybiB2YXJpYW50VHlwZSBpbiB0aGlzLnZhcmlhbnRzID8gdGhpcy52YXJpYW50c1t2YXJpYW50VHlwZV0gOiB0aGlzLm9yZGVyZWRWYXJpYW50c1swXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHZhcmlhbnRzIGZvciB0aGlzIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy52YXJpYW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmdWFsdCB2YXJpYW50IGZvciB0aGlzIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JkZXJlZFZhcmlhbnRzWzBdO1xuICB9XG59XG5jb25zdCBtYXBTdHlsZVByZXNldExpc3QgPSBbXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlNUUkVFVFNcIixcbiAgICBuYW1lOiBcIlN0cmVldHNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1saWdodFwiLFxuICAgICAgICBuYW1lOiBcIkxpZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1uaWdodFwiLFxuICAgICAgICBuYW1lOiBcIk5pZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIk5JR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1wYXN0ZWxcIixcbiAgICAgICAgbmFtZTogXCJQYXN0ZWxcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiUEFTVEVMXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiT1VURE9PUlwiLFxuICAgIG5hbWU6IFwiT3V0ZG9vclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIm91dGRvb3ItdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJvdXRkb29yLXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJXSU5URVJcIixcbiAgICBuYW1lOiBcIldpbnRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIndpbnRlci12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcIndpbnRlci12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiU0FURUxMSVRFXCIsXG4gICAgbmFtZTogXCJTYXRlbGxpdGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzYXRlbGxpdGVcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJIWUJSSURcIixcbiAgICBuYW1lOiBcIkh5YnJpZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImh5YnJpZFwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIkJBU0lDXCIsXG4gICAgbmFtZTogXCJCYXNpY1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhc2ljLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYmFzaWMtdjItZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhc2ljLXYyLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJCUklHSFRcIixcbiAgICBuYW1lOiBcIkJyaWdodFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJyaWdodC12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJyaWdodC12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYnJpZ2h0LXYyLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJicmlnaHQtdjItcGFzdGVsXCIsXG4gICAgICAgIG5hbWU6IFwiUGFzdGVsXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlBBU1RFTFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIk9QRU5TVFJFRVRNQVBcIixcbiAgICBuYW1lOiBcIk9wZW5TdHJlZXRNYXBcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJvcGVuc3RyZWV0bWFwXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiVE9QT1wiLFxuICAgIG5hbWU6IFwiVG9wb1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXNoaW55XCIsXG4gICAgICAgIG5hbWU6IFwiU2hpbnlcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiU0hJTllcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXBhc3RlbFwiLFxuICAgICAgICBuYW1lOiBcIlBhc3RlbFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJQQVNURUxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXRvcG9ncmFwaGlxdWVcIixcbiAgICAgICAgbmFtZTogXCJUb3BvZ3JhcGhpcXVlXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlRPUE9HUkFQSElRVUVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJWT1lBR0VSXCIsXG4gICAgbmFtZTogXCJWb3lhZ2VyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidm95YWdlci12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItZGFya21hdHRlclwiLFxuICAgICAgICBuYW1lOiBcIkRhcmttYXR0ZXJcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItcG9zaXRyb25cIixcbiAgICAgICAgbmFtZTogXCJQb3NpdHJvblwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJMSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItdmludGFnZVwiLFxuICAgICAgICBuYW1lOiBcIlZpbnRhZ2VcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiVklOVEFHRVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlRPTkVSXCIsXG4gICAgbmFtZTogXCJUb25lclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvbmVyLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidG9uZXItdjItYmFja2dyb3VuZFwiLFxuICAgICAgICBuYW1lOiBcIkJhY2tncm91bmRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiQkFDS0dST1VORFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvbmVyLXYyLWxpdGVcIixcbiAgICAgICAgbmFtZTogXCJMaXRlXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJVEVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b25lci12Mi1saW5lc1wiLFxuICAgICAgICBuYW1lOiBcIkxpbmVzXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJTkVTXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiREFUQVZJWlwiLFxuICAgIG5hbWU6IFwiRGF0YXZpelwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImRhdGF2aXpcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJkYXRhdml6LWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJkYXRhdml6LWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJCQUNLRFJPUFwiLFxuICAgIG5hbWU6IFwiQmFja2Ryb3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJiYWNrZHJvcFwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhY2tkcm9wLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYWNrZHJvcC1saWdodFwiLFxuICAgICAgICBuYW1lOiBcIkxpZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiT0NFQU5cIixcbiAgICBuYW1lOiBcIk9jZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwib2NlYW5cIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dO1xuZnVuY3Rpb24gbWFrZVJlZmVyZW5jZVN0eWxlUHJveHkocmVmZXJlbmNlU3R5bGUpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShyZWZlcmVuY2VTdHlsZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc1ZhcmlhbnQocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYXJpYW50KHByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpID09PSBwcm9wKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VTdHlsZS5nZXREZWZhdWx0VmFyaWFudCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBidWlsZE1hcFN0eWxlcygpIHtcbiAgY29uc3QgbWFwU3R5bGUgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBTdHlsZVByZXNldExpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCByZWZTdHlsZUluZm8gPSBtYXBTdHlsZVByZXNldExpc3RbaV07XG4gICAgY29uc3QgcmVmU3R5bGUgPSBtYWtlUmVmZXJlbmNlU3R5bGVQcm94eShcbiAgICAgIG5ldyBSZWZlcmVuY2VNYXBTdHlsZShyZWZTdHlsZUluZm8ubmFtZSwgcmVmU3R5bGVJbmZvLnJlZmVyZW5jZVN0eWxlSUQpXG4gICAgKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZlN0eWxlSW5mby52YXJpYW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgY29uc3QgdmFyaWFudEluZm8gPSByZWZTdHlsZUluZm8udmFyaWFudHNbal07XG4gICAgICBjb25zdCB2YXJpYW50ID0gbmV3IE1hcFN0eWxlVmFyaWFudChcbiAgICAgICAgdmFyaWFudEluZm8ubmFtZSxcbiAgICAgICAgLy8gbmFtZVxuICAgICAgICB2YXJpYW50SW5mby52YXJpYW50VHlwZSxcbiAgICAgICAgLy8gdmFyaWFudFR5cGVcbiAgICAgICAgdmFyaWFudEluZm8uaWQsXG4gICAgICAgIC8vIGlkXG4gICAgICAgIHJlZlN0eWxlLFxuICAgICAgICAvLyByZWZlcmVuY2VTdHlsZVxuICAgICAgICB2YXJpYW50SW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgdmFyaWFudEluZm8uaW1hZ2VVUkxcbiAgICAgICAgLy8gaW1hZ2VVUkxcbiAgICAgICk7XG4gICAgICByZWZTdHlsZS5hZGRWYXJpYW50KHZhcmlhbnQpO1xuICAgIH1cbiAgICBtYXBTdHlsZVtyZWZTdHlsZUluZm8ucmVmZXJlbmNlU3R5bGVJRF0gPSByZWZTdHlsZTtcbiAgfVxuICByZXR1cm4gbWFwU3R5bGU7XG59XG5mdW5jdGlvbiBzdHlsZVRvU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBNYXBTdHlsZVttYXBTdHlsZVByZXNldExpc3RbMF0ucmVmZXJlbmNlU3R5bGVJRF0uZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRJZCgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIgfHwgc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICByZXR1cm4gc3R5bGUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgTWFwU3R5bGVWYXJpYW50KSB7XG4gICAgcmV0dXJuIHN0eWxlLmdldElkKCk7XG4gIH1cbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgUmVmZXJlbmNlTWFwU3R5bGUpIHtcbiAgICByZXR1cm4gc3R5bGUuZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRJZCgpO1xuICB9XG59XG5jb25zdCBNYXBTdHlsZSA9IGJ1aWxkTWFwU3R5bGVzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RMaW5lU3RyaW5ncyhnZW9Kc29uKSB7XG4gIGNvbnN0IGxpbmVTdHJpbmdzID0gW107XG4gIGZ1bmN0aW9uIGV4dHJhY3RGcm9tR2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIgfHwgZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikge1xuICAgICAgbGluZVN0cmluZ3MucHVzaChnZW9tZXRyeSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RGcm9tRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkpIHtcbiAgICAgIGV4dHJhY3RGcm9tR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RGcm9tRmVhdHVyZUNvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBjb2xsZWN0aW9uLmZlYXR1cmVzKSB7XG4gICAgICBpZiAoZmVhdHVyZS50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgICAgICBleHRyYWN0RnJvbUZlYXR1cmUoZmVhdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgICAgIGV4dHJhY3RGcm9tRmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChnZW9Kc29uLnR5cGUgPT09IFwiRmVhdHVyZVwiKSB7XG4gICAgZXh0cmFjdEZyb21GZWF0dXJlKGdlb0pzb24pO1xuICB9IGVsc2UgaWYgKGdlb0pzb24udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgZXh0cmFjdEZyb21GZWF0dXJlQ29sbGVjdGlvbihnZW9Kc29uKTtcbiAgfSBlbHNlIHtcbiAgICBleHRyYWN0RnJvbUdlb21ldHJ5KGdlb0pzb24pO1xuICB9XG4gIHJldHVybiBsaW5lU3RyaW5ncztcbn1cbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcbiAgbGV0IHggPSBwMVswXSwgeSA9IHAxWzFdLCBkeCA9IHAyWzBdIC0geCwgZHkgPSBwMlsxXSAtIHk7XG4gIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgIGNvbnN0IHQgPSAoKHBbMF0gLSB4KSAqIGR4ICsgKHBbMV0gLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4ID0gcDJbMF07XG4gICAgICB5ID0gcDJbMV07XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICB5ICs9IGR5ICogdDtcbiAgICB9XG4gIH1cbiAgZHggPSBwWzBdIC0geDtcbiAgZHkgPSBwWzFdIC0geTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuZnVuY3Rpb24gc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpIHtcbiAgbGV0IG1heFNxRGlzdCA9IHNxVG9sZXJhbmNlLCBpbmRleDtcbiAgZm9yIChsZXQgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgIGNvbnN0IHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG4gICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgIH1cbiAgfVxuICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHtcbiAgICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgfVxuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICBpZiAobGFzdCAtIGluZGV4ID4gMSkge1xuICAgICAgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG4gIGNvbnN0IGxhc3QgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgY29uc3Qgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICBzaW1wbGlmeURQU3RlcChwb2ludHMsIDAsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tsYXN0XSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikge1xuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgY29uc3Qgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgIT09IHZvaWQgMCA/IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSA6IDE7XG4gIGNvbnN0IHNpbXBsZVBvaW50cyA9IHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gIHJldHVybiBzaW1wbGVQb2ludHM7XG59XG5jb25zdCBtaXNjID0ge1xuICBleHRyYWN0TGluZVN0cmluZ3MsXG4gIHNpbXBsaWZ5XG59O1xuXG5mdW5jdGlvbiBzdGF0aWNNYXBNYXJrZXJUb1N0cmluZyhtYXJrZXIsIGluY2x1ZGVDb2xvciA9IHRydWUpIHtcbiAgbGV0IHN0ciA9IGAke21hcmtlclswXX0sJHttYXJrZXJbMV19YDtcbiAgaWYgKG1hcmtlci5sZW5ndGggPT09IDMgJiYgaW5jbHVkZUNvbG9yKSB7XG4gICAgc3RyICs9IGAsJHttYXJrZXJbMl19YDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gc2ltcGxpZnlBbmRTdHJpbmdpZnkocGF0aCwgbWF4TmJDaGFyID0gM2UzKSB7XG4gIGxldCBzdHIgPSBwYXRoLm1hcCgocG9pbnQpID0+IHBvaW50LmpvaW4oXCIsXCIpKS5qb2luKFwifFwiKTtcbiAgbGV0IHRvbGVyYW5jZSA9IDVlLTY7XG4gIGNvbnN0IHRvbGVyYW5jZVN0ZXAgPSAxZS01O1xuICB3aGlsZSAoc3RyLmxlbmd0aCA+IG1heE5iQ2hhcikge1xuICAgIGNvbnN0IHNpbXBsZXJQYXRoID0gbWlzYy5zaW1wbGlmeShwYXRoLCB0b2xlcmFuY2UpO1xuICAgIHN0ciA9IHNpbXBsZXJQYXRoLm1hcCgocG9pbnQpID0+IGAke3BvaW50WzBdfSwke3BvaW50WzFdfWApLmpvaW4oXCJ8XCIpO1xuICAgIHRvbGVyYW5jZSArPSB0b2xlcmFuY2VTdGVwO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBjZW50ZXJlZChjZW50ZXIsIHpvb20sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzdHlsZSA9IHN0eWxlVG9TdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLmhpRFBJID8gXCJAMnhcIiA6IFwiXCI7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ID8/IFwicG5nXCI7XG4gIGxldCB3aWR0aCA9IH5+KG9wdGlvbnMud2lkdGggPz8gMTAyNCk7XG4gIGxldCBoZWlnaHQgPSB+fihvcHRpb25zLmhlaWdodCA/PyAxMDI0KTtcbiAgaWYgKG9wdGlvbnMuaGlEUEkpIHtcbiAgICB3aWR0aCA9IH5+KHdpZHRoIC8gMik7XG4gICAgaGVpZ2h0ID0gfn4oaGVpZ2h0IC8gMik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBtYXBzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0eWxlKX0vc3RhdGljLyR7Y2VudGVyWzBdfSwke2NlbnRlclsxXX0sJHt6b29tfS8ke3dpZHRofXgke2hlaWdodH0ke3NjYWxlfS4ke2Zvcm1hdH1gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGlmIChcImF0dHJpYnV0aW9uXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJhdHRyaWJ1dGlvblwiLCBvcHRpb25zLmF0dHJpYnV0aW9uLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcIm1hcmtlcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG1hcmtlclN0ciA9IFwiXCI7XG4gICAgY29uc3QgaGFzSWNvbiA9IFwibWFya2VySWNvblwiIGluIG9wdGlvbnM7XG4gICAgaWYgKGhhc0ljb24pIHtcbiAgICAgIG1hcmtlclN0ciArPSBgaWNvbjoke29wdGlvbnMubWFya2VySWNvbn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgXCJtYXJrZXJBbmNob3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGFuY2hvcjoke29wdGlvbnMubWFya2VyQW5jaG9yfXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBvcHRpb25zLmhpRFBJKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYHNjYWxlOjJ8YDtcbiAgICB9XG4gICAgY29uc3QgbWFya2VyTGlzdCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXJrZXJzWzBdKSA/IG9wdGlvbnMubWFya2VycyA6IFtvcHRpb25zLm1hcmtlcnNdO1xuICAgIG1hcmtlclN0ciArPSBtYXJrZXJMaXN0Lm1hcCgobSkgPT4gc3RhdGljTWFwTWFya2VyVG9TdHJpbmcobSwgIWhhc0ljb24pKS5qb2luKFwifFwiKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwibWFya2Vyc1wiLCBtYXJrZXJTdHIpO1xuICB9XG4gIGlmIChcInBhdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IHBhdGhTdHIgPSBcIlwiO1xuICAgIHBhdGhTdHIgKz0gYGZpbGw6JHtvcHRpb25zLnBhdGhGaWxsQ29sb3IgPz8gXCJub25lXCJ9fGA7XG4gICAgaWYgKFwicGF0aFN0cm9rZUNvbG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgcGF0aFN0ciArPSBgc3Ryb2tlOiR7b3B0aW9ucy5wYXRoU3Ryb2tlQ29sb3J9fGA7XG4gICAgfVxuICAgIGlmIChcInBhdGhXaWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhdGhXaWR0aCA9IG9wdGlvbnMucGF0aFdpZHRoIC8gKG9wdGlvbnMuaGlEUEkgPyAyIDogMSk7XG4gICAgICBwYXRoU3RyICs9IGB3aWR0aDoke3BhdGhXaWR0aC50b1N0cmluZygpfXxgO1xuICAgIH1cbiAgICBwYXRoU3RyICs9IHNpbXBsaWZ5QW5kU3RyaW5naWZ5KG9wdGlvbnMucGF0aCk7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInBhdGhcIiwgcGF0aFN0cik7XG4gIH1cbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgcmV0dXJuIGVuZHBvaW50LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBib3VuZGVkKGJvdW5kaW5nQm94LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3R5bGUgPSBzdHlsZVRvU3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5oaURQSSA/IFwiQDJ4XCIgOiBcIlwiO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCA/PyBcInBuZ1wiO1xuICBsZXQgd2lkdGggPSB+fihvcHRpb25zLndpZHRoID8/IDEwMjQpO1xuICBsZXQgaGVpZ2h0ID0gfn4ob3B0aW9ucy5oZWlnaHQgPz8gMTAyNCk7XG4gIGlmIChvcHRpb25zLmhpRFBJKSB7XG4gICAgd2lkdGggPSB+fih3aWR0aCAvIDIpO1xuICAgIGhlaWdodCA9IH5+KGhlaWdodCAvIDIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgbWFwcy8ke2VuY29kZVVSSUNvbXBvbmVudChzdHlsZSl9L3N0YXRpYy8ke2JvdW5kaW5nQm94WzBdfSwke2JvdW5kaW5nQm94WzFdfSwke2JvdW5kaW5nQm94WzJdfSwke2JvdW5kaW5nQm94WzNdfS8ke3dpZHRofXgke2hlaWdodH0ke3NjYWxlfS4ke2Zvcm1hdH1gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGlmIChcImF0dHJpYnV0aW9uXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJhdHRyaWJ1dGlvblwiLCBvcHRpb25zLmF0dHJpYnV0aW9uLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcInBhZGRpbmdcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInBhZGRpbmdcIiwgb3B0aW9ucy5wYWRkaW5nLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcIm1hcmtlcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG1hcmtlclN0ciA9IFwiXCI7XG4gICAgY29uc3QgaGFzSWNvbiA9IFwibWFya2VySWNvblwiIGluIG9wdGlvbnM7XG4gICAgaWYgKGhhc0ljb24pIHtcbiAgICAgIG1hcmtlclN0ciArPSBgaWNvbjoke29wdGlvbnMubWFya2VySWNvbn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgXCJtYXJrZXJBbmNob3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGFuY2hvcjoke29wdGlvbnMubWFya2VyQW5jaG9yfXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBvcHRpb25zLmhpRFBJKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYHNjYWxlOjJ8YDtcbiAgICB9XG4gICAgY29uc3QgbWFya2VyTGlzdCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXJrZXJzWzBdKSA/IG9wdGlvbnMubWFya2VycyA6IFtvcHRpb25zLm1hcmtlcnNdO1xuICAgIG1hcmtlclN0ciArPSBtYXJrZXJMaXN0Lm1hcCgobSkgPT4gc3RhdGljTWFwTWFya2VyVG9TdHJpbmcobSwgIWhhc0ljb24pKS5qb2luKFwifFwiKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwibWFya2Vyc1wiLCBtYXJrZXJTdHIpO1xuICB9XG4gIGlmIChcInBhdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IHBhdGhTdHIgPSBcIlwiO1xuICAgIHBhdGhTdHIgKz0gYGZpbGw6JHtvcHRpb25zLnBhdGhGaWxsQ29sb3IgPz8gXCJub25lXCJ9fGA7XG4gICAgaWYgKFwicGF0aFN0cm9rZUNvbG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgcGF0aFN0ciArPSBgc3Ryb2tlOiR7b3B0aW9ucy5wYXRoU3Ryb2tlQ29sb3J9fGA7XG4gICAgfVxuICAgIGlmIChcInBhdGhXaWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhdGhXaWR0aCA9IG9wdGlvbnMucGF0aFdpZHRoIC8gKG9wdGlvbnMuaGlEUEkgPyAyIDogMSk7XG4gICAgICBwYXRoU3RyICs9IGB3aWR0aDoke3BhdGhXaWR0aC50b1N0cmluZygpfXxgO1xuICAgIH1cbiAgICBwYXRoU3RyICs9IHNpbXBsaWZ5QW5kU3RyaW5naWZ5KG9wdGlvbnMucGF0aCk7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInBhdGhcIiwgcGF0aFN0cik7XG4gIH1cbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgcmV0dXJuIGVuZHBvaW50LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWMob3B0aW9ucyA9IHt9KSB7XG4gIGlmICghKFwibWFya2Vyc1wiIGluIG9wdGlvbnMpICYmICEoXCJwYXRoXCIgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dG9tYXRpYyBzdGF0aWMgbWFwcyByZXF1aXJlIG1hcmtlcnMgYW5kL29yIHBhdGggdG8gYmUgY3JlYXRlZC5cIlxuICAgICk7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBzdHlsZVRvU3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5oaURQSSA/IFwiQDJ4XCIgOiBcIlwiO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCA/PyBcInBuZ1wiO1xuICBsZXQgd2lkdGggPSB+fihvcHRpb25zLndpZHRoID8/IDEwMjQpO1xuICBsZXQgaGVpZ2h0ID0gfn4ob3B0aW9ucy5oZWlnaHQgPz8gMTAyNCk7XG4gIGlmIChvcHRpb25zLmhpRFBJKSB7XG4gICAgd2lkdGggPSB+fih3aWR0aCAvIDIpO1xuICAgIGhlaWdodCA9IH5+KGhlaWdodCAvIDIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgbWFwcy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIHN0eWxlXG4gICAgKX0vc3RhdGljL2F1dG8vJHt3aWR0aH14JHtoZWlnaHR9JHtzY2FsZX0uJHtmb3JtYXR9YCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBpZiAoXCJhdHRyaWJ1dGlvblwiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwiYXR0cmlidXRpb25cIiwgb3B0aW9ucy5hdHRyaWJ1dGlvbi50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJwYWRkaW5nXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJwYWRkaW5nXCIsIG9wdGlvbnMucGFkZGluZy50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJtYXJrZXJzXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBtYXJrZXJTdHIgPSBcIlwiO1xuICAgIGNvbnN0IGhhc0ljb24gPSBcIm1hcmtlckljb25cIiBpbiBvcHRpb25zO1xuICAgIGlmIChoYXNJY29uKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGljb246JHtvcHRpb25zLm1hcmtlckljb259fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIFwibWFya2VyQW5jaG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgbWFya2VyU3RyICs9IGBhbmNob3I6JHtvcHRpb25zLm1hcmtlckFuY2hvcn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgb3B0aW9ucy5oaURQSSkge1xuICAgICAgbWFya2VyU3RyICs9IGBzY2FsZToyfGA7XG4gICAgfVxuICAgIGNvbnN0IG1hcmtlckxpc3QgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMubWFya2Vyc1swXSkgPyBvcHRpb25zLm1hcmtlcnMgOiBbb3B0aW9ucy5tYXJrZXJzXTtcbiAgICBtYXJrZXJTdHIgKz0gbWFya2VyTGlzdC5tYXAoKG0pID0+IHN0YXRpY01hcE1hcmtlclRvU3RyaW5nKG0sICFoYXNJY29uKSkuam9pbihcInxcIik7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcIm1hcmtlcnNcIiwgbWFya2VyU3RyKTtcbiAgfVxuICBpZiAoXCJwYXRoXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBwYXRoU3RyID0gXCJcIjtcbiAgICBwYXRoU3RyICs9IGBmaWxsOiR7b3B0aW9ucy5wYXRoRmlsbENvbG9yID8/IFwibm9uZVwifXxgO1xuICAgIGlmIChcInBhdGhTdHJva2VDb2xvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhdGhTdHIgKz0gYHN0cm9rZToke29wdGlvbnMucGF0aFN0cm9rZUNvbG9yfXxgO1xuICAgIH1cbiAgICBpZiAoXCJwYXRoV2lkdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBwYXRoV2lkdGggPSBvcHRpb25zLnBhdGhXaWR0aCAvIChvcHRpb25zLmhpRFBJID8gMiA6IDEpO1xuICAgICAgcGF0aFN0ciArPSBgd2lkdGg6JHtwYXRoV2lkdGgudG9TdHJpbmcoKX18YDtcbiAgICB9XG4gICAgcGF0aFN0ciArPSBzaW1wbGlmeUFuZFN0cmluZ2lmeShvcHRpb25zLnBhdGgpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJwYXRoXCIsIHBhdGhTdHIpO1xuICB9XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIHJldHVybiBlbmRwb2ludC50b1N0cmluZygpO1xufVxuY29uc3Qgc3RhdGljTWFwcyA9IHtcbiAgY2VudGVyZWQsXG4gIGJvdW5kZWQsXG4gIGF1dG9tYXRpY1xufTtcblxuY29uc3QgRUFSVEhfUkFESVVTID0gNjM3MTAwODhlLTE7XG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gMiAqIE1hdGguUEkgKiBFQVJUSF9SQURJVVM7XG5mdW5jdGlvbiBsb25naXR1ZGVUb01lcmNhdG9yWChsbmcpIHtcbiAgcmV0dXJuICgxODAgKyBsbmcpIC8gMzYwO1xufVxuZnVuY3Rpb24gbGF0aXR1ZGVUb01lcmNhdG9yWShsYXQpIHtcbiAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuZnVuY3Rpb24gd2dzODRUb01lcmNhdG9yKHBvc2l0aW9uKSB7XG4gIGNvbnN0IHdyYXBwZWRQb3MgPSB3cmFwV2dzODQocG9zaXRpb24pO1xuICByZXR1cm4gW1xuICAgIGxvbmdpdHVkZVRvTWVyY2F0b3JYKHdyYXBwZWRQb3NbMF0pLFxuICAgIGxhdGl0dWRlVG9NZXJjYXRvclkod3JhcHBlZFBvc1sxXSlcbiAgXTtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yWFRvTG9uZ2l0dWRlKHgpIHtcbiAgcmV0dXJuIHggKiAzNjAgLSAxODA7XG59XG5mdW5jdGlvbiBtZXJjYXRvcllUb0xhdGl0dWRlKHkpIHtcbiAgY29uc3QgeTIgPSAxODAgLSB5ICogMzYwO1xuICByZXR1cm4gMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwO1xufVxuZnVuY3Rpb24gbWVyY2F0b3JUb1dnczg0KHBvc2l0aW9uKSB7XG4gIHJldHVybiBbbWVyY2F0b3JYVG9Mb25naXR1ZGUocG9zaXRpb25bMF0pLCBtZXJjYXRvcllUb0xhdGl0dWRlKHBvc2l0aW9uWzFdKV07XG59XG5mdW5jdGlvbiBoYXZlcnNpbmVEaXN0YW5jZVdnczg0KGZyb20sIHRvKSB7XG4gIGNvbnN0IHJhZCA9IE1hdGguUEkgLyAxODA7XG4gIGNvbnN0IGxhdDEgPSBmcm9tWzFdICogcmFkO1xuICBjb25zdCBsYXQyID0gdG9bMV0gKiByYWQ7XG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdDIpICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKCh0b1swXSAtIGZyb21bMF0pICogcmFkKTtcbiAgY29uc3QgbWF4TWV0ZXJzID0gRUFSVEhfUkFESVVTICogTWF0aC5hY29zKE1hdGgubWluKGEsIDEpKTtcbiAgcmV0dXJuIG1heE1ldGVycztcbn1cbmZ1bmN0aW9uIGhhdmVyc2luZUN1bXVsYXRlZERpc3RhbmNlV2dzODQocG9zaXRpb25zKSB7XG4gIGNvbnN0IGN1bXVsYXRlZERpc3RhbmNlID0gQXJyYXkocG9zaXRpb25zLmxlbmd0aCk7XG4gIGN1bXVsYXRlZERpc3RhbmNlWzBdID0gMDtcbiAgY29uc3QgbCA9IGN1bXVsYXRlZERpc3RhbmNlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICBjdW11bGF0ZWREaXN0YW5jZVtpXSA9IGhhdmVyc2luZURpc3RhbmNlV2dzODQocG9zaXRpb25zW2kgLSAxXSwgcG9zaXRpb25zW2ldKSArIGN1bXVsYXRlZERpc3RhbmNlW2kgLSAxXTtcbiAgfVxuICByZXR1cm4gY3VtdWxhdGVkRGlzdGFuY2U7XG59XG5mdW5jdGlvbiB3cmFwV2dzODQocG9zaXRpb24pIHtcbiAgY29uc3QgbG5nID0gcG9zaXRpb25bMF07XG4gIGNvbnN0IGxhdCA9IHBvc2l0aW9uWzFdO1xuICBjb25zdCBkID0gMzYwO1xuICBjb25zdCB3ID0gKChsbmcgKyAxODApICUgZCArIGQpICUgZCAtIDE4MDtcbiAgY29uc3Qgd3JhcExvbmcgPSB3ID09PSAtMTgwID8gMTgwIDogdztcbiAgcmV0dXJuIFt3cmFwTG9uZywgbGF0XTtcbn1cbmZ1bmN0aW9uIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlKGxhdGl0dWRlKSB7XG4gIHJldHVybiBFQVJUSF9DSVJDVU1GRVJFTkNFICogTWF0aC5jb3MobGF0aXR1ZGUgKiBNYXRoLlBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yVG9UaWxlSW5kZXgocG9zaXRpb24sIHpvb20sIHN0cmljdCA9IHRydWUpIHtcbiAgY29uc3QgbnVtYmVyT2ZUaWxlUGVyQXhpcyA9IDIgKiogem9vbTtcbiAgY29uc3QgZkluZGV4ID0gW1xuICAgIHBvc2l0aW9uWzBdICogbnVtYmVyT2ZUaWxlUGVyQXhpcyxcbiAgICBwb3NpdGlvblsxXSAqIG51bWJlck9mVGlsZVBlckF4aXNcbiAgXTtcbiAgcmV0dXJuIHN0cmljdCA/IFt+fmZJbmRleFswXSwgfn5mSW5kZXhbMV1dIDogZkluZGV4O1xufVxuZnVuY3Rpb24gd2dzODRUb1RpbGVJbmRleChwb3NpdGlvbiwgem9vbSwgc3RyaWN0ID0gdHJ1ZSkge1xuICBjb25zdCBtZXJjID0gd2dzODRUb01lcmNhdG9yKHBvc2l0aW9uKTtcbiAgcmV0dXJuIG1lcmNhdG9yVG9UaWxlSW5kZXgobWVyYywgem9vbSwgc3RyaWN0KTtcbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIGhhdmVyc2luZUludGVybWVkaWF0ZVdnczg0KHBvczEsIHBvczIsIHJhdGlvKSB7XG4gIGNvbnN0IGQgPSBoYXZlcnNpbmVEaXN0YW5jZVdnczg0KHBvczEsIHBvczIpO1xuICBjb25zdCBcXHUwM0JCMSA9IHRvUmFkaWFucyhwb3MxWzBdKTtcbiAgY29uc3QgXFx1MDNDNjEgPSB0b1JhZGlhbnMocG9zMVsxXSk7XG4gIGNvbnN0IFxcdTAzQkIyID0gdG9SYWRpYW5zKHBvczJbMF0pO1xuICBjb25zdCBcXHUwM0M2MiA9IHRvUmFkaWFucyhwb3MyWzFdKTtcbiAgY29uc3QgXFx1MDNCNCA9IGQgLyBFQVJUSF9SQURJVVM7XG4gIGNvbnN0IGEgPSBNYXRoLnNpbigoMSAtIHJhdGlvKSAqIFxcdTAzQjQpIC8gTWF0aC5zaW4oXFx1MDNCNCk7XG4gIGNvbnN0IGIgPSBNYXRoLnNpbihyYXRpbyAqIFxcdTAzQjQpIC8gTWF0aC5zaW4oXFx1MDNCNCk7XG4gIGNvbnN0IHggPSBhICogTWF0aC5jb3MoXFx1MDNDNjEpICogTWF0aC5jb3MoXFx1MDNCQjEpICsgYiAqIE1hdGguY29zKFxcdTAzQzYyKSAqIE1hdGguY29zKFxcdTAzQkIyKTtcbiAgY29uc3QgeSA9IGEgKiBNYXRoLmNvcyhcXHUwM0M2MSkgKiBNYXRoLnNpbihcXHUwM0JCMSkgKyBiICogTWF0aC5jb3MoXFx1MDNDNjIpICogTWF0aC5zaW4oXFx1MDNCQjIpO1xuICBjb25zdCB6ID0gYSAqIE1hdGguc2luKFxcdTAzQzYxKSArIGIgKiBNYXRoLnNpbihcXHUwM0M2Mik7XG4gIGNvbnN0IFxcdTAzQzYzID0gTWF0aC5hdGFuMih6LCBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuICBjb25zdCBcXHUwM0JCMyA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIHJldHVybiBbdG9EZWdyZWVzKFxcdTAzQkIzKSwgdG9EZWdyZWVzKFxcdTAzQzYzKV07XG59XG5jb25zdCBtYXRoID0ge1xuICBFQVJUSF9SQURJVVMsXG4gIEVBUlRIX0NJUkNVTUZFUkVOQ0UsXG4gIGxvbmdpdHVkZVRvTWVyY2F0b3JYLFxuICBsYXRpdHVkZVRvTWVyY2F0b3JZLFxuICB3Z3M4NFRvTWVyY2F0b3IsXG4gIG1lcmNhdG9yWFRvTG9uZ2l0dWRlLFxuICBtZXJjYXRvcllUb0xhdGl0dWRlLFxuICBtZXJjYXRvclRvV2dzODQsXG4gIGhhdmVyc2luZURpc3RhbmNlV2dzODQsXG4gIHdyYXBXZ3M4NCxcbiAgY2lyY3VtZmVyZW5jZUF0TGF0aXR1ZGUsXG4gIG1lcmNhdG9yVG9UaWxlSW5kZXgsXG4gIHdnczg0VG9UaWxlSW5kZXgsXG4gIHRvUmFkaWFucyxcbiAgdG9EZWdyZWVzLFxuICBoYXZlcnNpbmVJbnRlcm1lZGlhdGVXZ3M4NCxcbiAgaGF2ZXJzaW5lQ3VtdWxhdGVkRGlzdGFuY2VXZ3M4NFxufTtcblxubGV0IHRpbGVDYWNoZSA9IG51bGw7XG5mdW5jdGlvbiBnZXRUaWxlQ2FjaGUoKSB7XG4gIGlmICghdGlsZUNhY2hlKSB7XG4gICAgdGlsZUNhY2hlID0gbmV3IFF1aWNrTFJVKHsgbWF4U2l6ZTogY29uZmlnLnRpbGVDYWNoZVNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIHRpbGVDYWNoZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1ZmZlclRvUGl4ZWxEYXRhQnJvd3NlcihidWZmKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZl0pO1xuICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjYW52YXMud2lkdGggPSBpbWFnZUJpdG1hcC53aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGltYWdlQml0bWFwLmhlaWdodDtcbiAgY3R4LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7XG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBwaXhlbHM6IGltYWdlRGF0YS5kYXRhLFxuICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgIGNvbXBvbmVudHM6IGltYWdlRGF0YS5kYXRhLmxlbmd0aCAvIChjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIoKSB7XG4gIGlmIChjb25maWcuYnVmZmVyVG9QaXhlbERhdGEpIHtcbiAgICByZXR1cm4gY29uZmlnLmJ1ZmZlclRvUGl4ZWxEYXRhO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvUGl4ZWxEYXRhQnJvd3NlcjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJBbiBpbWFnZSBmaWxlIGJ1ZmZlciB0byBwaXhlbCBkYXRhIHBhcnNlciBpcyBuZWNlc3NhcnkuIFNwZWNpZnkgaXQgaW4gYGNvbmZpZy5idWZmZXJUb1BpeGVsRGF0YWBcIlxuICApO1xufVxuXG5jb25zdCB0ZXJyYWluVGlsZUpzb25VUkwgPSBcInRpbGVzL3RlcnJhaW4tcmdiLXYyL3RpbGVzLmpzb25cIjtcbmxldCB0ZXJyYWluVGlsZUpzb24gPSBudWxsO1xuY29uc3QgY3VzdG9tTWVzc2FnZXMgPSB7XG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmZXRjaFRlcnJhaW5UaWxlSnNvbihhcGlLZXkpIHtcbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKHRlcnJhaW5UaWxlSnNvblVSTCwgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkwpO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIGFwaUtleSk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmIChyZXMub2spIHtcbiAgICB0ZXJyYWluVGlsZUpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB0ZXJyYWluVGlsZUpzb247XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IocmVzLCBjdXN0b21NZXNzYWdlc1tyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGF0KHBvc2l0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleTtcbiAgaWYgKCF0ZXJyYWluVGlsZUpzb24pIHtcbiAgICBhd2FpdCBmZXRjaFRlcnJhaW5UaWxlSnNvbihhcGlLZXkpO1xuICB9XG4gIGNvbnN0IG1heFpvb20gPSB0ZXJyYWluVGlsZUpzb24ubWF4em9vbTtcbiAgbGV0IHpvb20gPSB+fihvcHRpb25zLnpvb20gPz8gbWF4Wm9vbSk7XG4gIGlmICh6b29tID4gbWF4Wm9vbSB8fCB6b29tIDwgMCkge1xuICAgIHpvb20gPSBtYXhab29tO1xuICB9XG4gIGNvbnN0IHRpbGVJbmRleCA9IG1hdGgud2dzODRUb1RpbGVJbmRleChwb3NpdGlvbiwgem9vbSwgZmFsc2UpO1xuICBjb25zdCB0aWxlWCA9IH5+dGlsZUluZGV4WzBdO1xuICBjb25zdCB0aWxlWSA9IH5+dGlsZUluZGV4WzFdO1xuICBpZiAoIXRlcnJhaW5UaWxlSnNvbi50aWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXJyYWluIHRpbGVKU09OIHRpbGUgbGlzdCBpcyBlbXB0eS5cIik7XG4gIH1cbiAgY29uc3QgdGlsZUlEID0gYHRlcnJhaW5fJHt6b29tLnRvU3RyaW5nKCl9XyR7dGlsZVgudG9TdHJpbmcoKX1fJHt0aWxlWS50b1N0cmluZygpfWA7XG4gIGxldCB0aWxlUGl4ZWxEYXRhO1xuICBjb25zdCBjYWNoZSA9IGdldFRpbGVDYWNoZSgpO1xuICBpZiAoY2FjaGUuaGFzKHRpbGVJRCkpIHtcbiAgICB0aWxlUGl4ZWxEYXRhID0gY2FjaGUuZ2V0KHRpbGVJRCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGlsZVVSTCA9IHRlcnJhaW5UaWxlSnNvbi50aWxlc1swXS5yZXBsYWNlKFwie3h9XCIsIHRpbGVYLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7eX1cIiwgdGlsZVkudG9TdHJpbmcoKSkucmVwbGFjZShcInt6fVwiLCB6b29tLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHRpbGVSZXMgPSBhd2FpdCBjYWxsRmV0Y2godGlsZVVSTCk7XG4gICAgaWYgKCF0aWxlUmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKHRpbGVSZXMsIGN1c3RvbU1lc3NhZ2VzW3RpbGVSZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgdGlsZUJ1ZmYgPSBhd2FpdCB0aWxlUmVzLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgdGlsZVBhcnNlciA9IGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyKCk7XG4gICAgdGlsZVBpeGVsRGF0YSA9IGF3YWl0IHRpbGVQYXJzZXIodGlsZUJ1ZmYpO1xuICAgIGNhY2hlLnNldCh0aWxlSUQsIHRpbGVQaXhlbERhdGEpO1xuICB9XG4gIGNvbnN0IHBpeGVsWCA9IH5+KHRpbGVQaXhlbERhdGEud2lkdGggKiAodGlsZUluZGV4WzBdICUgMSkpO1xuICBjb25zdCBwaXhlbFkgPSB+fih0aWxlUGl4ZWxEYXRhLmhlaWdodCAqICh0aWxlSW5kZXhbMV0gJSAxKSk7XG4gIGNvbnN0IHBpeGVsRGF0YUluZGV4ID0gKHBpeGVsWSAqIHRpbGVQaXhlbERhdGEud2lkdGggKyBwaXhlbFgpICogdGlsZVBpeGVsRGF0YS5jb21wb25lbnRzO1xuICBjb25zdCBSID0gdGlsZVBpeGVsRGF0YS5waXhlbHNbcGl4ZWxEYXRhSW5kZXhdO1xuICBjb25zdCBHID0gdGlsZVBpeGVsRGF0YS5waXhlbHNbcGl4ZWxEYXRhSW5kZXggKyAxXTtcbiAgY29uc3QgQiA9IHRpbGVQaXhlbERhdGEucGl4ZWxzW3BpeGVsRGF0YUluZGV4ICsgMl07XG4gIGNvbnN0IGVsZXZhdGlvbjIgPSAtMWU0ICsgKFIgKiAyNTYgKiAyNTYgKyBHICogMjU2ICsgQikgKiAwLjE7XG4gIHJldHVybiBbcG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBlbGV2YXRpb24yXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhdGNoKHBvc2l0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGFwaUtleSA9IG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXk7XG4gIGlmICghdGVycmFpblRpbGVKc29uKSB7XG4gICAgYXdhaXQgZmV0Y2hUZXJyYWluVGlsZUpzb24oYXBpS2V5KTtcbiAgfVxuICBjb25zdCB0aWxlUGFyc2VyID0gZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIoKTtcbiAgY29uc3QgdGlsZVVSTFNjaGVtYSA9IHRlcnJhaW5UaWxlSnNvbi50aWxlc1swXTtcbiAgY29uc3QgY2FjaGUgPSBnZXRUaWxlQ2FjaGUoKTtcbiAgY29uc3QgbWF4Wm9vbSA9IHRlcnJhaW5UaWxlSnNvbi5tYXh6b29tO1xuICBsZXQgem9vbSA9IH5+KG9wdGlvbnMuem9vbSA/PyBtYXhab29tKTtcbiAgaWYgKHpvb20gPiBtYXhab29tIHx8IHpvb20gPCAwKSB7XG4gICAgem9vbSA9IG1heFpvb207XG4gIH1cbiAgY29uc3QgdGlsZUluZGljZXNGbG9hdHMgPSBwb3NpdGlvbnMubWFwKFxuICAgIChwb3NpdGlvbikgPT4gbWF0aC53Z3M4NFRvVGlsZUluZGV4KHBvc2l0aW9uLCB6b29tLCBmYWxzZSlcbiAgKTtcbiAgY29uc3QgdGlsZUluZGljZXNJbnRlZ2VyID0gdGlsZUluZGljZXNGbG9hdHMubWFwKChpbmRleCkgPT4gW1xuICAgIH5+aW5kZXhbMF0sXG4gICAgfn5pbmRleFsxXVxuICBdKTtcbiAgY29uc3QgdGlsZUlEcyA9IHRpbGVJbmRpY2VzSW50ZWdlci5tYXAoXG4gICAgKGluZGV4KSA9PiBgdGVycmFpbl8ke3pvb20udG9TdHJpbmcoKX1fJHtpbmRleFswXS50b1N0cmluZygpfV8ke2luZGV4WzFdLnRvU3RyaW5nKCl9YFxuICApO1xuICBjb25zdCB1bmlxdWVUaWxlc1RvRmV0Y2ggPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQodGlsZUlEcy5maWx0ZXIoKHRpbGVJRCkgPT4gIWNhY2hlLmhhcyh0aWxlSUQpKSlcbiAgKS5tYXAoKHRpbGVJRCkgPT4gdGlsZUlELnNwbGl0KFwiX1wiKS5zbGljZSgxKSk7XG4gIGNvbnN0IHRpbGVVUkxzID0gdW5pcXVlVGlsZXNUb0ZldGNoLm1hcChcbiAgICAoenh5KSA9PiB0aWxlVVJMU2NoZW1hLnJlcGxhY2UoXCJ7eH1cIiwgenh5WzFdLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7eX1cIiwgenh5WzJdLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7en1cIiwgenh5WzBdLnRvU3RyaW5nKCkpXG4gICk7XG4gIGNvbnN0IHByb21pc2VzRmV0Y2hUaWxlcyA9IHRpbGVVUkxzLm1hcCgodXJsKSA9PiBjYWxsRmV0Y2godXJsKSk7XG4gIGNvbnN0IHJlc1RpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzRmV0Y2hUaWxlcyk7XG4gIGNvbnN0IGZ1bGZpbGxlZFJlcyA9IHJlc1RpbGVzLm1hcChcbiAgICAoZWwpID0+IGVsLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiA/IGVsLnZhbHVlIDogbnVsbFxuICApLmZpbHRlcigocmVzKSA9PiByZXMpO1xuICBjb25zdCBmdWxmaWxsZWRSQnV0Tm90T2tSZXMgPSBmdWxmaWxsZWRSZXMuZmlsdGVyKChyZXMpID0+ICFyZXMub2spO1xuICBpZiAoZnVsZmlsbGVkUmVzLmxlbmd0aCAhPT0gcHJvbWlzZXNGZXRjaFRpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWUgdGlsZXMgY291bGQgbm90IGJlIGZldGNoZWQuXCIpO1xuICB9XG4gIGlmIChmdWxmaWxsZWRSQnV0Tm90T2tSZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIGZ1bGZpbGxlZFJCdXROb3RPa1Jlc1swXSxcbiAgICAgIGN1c3RvbU1lc3NhZ2VzW2Z1bGZpbGxlZFJCdXROb3RPa1Jlc1swXS5zdGF0dXNdID8/IFwiXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbGVBcnJheUJ1ZmZlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBmdWxmaWxsZWRSZXMubWFwKChyZXMpID0+IHJlcy5hcnJheUJ1ZmZlcigpKVxuICApO1xuICBpZiAoIXRpbGVBcnJheUJ1ZmZlcnMuZXZlcnkoKGJ1ZmYpID0+IGJ1ZmYuYnl0ZUxlbmd0aCA+IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZSB0aWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7XG4gIH1cbiAgY29uc3QgdGlsZVBpeGVsRGF0YXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0aWxlQXJyYXlCdWZmZXJzLm1hcCgoYnVmZikgPT4gdGlsZVBhcnNlcihidWZmKSlcbiAgKTtcbiAgdGlsZVBpeGVsRGF0YXMuZm9yRWFjaCgodGlsZVBpeGVsRGF0YSwgaSkgPT4ge1xuICAgIGNvbnN0IHp4eSA9IHVuaXF1ZVRpbGVzVG9GZXRjaFtpXTtcbiAgICBjb25zdCB0aWxlSUQgPSBgdGVycmFpbl8ke3p4eVswXS50b1N0cmluZygpfV8ke3p4eVsxXS50b1N0cmluZygpfV8ke3p4eVsyXS50b1N0cmluZygpfWA7XG4gICAgY2FjaGUuc2V0KHRpbGVJRCwgdGlsZVBpeGVsRGF0YSk7XG4gIH0pO1xuICBjb25zdCBlbGV2YXRlZFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5tYXAoKHBvc2l0aW9uLCBpKSA9PiB7XG4gICAgY29uc3QgdGlsZUlEID0gdGlsZUlEc1tpXTtcbiAgICBjb25zdCB0aWxlSW5kZXhGbG9hdCA9IHRpbGVJbmRpY2VzRmxvYXRzW2ldO1xuICAgIGNvbnN0IHRpbGVQaXhlbERhdGEgPSBjYWNoZS5nZXQodGlsZUlEKTtcbiAgICBjb25zdCBwaXhlbFggPSBNYXRoLm1pbihcbiAgICAgIE1hdGgucm91bmQodGlsZVBpeGVsRGF0YS53aWR0aCAqICh0aWxlSW5kZXhGbG9hdFswXSAlIDEpKSxcbiAgICAgIHRpbGVQaXhlbERhdGEud2lkdGggLSAxXG4gICAgKTtcbiAgICBjb25zdCBwaXhlbFkgPSBNYXRoLm1pbihcbiAgICAgIE1hdGgucm91bmQodGlsZVBpeGVsRGF0YS5oZWlnaHQgKiAodGlsZUluZGV4RmxvYXRbMV0gJSAxKSksXG4gICAgICB0aWxlUGl4ZWxEYXRhLmhlaWdodCAtIDFcbiAgICApO1xuICAgIGNvbnN0IHBpeGVsRGF0YUluZGV4ID0gKHBpeGVsWSAqIHRpbGVQaXhlbERhdGEud2lkdGggKyBwaXhlbFgpICogdGlsZVBpeGVsRGF0YS5jb21wb25lbnRzO1xuICAgIGNvbnN0IFIgPSB0aWxlUGl4ZWxEYXRhLnBpeGVsc1twaXhlbERhdGFJbmRleF07XG4gICAgY29uc3QgRyA9IHRpbGVQaXhlbERhdGEucGl4ZWxzW3BpeGVsRGF0YUluZGV4ICsgMV07XG4gICAgY29uc3QgQiA9IHRpbGVQaXhlbERhdGEucGl4ZWxzW3BpeGVsRGF0YUluZGV4ICsgMl07XG4gICAgY29uc3QgZWxldmF0aW9uMiA9IC0xZTQgKyAoUiAqIDI1NiAqIDI1NiArIEcgKiAyNTYgKyBCKSAqIDAuMTtcbiAgICByZXR1cm4gW3Bvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgfn4oZWxldmF0aW9uMiAqIDFlMykgLyAxZTNdO1xuICB9KTtcbiAgaWYgKG9wdGlvbnMuc21vb3RoaW5nS2VybmVsU2l6ZSkge1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSB+fihvcHRpb25zLnNtb290aGluZ0tlcm5lbFNpemUgLyAyKSAqIDIgKyAxO1xuICAgIGNvbnN0IGVsZXZhdGlvbnMgPSBlbGV2YXRlZFBvc2l0aW9ucy5tYXAoKHBvcykgPT4gcG9zWzJdKTtcbiAgICBjb25zdCBrZXJuZWxTcGFuID0gfn4oa2VybmVsU2l6ZSAvIDIpO1xuICAgIGZvciAobGV0IGkgPSBrZXJuZWxTcGFuOyBpIDwgZWxldmF0aW9ucy5sZW5ndGggLSBrZXJuZWxTcGFuIC0gMTsgaSArPSAxKSB7XG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGVsZXYgPSBlbGV2YXRpb25zW2kgLSBrZXJuZWxTcGFuICsgal07XG4gICAgICAgIHN1bSArPSBlbGV2O1xuICAgICAgfVxuICAgICAgc3VtIC89IGtlcm5lbFNpemU7XG4gICAgICBlbGV2YXRlZFBvc2l0aW9uc1tpXVsyXSA9IHN1bTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZXZhdGVkUG9zaXRpb25zO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUxpbmVTdHJpbmcobHMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobHMudHlwZSAhPT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIEdlb0pTT04gTGluZVN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShscyk7XG4gIGNvbnN0IGVsZXZhdGVkUG9zaXRpb25zID0gYXdhaXQgYmF0Y2goY2xvbmUuY29vcmRpbmF0ZXMsIG9wdGlvbnMpO1xuICBjbG9uZS5jb29yZGluYXRlcyA9IGVsZXZhdGVkUG9zaXRpb25zO1xuICByZXR1cm4gY2xvbmU7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tTXVsdGlMaW5lU3RyaW5nKGxzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGxzLnR5cGUgIT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIEdlb0pTT04gTXVsdGlMaW5lU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKGxzKTtcbiAgY29uc3QgbXVsdGlMZW5ndGhzID0gY2xvbmUuY29vcmRpbmF0ZXMubWFwKChwb3NzKSA9PiBwb3NzLmxlbmd0aCk7XG4gIGNvbnN0IGZsYXR0ZW5Qb3NpdGlvbnMgPSBjbG9uZS5jb29yZGluYXRlcy5mbGF0KCk7XG4gIGNvbnN0IGZsYXR0ZW5Qb3NpdGlvbnNFbGV2YXRlZCA9IGF3YWl0IGJhdGNoKGZsYXR0ZW5Qb3NpdGlvbnMsIG9wdGlvbnMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBsZW5ndGggb2YgbXVsdGlMZW5ndGhzKSB7XG4gICAgcmVzdWx0LnB1c2goZmxhdHRlblBvc2l0aW9uc0VsZXZhdGVkLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCkpO1xuICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgfVxuICBjbG9uZS5jb29yZGluYXRlcyA9IHJlc3VsdDtcbiAgcmV0dXJuIGNsb25lO1xufVxuY29uc3QgZWxldmF0aW9uID0ge1xuICBhdCxcbiAgYmF0Y2gsXG4gIGZyb21MaW5lU3RyaW5nLFxuICBmcm9tTXVsdGlMaW5lU3RyaW5nXG59O1xuXG5leHBvcnQgeyBDbGllbnRDb25maWcsIExhbmd1YWdlR2VvY29kaW5nLCBNYXBTdHlsZSwgTWFwU3R5bGVWYXJpYW50LCBSZWZlcmVuY2VNYXBTdHlsZSwgU2VydmljZUVycm9yLCBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXIsIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlLCBjb25maWcsIGNvb3JkaW5hdGVzLCBkYXRhLCBlbGV2YXRpb24sIGV4cGFuZE1hcFN0eWxlLCBnZW9jb2RpbmcsIGdlb2xvY2F0aW9uLCBnZXRBdXRvTGFuZ3VhZ2VHZW9jb2RpbmcsIGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyLCBnZXRUaWxlQ2FjaGUsIG1hcFN0eWxlUHJlc2V0TGlzdCwgbWF0aCwgbWlzYywgc3RhdGljTWFwcywgc3R5bGVUb1N0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXB0aWxlci1jbGllbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AJAXError: () => (/* binding */ AJAXError),\n/* harmony export */   AttributionControl: () => (/* binding */ AttributionControl),\n/* harmony export */   CanvasSource: () => (/* binding */ CanvasSource),\n/* harmony export */   CanvasSourceMLGL: () => (/* binding */ CanvasSourceMLGL),\n/* harmony export */   ColorRamp: () => (/* binding */ ColorRamp),\n/* harmony export */   ColorRampCollection: () => (/* binding */ ColorRampCollection),\n/* harmony export */   Evented: () => (/* binding */ Evented),\n/* harmony export */   FullscreenControl: () => (/* binding */ FullscreenControl),\n/* harmony export */   GeoJSONSource: () => (/* binding */ GeoJSONSource),\n/* harmony export */   GeoJSONSourceMLGL: () => (/* binding */ GeoJSONSourceMLGL),\n/* harmony export */   GeolocateControl: () => (/* binding */ GeolocateControl),\n/* harmony export */   GeolocationType: () => (/* binding */ GeolocationType),\n/* harmony export */   ImageSource: () => (/* binding */ ImageSource),\n/* harmony export */   ImageSourceMLGL: () => (/* binding */ ImageSourceMLGL),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageGeocoding: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.LanguageGeocoding),\n/* harmony export */   LngLat: () => (/* binding */ LngLat),\n/* harmony export */   LngLatBounds: () => (/* binding */ LngLatBounds),\n/* harmony export */   LogoControl: () => (/* binding */ LogoControl),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapMLGL: () => (/* binding */ MapMLGL),\n/* harmony export */   MapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyleVariant),\n/* harmony export */   MaptilerGeolocateControl: () => (/* binding */ MaptilerGeolocateControl),\n/* harmony export */   MaptilerLogoControl: () => (/* binding */ MaptilerLogoControl),\n/* harmony export */   MaptilerNavigationControl: () => (/* binding */ MaptilerNavigationControl),\n/* harmony export */   MaptilerTerrainControl: () => (/* binding */ MaptilerTerrainControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   MarkerMLGL: () => (/* binding */ MarkerMLGL),\n/* harmony export */   MercatorCoordinate: () => (/* binding */ MercatorCoordinate),\n/* harmony export */   NavigationControl: () => (/* binding */ NavigationControl),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Popup: () => (/* binding */ Popup),\n/* harmony export */   PopupMLGL: () => (/* binding */ PopupMLGL),\n/* harmony export */   RasterDEMTileSource: () => (/* binding */ RasterDEMTileSource),\n/* harmony export */   RasterDEMTileSourceMLGL: () => (/* binding */ RasterDEMTileSourceMLGL),\n/* harmony export */   RasterTileSource: () => (/* binding */ RasterTileSource),\n/* harmony export */   RasterTileSourceMLGL: () => (/* binding */ RasterTileSourceMLGL),\n/* harmony export */   ReferenceMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ReferenceMapStyle),\n/* harmony export */   ScaleControl: () => (/* binding */ ScaleControl),\n/* harmony export */   SdkConfig: () => (/* binding */ SdkConfig),\n/* harmony export */   ServiceError: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ServiceError),\n/* harmony export */   Style: () => (/* binding */ Style),\n/* harmony export */   StyleMLGL: () => (/* binding */ StyleMLGL),\n/* harmony export */   TerrainControl: () => (/* binding */ TerrainControl),\n/* harmony export */   VectorTileSource: () => (/* binding */ VectorTileSource),\n/* harmony export */   VectorTileSourceMLGL: () => (/* binding */ VectorTileSourceMLGL),\n/* harmony export */   VideoSource: () => (/* binding */ VideoSource),\n/* harmony export */   VideoSourceMLGL: () => (/* binding */ VideoSourceMLGL),\n/* harmony export */   addProtocol: () => (/* binding */ addProtocol),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.bufferToPixelDataBrowser),\n/* harmony export */   circumferenceAtLatitude: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.circumferenceAtLatitude),\n/* harmony export */   clearPrewarmedResources: () => (/* binding */ clearPrewarmedResources),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   coordinates: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.coordinates),\n/* harmony export */   data: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.data),\n/* harmony export */   elevation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.elevation),\n/* harmony export */   expandMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.expandMapStyle),\n/* harmony export */   geocoding: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geocoding),\n/* harmony export */   geolocation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation),\n/* harmony export */   getAutoLanguageGeocoding: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getAutoLanguageGeocoding),\n/* harmony export */   getBrowserLanguage: () => (/* binding */ getBrowserLanguage),\n/* harmony export */   getBufferToPixelDataParser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getBufferToPixelDataParser),\n/* harmony export */   getRTLTextPluginStatus: () => (/* binding */ getRTLTextPluginStatus),\n/* harmony export */   getTileCache: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getTileCache),\n/* harmony export */   gpx: () => (/* binding */ gpx),\n/* harmony export */   gpxOrKml: () => (/* binding */ gpxOrKml),\n/* harmony export */   hasChildNodeWithName: () => (/* binding */ hasChildNodeWithName),\n/* harmony export */   helpers: () => (/* binding */ helpers),\n/* harmony export */   isLanguageSupported: () => (/* binding */ isLanguageSupported),\n/* harmony export */   kml: () => (/* binding */ kml),\n/* harmony export */   mapStylePresetList: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList),\n/* harmony export */   math: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.math),\n/* harmony export */   maxParallelImageRequests: () => (/* binding */ maxParallelImageRequests),\n/* harmony export */   misc: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.misc),\n/* harmony export */   prewarm: () => (/* binding */ prewarm),\n/* harmony export */   removeProtocol: () => (/* binding */ removeProtocol),\n/* harmony export */   setRTLTextPlugin: () => (/* binding */ setRTLTextPlugin),\n/* harmony export */   staticMaps: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.staticMaps),\n/* harmony export */   str2xml: () => (/* binding */ str2xml),\n/* harmony export */   styleToStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.styleToStyle),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   workerCount: () => (/* binding */ workerCount),\n/* harmony export */   workerUrl: () => (/* binding */ workerUrl),\n/* harmony export */   xml2str: () => (/* binding */ xml2str)\n/* harmony export */ });\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maplibre-gl */ \"(ssr)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in maplibre_gl__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"LanguageGeocoding\",\"MapStyle\",\"MapStyleVariant\",\"ReferenceMapStyle\",\"ServiceError\",\"bufferToPixelDataBrowser\",\"circumferenceAtLatitude\",\"coordinates\",\"data\",\"elevation\",\"expandMapStyle\",\"geocoding\",\"geolocation\",\"getAutoLanguageGeocoding\",\"getBufferToPixelDataParser\",\"getTileCache\",\"mapStylePresetList\",\"math\",\"misc\",\"staticMaps\",\"styleToStyle\",\"AJAXError\",\"AttributionControl\",\"CanvasSource\",\"CanvasSourceMLGL\",\"ColorRamp\",\"ColorRampCollection\",\"Evented\",\"FullscreenControl\",\"GeoJSONSource\",\"GeoJSONSourceMLGL\",\"GeolocateControl\",\"GeolocationType\",\"ImageSource\",\"ImageSourceMLGL\",\"Language\",\"LngLat\",\"LngLatBounds\",\"LogoControl\",\"Map\",\"MapMLGL\",\"MaptilerGeolocateControl\",\"MaptilerLogoControl\",\"MaptilerNavigationControl\",\"MaptilerTerrainControl\",\"Marker\",\"MarkerMLGL\",\"MercatorCoordinate\",\"NavigationControl\",\"Point\",\"Popup\",\"PopupMLGL\",\"RasterDEMTileSource\",\"RasterDEMTileSourceMLGL\",\"RasterTileSource\",\"RasterTileSourceMLGL\",\"ScaleControl\",\"SdkConfig\",\"Style\",\"StyleMLGL\",\"TerrainControl\",\"VectorTileSource\",\"VectorTileSourceMLGL\",\"VideoSource\",\"VideoSourceMLGL\",\"addProtocol\",\"clearPrewarmedResources\",\"config\",\"getBrowserLanguage\",\"getRTLTextPluginStatus\",\"gpx\",\"gpxOrKml\",\"hasChildNodeWithName\",\"helpers\",\"isLanguageSupported\",\"kml\",\"maxParallelImageRequests\",\"prewarm\",\"removeProtocol\",\"setRTLTextPlugin\",\"str2xml\",\"version\",\"workerCount\",\"workerUrl\",\"xml2str\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => maplibre_gl__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var _maptiler_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @maptiler/client */ \"(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v4.js\");\n\n\n\n\n\n\n\n\nconst Language = {\n  /**\n   * The visitor language mode concatenates the prefered language from the user settings and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR: \"visitor\",\n  /**\n   * The visitor language mode concatenates English and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR_ENGLISH: \"visitor_en\",\n  /**\n   * Language as the style is designed. Not that this is the default state and one\n   * the language has been changed to another than `STYLE`, then it cannot be set back to `STYLE`.\n   */\n  STYLE: \"style\",\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"name:latin\",\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"name:nonlatin\",\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"name\",\n  /**\n   * International name\n   */\n  INTERNATIONAL: \"name_int\",\n  ALBANIAN: \"name:sq\",\n  AMHARIC: \"name:am\",\n  ARABIC: \"name:ar\",\n  ARMENIAN: \"name:hy\",\n  AZERBAIJANI: \"name:az\",\n  BASQUE: \"name:eu\",\n  BELORUSSIAN: \"name:be\",\n  BENGALI: \"name:bn\",\n  BOSNIAN: \"name:bs\",\n  BRETON: \"name:br\",\n  BULGARIAN: \"name:bg\",\n  CATALAN: \"name:ca\",\n  CHINESE: \"name:zh\",\n  TRADITIONAL_CHINESE: \"name:zh-Hant\",\n  SIMPLIFIED_CHINESE: \"name:zh-Hans\",\n  CORSICAN: \"name:co\",\n  CROATIAN: \"name:hr\",\n  CZECH: \"name:cs\",\n  DANISH: \"name:da\",\n  DUTCH: \"name:nl\",\n  ENGLISH: \"name:en\",\n  ESPERANTO: \"name:eo\",\n  ESTONIAN: \"name:et\",\n  FINNISH: \"name:fi\",\n  FRENCH: \"name:fr\",\n  FRISIAN: \"name:fy\",\n  GEORGIAN: \"name:ka\",\n  GERMAN: \"name:de\",\n  GREEK: \"name:el\",\n  HEBREW: \"name:he\",\n  HINDI: \"name:hi\",\n  HUNGARIAN: \"name:hu\",\n  ICELANDIC: \"name:is\",\n  INDONESIAN: \"name:id\",\n  IRISH: \"name:ga\",\n  ITALIAN: \"name:it\",\n  JAPANESE: \"name:ja\",\n  JAPANESE_HIRAGANA: \"name:ja-Hira\",\n  JAPANESE_KANA: \"name:ja_kana\",\n  JAPANESE_LATIN: \"name:ja_rm\",\n  JAPANESE_2018: \"name:ja-Latn\",\n  KANNADA: \"name:kn\",\n  KAZAKH: \"name:kk\",\n  KOREAN: \"name:ko\",\n  KOREAN_LATIN: \"name:ko-Latn\",\n  KURDISH: \"name:ku\",\n  ROMAN_LATIN: \"name:la\",\n  LATVIAN: \"name:lv\",\n  LITHUANIAN: \"name:lt\",\n  LUXEMBOURGISH: \"name:lb\",\n  MACEDONIAN: \"name:mk\",\n  MALAYALAM: \"name:ml\",\n  MALTESE: \"name:mt\",\n  NORWEGIAN: \"name:no\",\n  OCCITAN: \"name:oc\",\n  PERSIAN: \"name:fa\",\n  POLISH: \"name:pl\",\n  PORTUGUESE: \"name:pt\",\n  PUNJABI: \"name:pa\",\n  WESTERN_PUNJABI: \"name:pnb\",\n  ROMANIAN: \"name:ro\",\n  ROMANSH: \"name:rm\",\n  RUSSIAN: \"name:ru\",\n  SCOTTISH_GAELIC: \"name:gd\",\n  SERBIAN_CYRILLIC: \"name:sr\",\n  SERBIAN_LATIN: \"name:sr-Latn\",\n  SLOVAK: \"name:sk\",\n  SLOVENE: \"name:sl\",\n  SPANISH: \"name:es\",\n  SWEDISH: \"name:sv\",\n  TAMIL: \"name:ta\",\n  TELUGU: \"name:te\",\n  THAI: \"name:th\",\n  TURKISH: \"name:tr\",\n  UKRAINIAN: \"name:uk\",\n  URDU: \"name:ur\",\n  VIETNAMIAN_LATIN: \"name:vi\",\n  WELSH: \"name:cy\"\n};\nconst languagesIsoSet = new Set(Object.values(Language));\nfunction isLanguageSupported(lang) {\n  return languagesIsoSet.has(lang);\n}\nconst languageCodeSet = new Set(Object.values(Language));\nfunction getBrowserLanguage() {\n  if (typeof navigator === \"undefined\") {\n    return `name:${Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0]}`;\n  }\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => `name:${l.split(\"-\")[0]}`))\n  ).filter((l) => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : Language.LOCAL;\n}\n\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.STYLE,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(defaults);\n\nvar __defProp$b = Object.defineProperty;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$8 = (obj, key, value) => {\n  __defNormalProp$b(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst MAPTILER_SESSION_ID = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\nclass SdkConfig extends events__WEBPACK_IMPORTED_MODULE_1__ {\n  constructor() {\n    super();\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    __publicField$8(this, \"primaryLanguage\", defaults.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    __publicField$8(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    __publicField$8(this, \"session\", true);\n    /**\n     * Unit to be used\n     */\n    __publicField$8(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    __publicField$8(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(u) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n    _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.fetch;\n  }\n}\nconst config = new SdkConfig();\n\nclass LogoControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$7 = (obj, key, value) => {\n  __defNormalProp$a(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerLogoControl extends LogoControl {\n  constructor(options = {}) {\n    var _a, _b;\n    super(options);\n    __publicField$7(this, \"logoURL\", \"\");\n    __publicField$7(this, \"linkURL\", \"\");\n    this.logoURL = (_a = options.logoURL) != null ? _a : defaults.maptilerLogoURL;\n    this.linkURL = (_b = options.linkURL) != null ? _b : defaults.maptilerURL;\n  }\n  onAdd(map) {\n    var _a;\n    this._map = map;\n    this._compact = (_a = this.options.compact) != null ? _a : false;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n    return this._container;\n  }\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction enableRTL() {\n  if (maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.setRTLTextPlugin(\n      defaults.rtlPluginURL,\n      (err) => {\n        if (err)\n          console.error(err);\n      },\n      true\n      // Lazy load the plugin\n    );\n  }\n}\nfunction bindAll(fns, context) {\n  fns.forEach((fn) => {\n    if (typeof context[fn] !== \"function\")\n      return;\n    context[fn] = context[fn].bind(context);\n  });\n}\nfunction DOMcreate(tagName, className, container) {\n  const el = window.document.createElement(tagName);\n  if (className !== void 0)\n    el.className = className;\n  if (container)\n    container.appendChild(el);\n  return el;\n}\nfunction DOMremove(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction maptilerCloudTransformRequest(url, _resourceType) {\n  let reqUrl = null;\n  try {\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url\n    };\n  }\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n  return {\n    url: reqUrl.href\n  };\n}\nfunction combineTransformRequest(userDefinedRTF) {\n  return function(url, resourceType) {\n    var _a;\n    if (userDefinedRTF !== void 0) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest((_a = rp == null ? void 0 : rp.url) != null ? _a : \"\");\n      return __spreadValues$5(__spreadValues$5({}, rp), rp2);\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\nfunction generateRandomString() {\n  return Math.random().toString(36).substring(2);\n}\nfunction isUUID(s) {\n  const regexExp = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\n  return regexExp.test(s);\n}\nfunction jsonParseNoThrow(doc) {\n  try {\n    return JSON.parse(doc);\n  } catch (e) {\n  }\n  return null;\n}\n\nfunction styleToStyle(style) {\n  if (!style) {\n    return _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      return style;\n    } else {\n      return (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.expandMapStyle)(style);\n    }\n  }\n  if (style instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n  if (style instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ReferenceMapStyle) {\n    return style.getDefaultVariant().getExpandedStyleURL();\n  }\n  return style;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$6 = (obj, key, value) => {\n  __defNormalProp$8(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerTerrainControl {\n  constructor() {\n    __publicField$6(this, \"_map\");\n    __publicField$6(this, \"_container\");\n    __publicField$6(this, \"_terrainButton\");\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(map) {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-terrain\",\n      this._container\n    );\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\n      \"aria-hidden\",\n      \"true\"\n    );\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n  onRemove() {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    this._map = void 0;\n  }\n  _toggleTerrain() {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n    this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.disableTerrain\"\n      );\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.enableTerrain\"\n      );\n    }\n  }\n}\n\nclass NavigationControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$7(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    __publicField$5(this, \"_rotateCompassArrow\", () => {\n      const rotate = this.options.visualizePitch ? `scale(${Math.min(\n        1.5,\n        1 / Math.pow(\n          Math.cos(this._map.transform.pitch * (Math.PI / 180)),\n          0.5\n        )\n      )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n      this._compassIcon.style.transform = rotate;\n    });\n    this._compass.removeEventListener(\n      \"click\",\n      this._compass.clickFunction\n    );\n    this._compass.addEventListener(\"click\", (e) => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, { originalEvent: e });\n          } else {\n            this._map.resetNorth({}, { originalEvent: e });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(className, fn) {\n    const button = super._createButton(className, fn);\n    button.clickFunction = fn;\n    return button;\n  }\n}\n\nclass GeolocateControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$6(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Marker$1 = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker;\nconst LngLat$1 = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLat;\nconst LngLatBounds$1 = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds;\nclass MaptilerGeolocateControl extends GeolocateControl {\n  constructor() {\n    super(...arguments);\n    __publicField$4(this, \"lastUpdatedCenter\", new LngLat$1(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    __publicField$4(this, \"_updateCamera\", (position) => {\n      var _a, _b, _c;\n      const center = new LngLat$1(\n        position.coords.longitude,\n        position.coords.latitude\n      );\n      const radius = position.coords.accuracy;\n      const bearing = this._map.getBearing();\n      const options = __spreadProps$3(__spreadValues$4({\n        bearing\n      }, this.options.fitBoundsOptions), {\n        linear: true\n      });\n      const currentMapZoom = this._map.getZoom();\n      if (currentMapZoom > ((_c = (_b = (_a = this.options) == null ? void 0 : _a.fitBoundsOptions) == null ? void 0 : _b.maxZoom) != null ? _c : 30)) {\n        options.zoom = currentMapZoom;\n      }\n      this._map.fitBounds(LngLatBounds$1.fromLngLat(center, radius), options, {\n        geolocateSource: true\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let hasFittingBeenDisrupted = false;\n      const flagFittingDisruption = () => {\n        hasFittingBeenDisrupted = true;\n      };\n      this._map.once(\"click\", flagFittingDisruption);\n      this._map.once(\"dblclick\", flagFittingDisruption);\n      this._map.once(\"dragstart\", flagFittingDisruption);\n      this._map.once(\"mousedown\", flagFittingDisruption);\n      this._map.once(\"touchstart\", flagFittingDisruption);\n      this._map.once(\"wheel\", flagFittingDisruption);\n      this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", flagFittingDisruption);\n        this._map.off(\"dblclick\", flagFittingDisruption);\n        this._map.off(\"dragstart\", flagFittingDisruption);\n        this._map.off(\"mousedown\", flagFittingDisruption);\n        this._map.off(\"touchstart\", flagFittingDisruption);\n        this._map.off(\"wheel\", flagFittingDisruption);\n        if (hasFittingBeenDisrupted) {\n          return;\n        }\n        this.lastUpdatedCenter = this._map.getCenter();\n      });\n    });\n    __publicField$4(this, \"_setupUI\", (supported) => {\n      this.lastUpdatedCenter = this._map.getCenter();\n      this._container.addEventListener(\n        \"contextmenu\",\n        (e) => e.preventDefault()\n      );\n      this._geolocateButton = DOMcreate(\n        \"button\",\n        \"maplibregl-ctrl-geolocate\",\n        this._container\n      );\n      DOMcreate(\n        \"span\",\n        \"maplibregl-ctrl-icon\",\n        this._geolocateButton\n      ).setAttribute(\"aria-hidden\", \"true\");\n      this._geolocateButton.type = \"button\";\n      if (supported === false) {\n        const title = this._map._getUIString(\n          \"GeolocateControl.LocationNotAvailable\"\n        );\n        this._geolocateButton.disabled = true;\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      } else {\n        const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      }\n      if (this.options.trackUserLocation) {\n        this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n        this._watchState = \"OFF\";\n      }\n      if (this.options.showUserLocation) {\n        this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n        this._userLocationDotMarker = new Marker$1({ element: this._dotElement });\n        this._circleElement = DOMcreate(\n          \"div\",\n          \"maplibregl-user-location-accuracy-circle\"\n        );\n        this._accuracyCircleMarker = new Marker$1({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        });\n        if (this.options.trackUserLocation)\n          this._watchState = \"OFF\";\n        this._map.on(\"move\", this._onZoom);\n      }\n      this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n      this._setup = true;\n      if (this.options.trackUserLocation) {\n        this._map.on(\"moveend\", (event) => {\n          const fromResize = event.originalEvent && event.originalEvent.type === \"resize\";\n          const movingDistance = this.lastUpdatedCenter.distanceTo(\n            this._map.getCenter()\n          );\n          if (!event.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !fromResize && movingDistance > 1) {\n            this._watchState = \"BACKGROUND\";\n            this._geolocateButton.classList.add(\n              \"maplibregl-ctrl-geolocate-background\"\n            );\n            this._geolocateButton.classList.remove(\n              \"maplibregl-ctrl-geolocate-active\"\n            );\n            this.fire(new Event(\"trackuserlocationend\"));\n          }\n        });\n      }\n    });\n    __publicField$4(this, \"_onZoom\", () => {\n      if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n        this._updateCircleRadius();\n      }\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") {\n      return;\n    }\n    const lastKnownLocation = [\n      this._lastKnownPosition.coords.longitude,\n      this._lastKnownPosition.coords.latitude\n    ];\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([\n      projectedLocation.x + 20,\n      projectedLocation.y\n    ]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n    const circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n}\n\nclass AttributionControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nclass ScaleControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nclass FullscreenControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _options, _parentMap, _container, _canvasContainer, _parentRect, _differentStyle, _desync, _addParentRect, addParentRect_fn, _setParentBounds, setParentBounds_fn, _syncMaps, syncMaps_fn;\nclass Minimap {\n  constructor(options, mapOptions) {\n    __privateAdd(this, _addParentRect);\n    __privateAdd(this, _setParentBounds);\n    __privateAdd(this, _syncMaps);\n    __privateAdd(this, _options, void 0);\n    __publicField$3(this, \"map\");\n    __privateAdd(this, _parentMap, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _canvasContainer, void 0);\n    __privateAdd(this, _parentRect, void 0);\n    __privateAdd(this, _differentStyle, false);\n    __privateAdd(this, _desync, void 0);\n    var _a;\n    if (options.style !== void 0)\n      __privateSet(this, _differentStyle, true);\n    __privateSet(this, _options, __spreadProps$2(__spreadValues$3(__spreadProps$2(__spreadValues$3({\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\"\n    }, mapOptions), {\n      // override any lingering control options\n      forceNoAttributionControl: true,\n      attributionControl: false,\n      navigationControl: false,\n      geolocateControl: false,\n      maptilerLogo: false,\n      minimap: false,\n      hash: false,\n      pitchAdjust: false\n    }), options), {\n      containerStyle: __spreadValues$3({\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\"\n      }, (_a = options.containerStyle) != null ? _a : {})\n    }));\n    if (options.lockZoom !== void 0) {\n      __privateGet(this, _options).minZoom = options.lockZoom;\n      __privateGet(this, _options).maxZoom = options.lockZoom;\n    }\n  }\n  setStyle(style, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setStyle(style, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n  }\n  addLayer(layer, beforeId) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.addLayer(layer, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  moveLayer(id, beforeId) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.moveLayer(id, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  removeLayer(id) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.removeLayer(id);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setLayerZoomRange(layerId, minzoom, maxzoom);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setFilter(layerId, filter, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setFilter(layerId, filter, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setPaintProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setPaintProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayoutProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setLayoutProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setGlyphs(glyphsUrl, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setGlyphs(glyphsUrl, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  onAdd(parentMap) {\n    __privateSet(this, _parentMap, parentMap);\n    __privateSet(this, _container, DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [key, value] of Object.entries(__privateGet(this, _options).containerStyle)) {\n      __privateGet(this, _container).style.setProperty(key, value);\n    }\n    __privateGet(this, _options).container = __privateGet(this, _container);\n    __privateGet(this, _options).zoom = parentMap.getZoom() + __privateGet(this, _options).zoomAdjust;\n    this.map = new Map(__privateGet(this, _options));\n    this.map.once(\"style.load\", () => {\n      this.map.resize();\n    });\n    this.map.once(\"load\", () => {\n      __privateMethod(this, _addParentRect, addParentRect_fn).call(this, __privateGet(this, _options).parentRect);\n      __privateSet(this, _desync, __privateMethod(this, _syncMaps, syncMaps_fn).call(this));\n    });\n    return __privateGet(this, _container);\n  }\n  onRemove() {\n    var _a;\n    (_a = __privateGet(this, _desync)) == null ? void 0 : _a.call(this);\n    DOMremove(__privateGet(this, _container));\n  }\n}\n_options = new WeakMap();\n_parentMap = new WeakMap();\n_container = new WeakMap();\n_canvasContainer = new WeakMap();\n_parentRect = new WeakMap();\n_differentStyle = new WeakMap();\n_desync = new WeakMap();\n_addParentRect = new WeakSet();\naddParentRect_fn = function(rect) {\n  if (rect === void 0 || rect.linePaint === void 0 && rect.fillPaint === void 0) {\n    return;\n  }\n  __privateSet(this, _parentRect, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  });\n  this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: __privateGet(this, _parentRect)\n  });\n  if (rect.lineLayout !== void 0 || rect.linePaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectOutline\",\n      type: \"line\",\n      source: \"parentRect\",\n      layout: __spreadValues$3({}, rect.lineLayout),\n      paint: __spreadValues$3({\n        \"line-color\": \"#FFF\",\n        \"line-width\": 1,\n        \"line-opacity\": 0.85\n      }, rect.linePaint)\n    });\n  }\n  if (rect.fillPaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectFill\",\n      type: \"fill\",\n      source: \"parentRect\",\n      layout: {},\n      paint: __spreadValues$3({\n        \"fill-color\": \"#08F\",\n        \"fill-opacity\": 0.135\n      }, rect.fillPaint)\n    });\n  }\n  __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n};\n_setParentBounds = new WeakSet();\nsetParentBounds_fn = function() {\n  if (__privateGet(this, _parentRect) === void 0)\n    return;\n  const { devicePixelRatio } = window;\n  const canvas = __privateGet(this, _parentMap).getCanvas();\n  const width = canvas.width / devicePixelRatio;\n  const height = canvas.height / devicePixelRatio;\n  const unproject = __privateGet(this, _parentMap).unproject.bind(__privateGet(this, _parentMap));\n  const northWest = unproject([0, 0]);\n  const northEast = unproject([width, 0]);\n  const southWest = unproject([0, height]);\n  const southEast = unproject([width, height]);\n  __privateGet(this, _parentRect).geometry.coordinates = [\n    [\n      southWest.toArray(),\n      southEast.toArray(),\n      northEast.toArray(),\n      northWest.toArray(),\n      southWest.toArray()\n    ]\n  ];\n  const source = this.map.getSource(\"parentRect\");\n  source.setData(__privateGet(this, _parentRect));\n};\n_syncMaps = new WeakSet();\nsyncMaps_fn = function() {\n  const { pitchAdjust } = __privateGet(this, _options);\n  const parentCallback = () => {\n    sync(\"parent\");\n  };\n  const minimapCallback = () => {\n    sync(\"minimap\");\n  };\n  const on = () => {\n    __privateGet(this, _parentMap).on(\"move\", parentCallback);\n    this.map.on(\"move\", minimapCallback);\n  };\n  const off = () => {\n    __privateGet(this, _parentMap).off(\"move\", parentCallback);\n    this.map.off(\"move\", minimapCallback);\n  };\n  const sync = (which) => {\n    var _a;\n    off();\n    const from = which === \"parent\" ? __privateGet(this, _parentMap) : this.map;\n    const to = which === \"parent\" ? this.map : __privateGet(this, _parentMap);\n    const center = from.getCenter();\n    const zoom = from.getZoom() + ((_a = __privateGet(this, _options).zoomAdjust) != null ? _a : -4) * (which === \"parent\" ? 1 : -1);\n    const bearing = from.getBearing();\n    const pitch = from.getPitch();\n    to.jumpTo({\n      center,\n      zoom,\n      bearing,\n      pitch: pitchAdjust ? pitch : 0\n    });\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    on();\n  };\n  on();\n  return () => {\n    off();\n  };\n};\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async$1 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst GeolocationType = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nclass Map extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map {\n  constructor(options) {\n    var _a, _b, _c;\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n    if (!config.apiKey) {\n      console.warn(\n        \"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\"\n      );\n    }\n    super(__spreadProps$1(__spreadValues$2({}, options), {\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest)\n    }));\n    __publicField$2(this, \"isTerrainEnabled\", false);\n    __publicField$2(this, \"terrainExaggeration\", 1);\n    __publicField$2(this, \"primaryLanguage\");\n    __publicField$2(this, \"terrainGrowing\", false);\n    __publicField$2(this, \"terrainFlattening\", false);\n    __publicField$2(this, \"minimap\");\n    __publicField$2(this, \"forceLanguageUpdate\");\n    __publicField$2(this, \"languageAlwaysBeenStyle\");\n    __publicField$2(this, \"isReady\", false);\n    this.primaryLanguage = (_a = options.language) != null ? _a : config.primaryLanguage;\n    this.forceLanguageUpdate = this.primaryLanguage === Language.STYLE || this.primaryLanguage === Language.STYLE_LOCK ? false : true;\n    this.languageAlwaysBeenStyle = this.primaryLanguage === Language.STYLE;\n    this.terrainExaggeration = (_b = options.terrainExaggeration) != null ? _b : this.terrainExaggeration;\n    this.once(\"styledata\", () => __async$1(this, null, function* () {\n      if (!options.geolocate) {\n        return;\n      }\n      if (options.center) {\n        return;\n      }\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          yield this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        console.warn(e.message);\n      }\n      let ipLocatedCameraHash;\n      try {\n        yield this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        console.warn(e.message);\n      }\n      const locationResult = yield navigator.permissions.query({\n        name: \"geolocation\"\n      });\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n          // success callback\n          (data) => {\n            if (ipLocatedCameraHash !== this.getCameraHash()) {\n              return;\n            }\n            if (this.terrain) {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2e3\n              });\n            } else {\n              this.once(\"terrain\", () => {\n                this.easeTo({\n                  center: [data.coords.longitude, data.coords.latitude],\n                  zoom: options.zoom || 12,\n                  duration: 2e3\n                });\n              });\n            }\n          },\n          // error callback\n          null,\n          // options\n          {\n            maximumAge: 24 * 3600 * 1e3,\n            // a day in millisec\n            timeout: 5e3,\n            // milliseconds\n            enableHighAccuracy: false\n          }\n        );\n      }\n    }));\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    });\n    this.on(\"styledata\", () => {\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      enableRTL();\n    }));\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      let tileJsonContent = { logo: null };\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches).map((sourceName) => this.getSource(sourceName)).filter(\n          (s) => s && \"url\" in s && typeof s.url === \"string\" && (s == null ? void 0 : s.url.includes(\"tiles.json\"))\n        );\n        const styleUrl = new URL(\n          possibleSources[0].url\n        );\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n        const tileJsonRes = yield fetch(styleUrl.href);\n        tileJsonContent = yield tileJsonRes.json();\n      } catch (e) {\n      }\n      if (options.forceNoAttributionControl !== true) {\n        if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n          const logoURL = tileJsonContent.logo;\n          this.addControl(\n            new MaptilerLogoControl({ logoURL }),\n            options.logoPosition\n          );\n          if (options.attributionControl === false) {\n            this.addControl(\n              new AttributionControl({\n                customAttribution: options.customAttribution\n              })\n            );\n          }\n        } else if (options.maptilerLogo) {\n          this.addControl(new MaptilerLogoControl(), options.logoPosition);\n        }\n      }\n      if (options.scaleControl) {\n        const position = options.scaleControl === true || options.scaleControl === void 0 ? \"bottom-right\" : options.scaleControl;\n        const scaleControl = new ScaleControl({ unit: config.unit });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", (unit) => {\n          scaleControl.setUnit(unit);\n        });\n      }\n      if (options.navigationControl !== false) {\n        const position = options.navigationControl === true || options.navigationControl === void 0 ? \"top-right\" : options.navigationControl;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n      if (options.geolocateControl !== false) {\n        const position = options.geolocateControl === true || options.geolocateControl === void 0 ? \"top-right\" : options.geolocateControl;\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new MaptilerGeolocateControl({\n            positionOptions: {\n              enableHighAccuracy: true,\n              maximumAge: 0,\n              timeout: 6e3\n            },\n            fitBoundsOptions: {\n              maxZoom: 15\n            },\n            trackUserLocation: true,\n            showAccuracyCircle: true,\n            showUserLocation: true\n          }),\n          position\n        );\n      }\n      if (options.terrainControl) {\n        const position = options.terrainControl === true || options.terrainControl === void 0 ? \"top-right\" : options.terrainControl;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n      if (options.fullscreenControl) {\n        const position = options.fullscreenControl === true || options.fullscreenControl === void 0 ? \"top-right\" : options.fullscreenControl;\n        this.addControl(new FullscreenControl({}), position);\n      }\n      this.isReady = true;\n      this.fire(\"ready\", { target: this });\n    }));\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData;\n    this.once(\"ready\", () => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n    this.once(\"style.load\", () => {\n      var _a2;\n      const { minimap } = options;\n      if (typeof minimap === \"object\") {\n        const {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        } = options;\n        this.minimap = new Minimap(minimap, {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          container: \"null\",\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        });\n        this.addControl(this.minimap, (_a2 = minimap.position) != null ? _a2 : \"bottom-left\");\n      } else if (minimap === true) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, \"bottom-left\");\n      } else if (minimap !== void 0 && minimap !== false) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, minimap);\n      }\n    });\n    const terrainCallback = (evt) => {\n      if (!evt.terrain)\n        return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain\n      };\n      this.off(\"terrain\", terrainCallback);\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    };\n    this.on(\"terrain\", terrainCallback);\n    if (options.terrain) {\n      this.enableTerrain(\n        (_c = options.terrainExaggeration) != null ? _c : this.terrainExaggeration\n      );\n    }\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  onLoadAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.loaded()) {\n          return resolve(this);\n        }\n        this.once(\"load\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  onReadyAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.isReady) {\n          return resolve(this);\n        }\n        this.once(\"ready\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  onLoadWithTerrainAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.isReady && this.terrain) {\n          return resolve(this);\n        }\n        this.once(\"loadWithTerrain\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(style, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setStyle(style);\n    this.forceLanguageUpdate = true;\n    this.once(\"idle\", () => {\n      this.forceLanguageUpdate = false;\n    });\n    return super.setStyle(styleToStyle(style), options);\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(layer, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.addLayer(layer, beforeId);\n    return super.addLayer(layer, beforeId);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(id, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.moveLayer(id, beforeId);\n    return super.moveLayer(id, beforeId);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(id) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.removeLayer(id);\n    return super.removeLayer(id);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayerZoomRange(layerId, minzoom, maxzoom);\n    return super.setLayerZoomRange(layerId, minzoom, maxzoom);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(layerId, filter, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setFilter(layerId, filter, options);\n    return super.setFilter(layerId, filter, options);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setPaintProperty(layerId, name, value, options);\n    return super.setPaintProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayoutProperty(layerId, name, value, options);\n    return super.setLayoutProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(glyphsUrl, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setGlyphs(glyphsUrl, options);\n    return super.setGlyphs(glyphsUrl, options);\n  }\n  getStyleLanguage() {\n    if (!this.style.stylesheet.metadata)\n      return null;\n    if (typeof this.style.stylesheet.metadata !== \"object\")\n      return null;\n    if (\"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] === \"string\") {\n      return this.style.stylesheet.metadata[\"maptiler:language\"];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(language) {\n    var _a, _b;\n    (_b = (_a = this.minimap) == null ? void 0 : _a.map) == null ? void 0 : _b.setLanguage(language);\n    this.onStyleReady(() => {\n      this.setPrimaryLanguage(language);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(language) {\n    const styleLanguage = this.getStyleLanguage();\n    if (!(language === Language.STYLE && (styleLanguage === Language.AUTO || styleLanguage === Language.VISITOR))) {\n      if (language !== Language.STYLE) {\n        this.languageAlwaysBeenStyle = false;\n      }\n      if (this.languageAlwaysBeenStyle) {\n        return;\n      }\n      if (this.primaryLanguage === language && !this.forceLanguageUpdate) {\n        return;\n      }\n    }\n    if (!isLanguageSupported(language)) {\n      console.warn(`The language \"${language}\" is not supported.`);\n      return;\n    }\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\"\n      );\n      return;\n    }\n    this.primaryLanguage = language;\n    let languageNonStyle = language;\n    if (language === Language.STYLE) {\n      if (!styleLanguage) {\n        console.warn(\"The style has no default languages.\");\n        return;\n      }\n      if (!isLanguageSupported(styleLanguage)) {\n        console.warn(\"The language defined in the style is not valid.\");\n        return;\n      }\n      languageNonStyle = styleLanguage;\n    }\n    let langStr = Language.LOCAL;\n    let replacer = `{${langStr}}`;\n    if (languageNonStyle == Language.VISITOR) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 }\n          ]\n        ],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle == Language.VISITOR_ENGLISH) {\n      langStr = Language.ENGLISH;\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 }\n          ]\n        ],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle === Language.AUTO) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle === Language.LOCAL) {\n      langStr = Language.LOCAL;\n      replacer = `{${langStr}}`;\n    } else {\n      langStr = languageNonStyle;\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL]\n      ];\n    }\n    const { layers } = this.getStyle();\n    for (const { id, layout } of layers) {\n      if (!layout) {\n        continue;\n      }\n      if (!(\"text-field\" in layout)) {\n        continue;\n      }\n      const textFieldLayoutProp = this.getLayoutProperty(id, \"text-field\");\n      if (typeof textFieldLayoutProp === \"string\" && (textFieldLayoutProp.toLowerCase().includes(\"ref\") || textFieldLayoutProp.toLowerCase().includes(\"housenumber\"))) {\n        continue;\n      }\n      this.setLayoutProperty(id, \"text-field\", replacer);\n    }\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(exaggeration, durationMs = 1e3) {\n    if (!this.terrain) {\n      return;\n    }\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainFlattening) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const dataEventTerrainGrow = (evt) => __async$1(this, null, function* () {\n      if (!this.terrain) {\n        return;\n      }\n      if (evt.type !== \"data\" || evt.dataType !== \"source\" || !(\"source\" in evt)) {\n        return;\n      }\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n      const source = evt.source;\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n      this.off(\"data\", dataEventTerrainGrow);\n      this.growTerrain(exaggeration);\n    });\n    const addTerrain = () => {\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n      this.on(\"data\", dataEventTerrainGrow);\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL\n      });\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain) {\n      return;\n    }\n    this.isTerrainEnabled = false;\n    const animationLoopDuration = 1 * 1e3;\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainGrowing) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / animationLoopDuration;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.setTerrain();\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(exaggeration, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(cb) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n  fitToIpBounds() {\n    return __async$1(this, null, function* () {\n      const ipGeolocateResult = yield _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation.info();\n      this.fitBounds(\n        ipGeolocateResult.country_bounds,\n        {\n          duration: 0,\n          padding: 100\n        }\n      );\n    });\n  }\n  centerOnIpPoint(zoom) {\n    return __async$1(this, null, function* () {\n      var _a, _b;\n      const ipGeolocateResult = yield _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation.info();\n      this.jumpTo({\n        center: [\n          (_a = ipGeolocateResult == null ? void 0 : ipGeolocateResult.longitude) != null ? _a : 0,\n          (_b = ipGeolocateResult == null ? void 0 : ipGeolocateResult.latitude) != null ? _b : 0\n        ],\n        zoom: zoom || 11\n      });\n    });\n  }\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return js_base64__WEBPACK_IMPORTED_MODULE_4__.Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return config;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return MAPTILER_SESSION_ID;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(transformRequest) {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n  /**\n   * Loads an image. This is an async equivalent of `Map.loadImage`\n   */\n  loadImageAsync(url) {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.loadImage(\n          url,\n          (error, image) => {\n            if (error) {\n              reject(error);\n              return;\n            }\n            resolve(image);\n          }\n        );\n      });\n    });\n  }\n}\n\nclass Marker extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\n\nclass Popup extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\n\nclass Style extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style {\n  constructor(map, options = {}) {\n    super(map, options);\n  }\n}\n\nclass CanvasSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass GeoJSONSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass ImageSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass RasterTileSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass RasterDEMTileSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass VectorTileSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass VideoSource extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass TerrainControl extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Point {\n  constructor(x, y) {\n    __publicField$1(this, \"x\");\n    __publicField$1(this, \"y\");\n    this.x = x;\n    this.y = y;\n  }\n  _matMult(m) {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _add(p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  _sub(p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n  _mult(k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n  _div(k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n  _multByPoint(p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n  _divByPoint(p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n  _unit() {\n    this._div(this.mag());\n    return this;\n  }\n  _perp() {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n  _rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _rotateAround(angle, p) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p) {\n    return this.clone()._add(p);\n  }\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p) {\n    return this.clone()._sub(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p) {\n    return this.clone()._multByPoint(p);\n  }\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p) {\n    return this.clone()._divByPoint(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k) {\n    return this.clone()._mult(k);\n  }\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k) {\n    return this.clone()._div(k);\n  }\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a) {\n    return this.clone()._rotate(a);\n  }\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a, p) {\n    return this.clone()._rotateAround(a, p);\n  }\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m) {\n    return this.clone()._matMult(m);\n  }\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit() {\n    return this.clone()._unit();\n  }\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp() {\n    return this.clone()._perp();\n  }\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round() {\n    return this.clone()._round();\n  }\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p) {\n    return Math.sqrt(this.distSqr(p));\n  }\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p) {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b) {\n    return this.angleWithSep(b.x, b.y);\n  }\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin() for .\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction str2xml(str) {\n  if (typeof DOMParser !== \"undefined\") {\n    const doc = new DOMParser().parseFromString(str, \"application/xml\");\n    if (doc.querySelector(\"parsererror\")) {\n      throw new Error(\"The provided string is not valid XML\");\n    }\n    return doc;\n  } else {\n    throw new Error(\"No XML parser found\");\n  }\n}\nfunction hasChildNodeWithName(doc, nodeName) {\n  if (!doc.hasChildNodes()) {\n    return false;\n  }\n  for (const childNode of Array.from(doc.childNodes)) {\n    const currentNodeName = childNode.nodeName;\n    if (typeof currentNodeName === \"string\" && currentNodeName.trim().toLowerCase() === nodeName.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction xml2str(node) {\n  if (typeof XMLSerializer !== \"undefined\") {\n    return new XMLSerializer().serializeToString(node);\n  }\n  throw new Error(\"No XML serializer found\");\n}\nfunction gpx(doc) {\n  if (typeof doc === \"string\")\n    doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"gpx\")) {\n    throw new Error(\"The XML document is not valid GPX\");\n  }\n  const tracks = get(doc, \"trk\");\n  const routes = get(doc, \"rte\");\n  const waypoints = get(doc, \"wpt\");\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  for (const track of Array.from(tracks)) {\n    const feature = getTrack(track);\n    if (feature)\n      gj.features.push(feature);\n  }\n  for (const route of Array.from(routes)) {\n    const feature = getRoute(route);\n    if (feature)\n      gj.features.push(feature);\n  }\n  for (const waypoint of Array.from(waypoints)) {\n    gj.features.push(getPoint(waypoint));\n  }\n  return gj;\n}\nfunction kml(doc, xml2string) {\n  var _a;\n  if (typeof doc === \"string\")\n    doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"kml\")) {\n    throw new Error(\"The XML document is not valid KML\");\n  }\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  const styleIndex = {};\n  const styleByHash = {};\n  const styleMapIndex = {};\n  const placemarks = get(doc, \"Placemark\");\n  const styles = get(doc, \"Style\");\n  const styleMaps = get(doc, \"StyleMap\");\n  for (const style of Array.from(styles)) {\n    const hash = okhash(\n      xml2string !== void 0 ? xml2string(style) : xml2str(style)\n    ).toString(16);\n    styleIndex[\"#\" + attr(style, \"id\")] = hash;\n    styleByHash[hash] = style;\n  }\n  for (const styleMap of Array.from(styleMaps)) {\n    styleIndex[\"#\" + attr(styleMap, \"id\")] = okhash(\n      xml2string !== void 0 ? xml2string(styleMap) : xml2str(styleMap)\n    ).toString(16);\n    const pairs = get(styleMap, \"Pair\");\n    const pairsMap = {};\n    for (const pair of Array.from(pairs)) {\n      pairsMap[(_a = nodeVal(get1(pair, \"key\"))) != null ? _a : \"\"] = nodeVal(\n        get1(pair, \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + attr(styleMap, \"id\")] = pairsMap;\n  }\n  for (const placemark of Array.from(placemarks)) {\n    gj.features = gj.features.concat(\n      getPlacemark(placemark, styleIndex, styleByHash, styleMapIndex)\n    );\n  }\n  return gj;\n}\nfunction kmlColor(v) {\n  if (v === null)\n    return [\"#000000\", 1];\n  let color = \"\";\n  let opacity = 1;\n  if (v.substring(0, 1) === \"#\")\n    v = v.substring(1);\n  if (v.length === 6 || v.length === 3)\n    color = v;\n  if (v.length === 8) {\n    opacity = parseInt(v.substring(0, 2), 16) / 255;\n    color = \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return [color != null ? color : \"#000000\", opacity != null ? opacity : 1];\n}\nfunction gxCoord(v) {\n  return numarray(v.split(\" \"));\n}\nfunction gxCoords(root) {\n  var _a;\n  let elems = get(root, \"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0)\n    elems = get(root, \"gx:coord\");\n  for (const elem of Array.from(elems)) {\n    coords.push(gxCoord((_a = nodeVal(elem)) != null ? _a : \"\"));\n  }\n  const timeElems = get(root, \"when\");\n  for (const timeElem of Array.from(timeElems))\n    times.push(nodeVal(timeElem));\n  return {\n    coords,\n    times\n  };\n}\nfunction getGeometry(root) {\n  var _a, _b, _c;\n  const geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let geomNode, geomNodes, i, j, k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\") !== null) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = get(root, geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1((_a = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _a : \"\")\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord((_b = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _b : \"\")\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = get(geomNode, \"LinearRing\");\n          const coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord((_c = nodeVal(get1(rings[k], \"coordinates\"))) != null ? _c : \"\"));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords\n          });\n          if (track.times.length)\n            coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return { geoms, coordTimes };\n}\nfunction getPlacemark(root, styleIndex, styleByHash, styleMapIndex) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  const geomsAndTimes = getGeometry(root);\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  const visibility = get1(root, \"visibility\");\n  let i;\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  if (!geomsAndTimes.geoms.length)\n    return [];\n  if (name)\n    properties.name = name;\n  if (address)\n    properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\")\n      styleUrl = \"#\" + styleUrl;\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[(_a = styleMapIndex[styleUrl].normal) != null ? _a : \"\"];\n    }\n    const style = styleByHash[(_b = properties.styleHash) != null ? _b : \"\"];\n    if (style) {\n      if (!lineStyle)\n        lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle)\n        polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href)\n            properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description)\n    properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    if (begin && end)\n      properties.timespan = { begin, end };\n  }\n  if (timeStamp !== null) {\n    properties.timestamp = (_c = nodeVal(get1(timeStamp, \"when\"))) != null ? _c : (/* @__PURE__ */ new Date()).toISOString();\n  }\n  if (lineStyle !== null) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\")));\n    const color = linestyles[0];\n    const opacity = linestyles[1];\n    const width = parseFloat((_d = nodeVal(get1(lineStyle, \"width\"))) != null ? _d : \"\");\n    if (color)\n      properties.stroke = color;\n    if (!isNaN(opacity))\n      properties[\"stroke-opacity\"] = opacity;\n    if (!isNaN(width))\n      properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor)\n      properties.fill = pcolor;\n    if (!isNaN(popacity))\n      properties[\"fill-opacity\"] = popacity;\n    if (fill)\n      properties[\"fill-opacity\"] = fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] = outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = get(extendedData, \"Data\"), simpleDatas = get(extendedData, \"SimpleData\");\n    for (i = 0; i < datas.length; i++) {\n      properties[(_e = datas[i].getAttribute(\"name\")) != null ? _e : \"\"] = (_f = nodeVal(get1(datas[i], \"value\"))) != null ? _f : \"\";\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[(_g = simpleDatas[i].getAttribute(\"name\")) != null ? _g : \"\"] = (_h = nodeVal(simpleDatas[i])) != null ? _h : \"\";\n    }\n  }\n  if (visibility !== null) {\n    properties.visibility = (_i = nodeVal(visibility)) != null ? _i : \"\";\n  }\n  if (geomsAndTimes.coordTimes.length !== 0) {\n    properties.coordTimes = geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry: geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: geomsAndTimes.geoms\n    },\n    properties\n  };\n  if (attr(root, \"id\"))\n    feature.id = (_j = attr(root, \"id\")) != null ? _j : void 0;\n  return [feature];\n}\nfunction getPoints(node, pointname) {\n  const pts = get(node, pointname);\n  const line = [];\n  const times = [];\n  let heartRates = [];\n  const ptsLength = pts.length;\n  if (ptsLength < 2)\n    return;\n  for (let i = 0; i < ptsLength; i++) {\n    const cPair = coordPair(pts[i]);\n    line.push(cPair.coordinates);\n    if (cPair.time)\n      times.push(cPair.time);\n    if (cPair.heartRate || heartRates.length) {\n      if (heartRates.length === 0)\n        heartRates = new Array(i).fill(null);\n      heartRates.push(cPair.heartRate);\n    }\n  }\n  return {\n    line,\n    times,\n    heartRates\n  };\n}\nfunction getTrack(node) {\n  const segments = get(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line !== void 0) {\n      if (line.line)\n        track.push(line.line);\n      if (line.times && line.times.length)\n        times.push(line.times);\n      if (heartRates.length || line.heartRates && line.heartRates.length) {\n        if (!heartRates.length) {\n          for (let s = 0; s < i; s++) {\n            heartRates.push(new Array(track[s].length).fill(null));\n          }\n        }\n        if (line.heartRates && line.heartRates.length) {\n          heartRates.push(line.heartRates);\n        } else {\n          heartRates.push(new Array(line.line.length).fill(null));\n        }\n      }\n    }\n  }\n  if (track.length === 0)\n    return;\n  const properties = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  if (times.length !== 0)\n    properties.coordTimes = track.length === 1 ? times[0] : times;\n  if (heartRates.length !== 0) {\n    properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n  }\n  if (track.length === 1) {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"LineString\",\n        coordinates: track[0]\n      }\n    };\n  } else {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: track\n      }\n    };\n  }\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (line === void 0)\n    return;\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line\n    }\n  };\n}\nfunction getPoint(node) {\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getMulti(node, [\"sym\"]));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates\n    }\n  };\n}\nfunction getLineStyle(extensions) {\n  var _a, _b;\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\"));\n      const opacity = parseFloat((_a = nodeVal(get1(lineStyle, \"opacity\"))) != null ? _a : \"0\");\n      const width = parseFloat((_b = nodeVal(get1(lineStyle, \"width\"))) != null ? _b : \"0\");\n      if (color)\n        style.stroke = color;\n      if (!isNaN(opacity))\n        style[\"stroke-opacity\"] = opacity;\n      if (!isNaN(width))\n        style[\"stroke-width\"] = width * 96 / 25.4;\n    }\n  }\n  return style;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\"\n  ]);\n  const links = get(node, \"link\");\n  if (links.length !== 0) {\n    prop.links = [];\n    for (const l of Array.from(links)) {\n      const link = __spreadValues$1({\n        href: attr(l, \"href\")\n      }, getMulti(l, [\"text\", \"type\"]));\n      prop.links.push(link);\n    }\n  }\n  return prop;\n}\nfunction okhash(x) {\n  let h = 0;\n  if (!x || !x.length)\n    return h;\n  for (let i = 0; i < x.length; i++) {\n    h = (h << 5) - h + x.charCodeAt(i) | 0;\n  }\n  return h;\n}\nfunction get(x, y) {\n  return x.getElementsByTagName(y);\n}\nfunction attr(x, y) {\n  return x.getAttribute(y);\n}\nfunction attrf(x, y) {\n  var _a;\n  return parseFloat((_a = attr(x, y)) != null ? _a : \"0\");\n}\nfunction get1(x, y) {\n  const n = get(x, y);\n  return n.length ? n[0] : null;\n}\nfunction norm(el) {\n  if (el.normalize)\n    el.normalize();\n  return el;\n}\nfunction numarray(x) {\n  return x.map(parseFloat).map((n) => isNaN(n) ? null : n);\n}\nfunction nodeVal(x) {\n  if (x)\n    norm(x);\n  return x && x.textContent;\n}\nfunction getMulti(x, ys) {\n  var _a;\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n)\n      o[ys[k]] = (_a = nodeVal(n)) != null ? _a : \"\";\n  }\n  return o;\n}\nfunction coord1(v) {\n  return numarray(v.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction coord(v) {\n  const coords = v.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/);\n  const out = [];\n  for (const coord2 of coords)\n    out.push(coord1(coord2));\n  return out;\n}\nfunction coordPair(x) {\n  var _a, _b;\n  const ll = [attrf(x, \"lon\"), attrf(x, \"lat\")];\n  const ele = get1(x, \"ele\");\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat((_a = nodeVal(ele)) != null ? _a : \"0\");\n    if (!isNaN(e))\n      ll.push(e);\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate !== null ? parseFloat((_b = nodeVal(heartRate)) != null ? _b : \"0\") : null\n  };\n}\nfunction gpxOrKml(doc) {\n  try {\n    if (typeof doc === \"string\")\n      doc = str2xml(doc);\n  } catch (e) {\n    return null;\n  }\n  try {\n    const result = gpx(doc);\n    return result;\n  } catch (e) {\n  }\n  try {\n    const result = kml(doc);\n    return result;\n  } catch (e) {\n  }\n  return null;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction componentToHex(c) {\n  const hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\nfunction rgbToHex(rgb) {\n  return \"#\" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]) + (rgb.length === 4 ? componentToHex(rgb[3]) : \"\");\n}\nclass ColorRamp extends Array {\n  constructor(options = {}) {\n    super();\n    __publicField(this, \"min\", 0);\n    __publicField(this, \"max\", 1);\n    if (\"min\" in options) {\n      this.min = options.min;\n    }\n    if (\"max\" in options) {\n      this.max = options.max;\n    }\n    if (\"stops\" in options) {\n      this.setStops(options.stops, { clone: false });\n    }\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(cr) {\n    return new ColorRamp({\n      stops: cr.map((cs) => ({\n        value: cs[0],\n        color: cs[1]\n      }))\n    });\n  }\n  setStops(stops, options = { clone: true }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    colorRamp.length = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < stops.length; i += 1) {\n      min = Math.min(min, stops[i].value);\n      max = Math.max(max, stops[i].value);\n      colorRamp.push({\n        value: stops[i].value,\n        color: stops[i].color.slice()\n        // we want to make sure we do a deep copy and not a reference\n      });\n    }\n    colorRamp.sort(\n      (a, b) => a.value < b.value ? -1 : 1\n    );\n    this.min = min;\n    this.max = max;\n    return colorRamp;\n  }\n  scale(min, max, options = { clone: true }) {\n    const clone = options.clone;\n    const currentMin = this[0].value;\n    const currentMax = this.at(-1).value;\n    const currentSpan = currentMax - currentMin;\n    const newSpan = max - min;\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      const currentValue = this[i].value;\n      const normalizedValue = (currentValue - currentMin) / currentSpan;\n      const newValue = normalizedValue * newSpan + min;\n      if (clone) {\n        stops.push({\n          value: newValue,\n          color: this[i].color.slice()\n        });\n      } else {\n        this[i].value = newValue;\n      }\n    }\n    return clone ? new ColorRamp({ stops }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(pos) {\n    if (pos < 0) {\n      return this[this.length + pos];\n    } else {\n      return this[pos];\n    }\n  }\n  clone() {\n    return new ColorRamp({ stops: this.getRawColorStops() });\n  }\n  getRawColorStops() {\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      stops.push({ value: this[i].value, color: this[i].color });\n    }\n    return stops;\n  }\n  reverse(options = { clone: true }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    for (let i = 0; i < ~~(colorRamp.length / 2); i += 1) {\n      const c = colorRamp[i].color;\n      colorRamp[i].color = colorRamp.at(-(i + 1)).color;\n      colorRamp.at(-(i + 1)).color = c;\n    }\n    return colorRamp;\n  }\n  getBounds() {\n    return { min: this.min, max: this.max };\n  }\n  getColor(value, options = { smooth: true }) {\n    if (value <= this[0].value) {\n      return this[0].color;\n    }\n    if (value >= this.at(-1).value) {\n      return this.at(-1).color;\n    }\n    for (let i = 0; i < this.length - 1; i += 1) {\n      if (value > this[i + 1].value) {\n        continue;\n      }\n      const colorBefore = this[i].color;\n      if (!options.smooth) {\n        return colorBefore.slice();\n      }\n      const valueBefore = this[i].value;\n      const valueAfter = this[i + 1].value;\n      const colorAfter = this[i + 1].color;\n      const beforeRatio = (valueAfter - value) / (valueAfter - valueBefore);\n      return colorBefore.map(\n        (chan, i2) => Math.round(chan * beforeRatio + colorAfter[i2] * (1 - beforeRatio))\n      );\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(value, options = {\n    smooth: true,\n    withAlpha: false\n  }) {\n    return rgbToHex(this.getColor(value, options));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(value, options = { smooth: true }) {\n    const bounds = this.getBounds();\n    return this.getColor(\n      bounds.min + value * (bounds.max - bounds.min),\n      options\n    );\n  }\n  getCanvasStrip(options = {\n    horizontal: true,\n    size: 512,\n    smooth: true\n  }) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = options.horizontal ? options.size : 1;\n    canvas.height = options.horizontal ? 1 : options.size;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx)\n      throw new Error(\"Canvs context is missing\");\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n    const size = options.size;\n    const startValue = this[0].value;\n    const endValue = this.at(-1).value;\n    const valueSpan = endValue - startValue;\n    const valueStep = valueSpan / size;\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getColor(startValue + i * valueStep, {\n        smooth: options.smooth\n      });\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color.length > 3 ? color[3] : 255;\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(method, samples = 15) {\n    const inputBounds = this.getBounds();\n    const inputNormalized = this.scale(0, 1);\n    const step = 1 / (samples - 1);\n    let stops;\n    if (method === \"ease-in-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(2, -10 * x);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(2, 10 * x - 10);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else {\n      throw new Error(\"Invalid ressampling method.\");\n    }\n    const outputNormalized = new ColorRamp({ stops });\n    const output = outputNormalized.scale(inputBounds.min, inputBounds.max);\n    return output;\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const stops = this.getRawColorStops();\n    stops.unshift({\n      value: stops[0].value,\n      color: stops[0].color.slice()\n    });\n    stops[1].value += 1e-3;\n    stops.forEach((s) => {\n      if (s.color.length === 3) {\n        s.color.push(255);\n      }\n    });\n    stops[0].color[3] = 0;\n    return new ColorRamp({ stops });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst ColorRampCollection = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] }\n    ]\n  }),\n  GRAY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] }\n    ]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] }\n    ]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] }\n    ]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] }\n    ]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] }\n    ]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] }\n    ]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new ColorRamp({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] }\n    ]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] }\n    ]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new ColorRamp({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new ColorRamp({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] }\n    ]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] }\n    ]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] }\n    ]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] }\n    ]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] }\n    ]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] }\n    ]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] }\n    ]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] }\n    ]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new ColorRamp({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] }\n    ]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new ColorRamp({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] }\n    ]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new ColorRamp({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] }\n    ]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] }\n    ]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new ColorRamp({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] }\n    ]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new ColorRamp({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] }\n    ]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new ColorRamp({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] }\n    ]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] }\n    ]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new ColorRamp({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] }\n    ]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] }\n    ]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] }\n    ]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] }\n    ]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] }\n    ]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] }\n    ]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new ColorRamp({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] }\n    ]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new ColorRamp({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] }\n    ]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new ColorRamp({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] }\n    ]\n  })\n};\n\nconst colorPalettes = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]\n];\nfunction getRandomColor() {\n  return colorPalettes[~~(Math.random() * colorPalettes.length)][~~(Math.random() * 4)];\n}\nfunction generateRandomSourceName() {\n  return `maptiler_source_${generateRandomString()}`;\n}\nfunction generateRandomLayerName() {\n  return `maptiler_layer_${generateRandomString()}`;\n}\nfunction lerpZoomNumberValues(znv, z) {\n  if (z <= znv[0].zoom) {\n    return znv[0].value;\n  }\n  if (z >= znv[znv.length - 1].zoom) {\n    return znv[znv.length - 1].value;\n  }\n  for (let i = 0; i < znv.length - 1; i += 1) {\n    if (z >= znv[i].zoom && z < znv[i + 1].zoom) {\n      const zoomRange = znv[i + 1].zoom - znv[i].zoom;\n      const normalizedDistanceFromLowerBound = (z - znv[i].zoom) / zoomRange;\n      return normalizedDistanceFromLowerBound * znv[i + 1].value + (1 - normalizedDistanceFromLowerBound) * znv[i].value;\n    }\n  }\n  return 0;\n}\nfunction paintColorOptionsToPaintSpec(color) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...color.map((el) => [el.zoom, el.value]).flat()\n  ];\n}\nfunction rampedOptionsToLayerPaintSpec(ramp) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...ramp.map((el) => [el.zoom, el.value]).flat()\n  ];\n}\nfunction computeRampedOutlineWidth(lineWidth, outlineWidth) {\n  if (typeof outlineWidth === \"number\" && typeof lineWidth === \"number\") {\n    return 2 * outlineWidth + lineWidth;\n  } else if (typeof outlineWidth === \"number\" && Array.isArray(lineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...lineWidth.map((el) => [el.zoom, 2 * outlineWidth + el.value]).flat()\n    ];\n  } else if (typeof lineWidth === \"number\" && Array.isArray(outlineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...outlineWidth.map((el) => [el.zoom, 2 * el.value + lineWidth]).flat()\n    ];\n  }\n  if (Array.isArray(lineWidth) && Array.isArray(outlineWidth)) {\n    const allStops = Array.from(\n      /* @__PURE__ */ new Set([\n        ...lineWidth.map((el) => el.zoom),\n        ...outlineWidth.map((el) => el.zoom)\n      ])\n    ).sort((a, b) => a < b ? -1 : 1);\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...allStops.map((z) => [\n        z,\n        2 * lerpZoomNumberValues(outlineWidth, z) + lerpZoomNumberValues(lineWidth, z)\n      ]).flat()\n    ];\n  }\n  return 0;\n}\nfunction rampedPropertyValueWeight(ramp, property) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...ramp.map((el) => [el.propertyValue, el.value]).flat()\n  ];\n}\nfunction dashArrayMaker(pattern) {\n  const startTrimmedPattern = pattern.trimStart();\n  const fixedPattern = `${startTrimmedPattern}${\" \".repeat(\n    pattern.length - startTrimmedPattern.length\n  )}`;\n  const patternArr = Array.from(fixedPattern);\n  const isOnlyDashesAndSpaces = patternArr.every((c) => c === \" \" || c === \"_\");\n  if (!isOnlyDashesAndSpaces) {\n    throw new Error(\n      \"A dash pattern must be composed only of whitespace and underscore characters.\"\n    );\n  }\n  const hasBothDashesAndWhitespaces = patternArr.some((c) => c === \"_\") && patternArr.some((c) => c === \" \");\n  if (!hasBothDashesAndWhitespaces) {\n    throw new Error(\n      \"A dash pattern must contain at least one underscore and one whitespace character\"\n    );\n  }\n  const dashArray = [1];\n  for (let i = 1; i < patternArr.length; i += 1) {\n    const previous = patternArr[i - 1];\n    const current = patternArr[i];\n    if (previous === current) {\n      dashArray[dashArray.length - 1] += 1;\n    } else {\n      dashArray.push(1);\n    }\n  }\n  return dashArray;\n}\nfunction colorDrivenByProperty(style, property) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...style.map((el) => [el.value, el.color]).flat()\n  ];\n}\nfunction radiusDrivenByProperty(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat()\n    ];\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.025]).flat()\n    ],\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.05]).flat()\n    ],\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.1]).flat()\n    ],\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.25]).flat()\n    ],\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat()\n    ]\n  ];\n}\nfunction radiusDrivenByPropertyHeatmap(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat()\n    ];\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.025]).flat()\n    ],\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.05]).flat()\n    ],\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.1]).flat()\n    ],\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.25]).flat()\n    ],\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat()\n    ]\n  ];\n}\nfunction opacityDrivenByProperty(colorramp, property) {\n  if (colorramp.every((el) => el.color[3] === colorramp[0].color[3])) {\n    return colorramp[0].color[3] ? colorramp[0].color[3] / 255 : 1;\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...colorramp.getRawColorStops().map((el) => {\n      const value = el.value;\n      const color = el.color;\n      return [value, color.length === 4 ? color[3] / 255 : 1];\n    }).flat()\n  ];\n}\nfunction heatmapIntensityFromColorRamp(colorRamp, steps = 10) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: steps + 1 }, (_, i) => {\n      const unitStep = i / steps;\n      return [unitStep, colorRamp.getColorHex(unitStep)];\n    }).flat()\n  ];\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction addPolyline(_0, _1) {\n  return __async(this, arguments, function* (map, options, fetchOptions = {}) {\n    var _a, _b, _c;\n    if (!options.sourceId && !options.data) {\n      throw new Error(\n        \"Creating a polyline layer requires an existing .sourceId or a valid .data property\"\n      );\n    }\n    let data = options.data;\n    if (typeof data === \"string\") {\n      if (isUUID(data)) {\n        data = `https://api.maptiler.com/data/${options.data}/features.json?key=${config.apiKey}`;\n      } else if (((_a = data.split(\".\").pop()) == null ? void 0 : _a.toLowerCase().trim()) === \"gpx\") {\n        const res = yield fetch(data, fetchOptions);\n        const gpxStr = yield res.text();\n        data = gpx(gpxStr);\n      } else if (((_b = data.split(\".\").pop()) == null ? void 0 : _b.toLowerCase().trim()) === \"kml\") {\n        const res = yield fetch(data, fetchOptions);\n        const kmlStr = yield res.text();\n        data = kml(kmlStr);\n      } else {\n        const tmpData = (_c = jsonParseNoThrow(\n          data\n        )) != null ? _c : gpxOrKml(data);\n        if (tmpData)\n          data = tmpData;\n      }\n      if (!data) {\n        throw new Error(\n          \"Polyline data was provided as string but is incompatible with valid formats.\"\n        );\n      }\n    }\n    return addGeoJSONPolyline(map, __spreadProps(__spreadValues({}, options), {\n      data\n    }));\n  });\n}\nfunction addGeoJSONPolyline(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polylineLayerId: layerId,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: options.data\n    });\n  }\n  const lineWidth = (_c = options.lineWidth) != null ? _c : 3;\n  const lineColor = (_d = options.lineColor) != null ? _d : getRandomColor();\n  const lineOpacity = (_e = options.lineOpacity) != null ? _e : 1;\n  const lineBlur = (_f = options.lineBlur) != null ? _f : 0;\n  const lineGapWidth = (_g = options.lineGapWidth) != null ? _g : 0;\n  let lineDashArray = (_h = options.lineDashArray) != null ? _h : null;\n  const outlineWidth = (_i = options.outlineWidth) != null ? _i : 1;\n  const outlineColor = (_j = options.outlineColor) != null ? _j : \"#FFFFFF\";\n  const outlineOpacity = (_k = options.outlineOpacity) != null ? _k : 1;\n  const outlineBlur = (_l = options.outlineBlur) != null ? _l : 0;\n  if (typeof lineDashArray === \"string\") {\n    lineDashArray = dashArrayMaker(lineDashArray);\n  }\n  if (options.outline === true) {\n    const outlineLayerId = `${layerId}_outline`;\n    returnedInfo.polylineOutlineLayerId = outlineLayerId;\n    map.addLayer(\n      {\n        id: outlineLayerId,\n        type: \"line\",\n        source: sourceId,\n        layout: {\n          \"line-join\": (_m = options.lineJoin) != null ? _m : \"round\",\n          \"line-cap\": (_n = options.lineCap) != null ? _n : \"round\"\n        },\n        minzoom: (_o = options.minzoom) != null ? _o : 0,\n        maxzoom: (_p = options.maxzoom) != null ? _p : 23,\n        paint: {\n          \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          \"line-width\": computeRampedOutlineWidth(lineWidth, outlineWidth),\n          \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur)\n        }\n      },\n      options.beforeId\n    );\n  }\n  map.addLayer(\n    {\n      id: layerId,\n      type: \"line\",\n      source: sourceId,\n      layout: {\n        \"line-join\": (_q = options.lineJoin) != null ? _q : \"round\",\n        \"line-cap\": (_r = options.lineCap) != null ? _r : \"round\"\n      },\n      minzoom: (_s = options.minzoom) != null ? _s : 0,\n      maxzoom: (_t = options.maxzoom) != null ? _t : 23,\n      paint: __spreadValues({\n        \"line-opacity\": typeof lineOpacity === \"number\" ? lineOpacity : rampedOptionsToLayerPaintSpec(lineOpacity),\n        \"line-color\": typeof lineColor === \"string\" ? lineColor : paintColorOptionsToPaintSpec(lineColor),\n        \"line-width\": typeof lineWidth === \"number\" ? lineWidth : rampedOptionsToLayerPaintSpec(lineWidth),\n        \"line-blur\": typeof lineBlur === \"number\" ? lineBlur : rampedOptionsToLayerPaintSpec(lineBlur),\n        \"line-gap-width\": typeof lineGapWidth === \"number\" ? lineGapWidth : rampedOptionsToLayerPaintSpec(lineGapWidth)\n      }, lineDashArray && { \"line-dasharray\": lineDashArray })\n    },\n    options.beforeId\n  );\n  return returnedInfo;\n}\nfunction addPolygon(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polygonLayerId: layerId,\n    polygonOutlineLayerId: options.outline ? `${layerId}_outline` : \"\",\n    polygonSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  let outlineDashArray = (_c = options.outlineDashArray) != null ? _c : null;\n  const outlineWidth = (_d = options.outlineWidth) != null ? _d : 1;\n  const outlineColor = (_e = options.outlineColor) != null ? _e : \"#FFFFFF\";\n  const outlineOpacity = (_f = options.outlineOpacity) != null ? _f : 1;\n  const outlineBlur = (_g = options.outlineBlur) != null ? _g : 0;\n  const fillColor = (_h = options.fillColor) != null ? _h : getRandomColor();\n  const fillOpacity = (_i = options.fillOpacity) != null ? _i : 1;\n  const outlinePosition = (_j = options.outlinePosition) != null ? _j : \"center\";\n  const pattern = (_k = options.pattern) != null ? _k : null;\n  if (typeof outlineDashArray === \"string\") {\n    outlineDashArray = dashArrayMaker(outlineDashArray);\n  }\n  const addLayers = (patternImageId = null) => {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    map.addLayer(\n      {\n        id: layerId,\n        type: \"fill\",\n        source: sourceId,\n        minzoom: (_a2 = options.minzoom) != null ? _a2 : 0,\n        maxzoom: (_b2 = options.maxzoom) != null ? _b2 : 23,\n        paint: __spreadValues({\n          \"fill-color\": typeof fillColor === \"string\" ? fillColor : paintColorOptionsToPaintSpec(fillColor),\n          \"fill-opacity\": typeof fillOpacity === \"number\" ? fillOpacity : rampedOptionsToLayerPaintSpec(fillOpacity)\n        }, patternImageId && { \"fill-pattern\": patternImageId })\n      },\n      options.beforeId\n    );\n    if (options.outline === true) {\n      let computedOutlineOffset;\n      if (outlinePosition === \"inside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = 0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map(({ zoom, value }) => ({\n              zoom,\n              value: 0.5 * value\n            }))\n          );\n        }\n      } else if (outlinePosition === \"outside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = -0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map((el) => ({\n              zoom: el.zoom,\n              value: -0.5 * el.value\n            }))\n          );\n        }\n      } else {\n        computedOutlineOffset = 0;\n      }\n      map.addLayer(\n        {\n          id: returnedInfo.polygonOutlineLayerId,\n          type: \"line\",\n          source: sourceId,\n          layout: {\n            \"line-join\": (_c2 = options.outlineJoin) != null ? _c2 : \"round\",\n            \"line-cap\": (_d2 = options.outlineCap) != null ? _d2 : \"butt\"\n          },\n          minzoom: (_e2 = options.minzoom) != null ? _e2 : 0,\n          maxzoom: (_f2 = options.maxzoom) != null ? _f2 : 23,\n          paint: __spreadValues({\n            \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n            \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n            \"line-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n            \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur),\n            \"line-offset\": computedOutlineOffset\n          }, outlineDashArray && {\n            \"line-dasharray\": outlineDashArray\n          })\n        },\n        options.beforeId\n      );\n    }\n  };\n  if (pattern) {\n    if (map.hasImage(pattern)) {\n      addLayers(pattern);\n    } else {\n      map.loadImage(\n        pattern,\n        // (error?: Error | null, image?: HTMLImageElement | ImageBitmap | null, expiry?: ExpiryData | null)\n        (error, image) => {\n          if (error) {\n            console.error(\"Could not load the pattern image.\", error.message);\n            return addLayers();\n          }\n          if (!image) {\n            console.error(\n              `An image cannot be created from the pattern URL ${pattern}.`\n            );\n            return addLayers();\n          }\n          map.addImage(pattern, image);\n          addLayers(pattern);\n        }\n      );\n    }\n  } else {\n    addLayers();\n  }\n  return returnedInfo;\n}\nfunction addPoint(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const minPointRadius = (_a = options.minPointRadius) != null ? _a : 10;\n  const maxPointRadius = (_b = options.maxPointRadius) != null ? _b : 50;\n  const cluster = (_c = options.cluster) != null ? _c : false;\n  const nbDefaultDataDrivenStyleSteps = 20;\n  const colorramp = Array.isArray(options.pointColor) ? options.pointColor : ColorRampCollection.TURBO.scale(\n    10,\n    options.cluster ? 1e4 : 1e3\n  ).resample(\"ease-out-square\");\n  const colorRampBounds = colorramp.getBounds();\n  const sourceId = (_d = options.sourceId) != null ? _d : generateRandomSourceName();\n  const layerId = (_e = options.layerId) != null ? _e : generateRandomLayerName();\n  const showLabel = (_f = options.showLabel) != null ? _f : cluster;\n  const alignOnViewport = (_g = options.alignOnViewport) != null ? _g : true;\n  const outline = (_h = options.outline) != null ? _h : false;\n  const outlineOpacity = (_i = options.outlineOpacity) != null ? _i : 1;\n  const outlineWidth = (_j = options.outlineWidth) != null ? _j : 1;\n  const outlineColor = (_k = options.outlineColor) != null ? _k : \"#FFFFFF\";\n  let pointOpacity;\n  const zoomCompensation = (_l = options.zoomCompensation) != null ? _l : true;\n  const minzoom = (_m = options.minzoom) != null ? _m : 0;\n  const maxzoom = (_n = options.maxzoom) != null ? _n : 23;\n  if (typeof options.pointOpacity === \"number\") {\n    pointOpacity = options.pointOpacity;\n  } else if (Array.isArray(options.pointOpacity)) {\n    pointOpacity = rampedOptionsToLayerPaintSpec(options.pointOpacity);\n  } else if (options.cluster) {\n    pointOpacity = opacityDrivenByProperty(colorramp, \"point_count\");\n  } else if (options.property) {\n    pointOpacity = opacityDrivenByProperty(colorramp, options.property);\n  } else {\n    pointOpacity = rampedOptionsToLayerPaintSpec([\n      { zoom: minzoom, value: 0 },\n      { zoom: minzoom + 0.25, value: 1 },\n      { zoom: maxzoom - 0.25, value: 1 },\n      { zoom: maxzoom, value: 0 }\n    ]);\n  }\n  const returnedInfo = {\n    pointLayerId: layerId,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data,\n      cluster\n    });\n  }\n  if (cluster) {\n    returnedInfo.clusterLayerId = `${layerId}_cluster`;\n    const clusterStyle = Array.from(\n      { length: nbDefaultDataDrivenStyleSteps },\n      (_, i) => {\n        const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n        return {\n          value,\n          pointRadius: minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n          color: colorramp.getColorHex(value)\n        };\n      }\n    );\n    map.addLayer(\n      {\n        id: returnedInfo.clusterLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"has\", \"point_count\"],\n        paint: __spreadValues({\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : radiusDrivenByProperty(clusterStyle, \"point_count\", false),\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": pointOpacity\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: __spreadValues({\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(colorramp.getBounds().min),\n          \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : clusterStyle[0].pointRadius * 0.75,\n          \"circle-opacity\": pointOpacity\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  } else {\n    let pointColor = typeof options.pointColor === \"string\" ? options.pointColor : Array.isArray(options.pointColor) ? options.pointColor.getColorHex(options.pointColor.getBounds().min) : getRandomColor();\n    let pointRadius = typeof options.pointRadius === \"number\" ? zoomCompensation ? rampedOptionsToLayerPaintSpec([\n      { zoom: 0, value: options.pointRadius * 0.025 },\n      { zoom: 2, value: options.pointRadius * 0.05 },\n      { zoom: 4, value: options.pointRadius * 0.1 },\n      { zoom: 8, value: options.pointRadius * 0.25 },\n      { zoom: 16, value: options.pointRadius * 1 }\n    ]) : options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : zoomCompensation ? rampedOptionsToLayerPaintSpec([\n      { zoom: 0, value: minPointRadius * 0.05 },\n      { zoom: 2, value: minPointRadius * 0.1 },\n      { zoom: 4, value: minPointRadius * 0.2 },\n      { zoom: 8, value: minPointRadius * 0.5 },\n      { zoom: 16, value: minPointRadius * 1 }\n    ]) : minPointRadius;\n    if (options.property && Array.isArray(options.pointColor)) {\n      const dataDrivenStyle = Array.from(\n        { length: nbDefaultDataDrivenStyleSteps },\n        (_, i) => {\n          const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n          return {\n            value,\n            pointRadius: typeof options.pointRadius === \"number\" ? options.pointRadius : minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n            color: typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(value)\n          };\n        }\n      );\n      pointColor = colorDrivenByProperty(dataDrivenStyle, options.property);\n      pointRadius = radiusDrivenByProperty(\n        dataDrivenStyle,\n        options.property,\n        zoomCompensation\n      );\n    }\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": options.property ? [\"/\", 1, [\"get\", options.property]] : 0\n        },\n        paint: __spreadValues({\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": pointColor,\n          \"circle-opacity\": pointOpacity,\n          \"circle-radius\": pointRadius\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  }\n  if (showLabel !== false && (options.cluster || options.property)) {\n    returnedInfo.labelLayerId = `${layerId}_label`;\n    const labelColor = (_o = options.labelColor) != null ? _o : \"#fff\";\n    const labelSize = (_p = options.labelSize) != null ? _p : 12;\n    map.addLayer(\n      {\n        id: returnedInfo.labelLayerId,\n        type: \"symbol\",\n        source: sourceId,\n        filter: [\n          \"has\",\n          options.cluster ? \"point_count\" : options.property\n        ],\n        layout: {\n          \"text-field\": options.cluster ? \"{point_count_abbreviated}\" : `{${options.property}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": labelSize,\n          \"text-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\n            \"/\",\n            1,\n            [\n              \"get\",\n              options.cluster ? \"point_count\" : options.property\n            ]\n          ]\n          // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": labelColor,\n          \"text-opacity\": pointOpacity\n        },\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  }\n  return returnedInfo;\n}\nfunction addHeatmap(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const minzoom = (_c = options.minzoom) != null ? _c : 0;\n  const maxzoom = (_d = options.maxzoom) != null ? _d : 23;\n  const zoomCompensation = (_e = options.zoomCompensation) != null ? _e : true;\n  const opacity = (_f = options.opacity) != null ? _f : [\n    { zoom: minzoom, value: 0 },\n    { zoom: minzoom + 0.25, value: 1 },\n    { zoom: maxzoom - 0.25, value: 1 },\n    { zoom: maxzoom, value: 0 }\n  ];\n  let colorRamp = Array.isArray(options.colorRamp) ? options.colorRamp : ColorRampCollection.TURBO.transparentStart();\n  const crBounds = colorRamp.getBounds();\n  if (crBounds.min !== 0 || crBounds.max !== 1) {\n    colorRamp = colorRamp.scale(0, 1);\n  }\n  if (!colorRamp.hasTransparentStart()) {\n    colorRamp = colorRamp.transparentStart();\n  }\n  const intensity = (_g = options.intensity) != null ? _g : [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 }\n  ];\n  const property = (_h = options.property) != null ? _h : null;\n  const propertyValueWeight = (_i = options.weight) != null ? _i : 1;\n  let heatmapWeight = 1;\n  if (property) {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n      if (typeof options.weight === \"number\") {\n        console.warn(\n          \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\"\n        );\n      }\n    } else if (Array.isArray(propertyValueWeight)) {\n      heatmapWeight = rampedPropertyValueWeight(propertyValueWeight, property);\n    } else {\n      console.warn(\n        \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\"\n      );\n    }\n  } else {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n    } else if (Array.isArray(propertyValueWeight)) {\n      console.warn(\n        \"The options `.propertyValueWeights` can only be used when `.property` is provided.\"\n      );\n    }\n  }\n  const defaultRadiusZoomRamping = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 }\n  ];\n  const radius = (_j = options.radius) != null ? _j : zoomCompensation ? defaultRadiusZoomRamping : 10;\n  let radiusHeatmap = 1;\n  if (typeof radius === \"number\") {\n    radiusHeatmap = radius;\n  } else if (Array.isArray(radius) && \"zoom\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(radius);\n  } else if (property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = radiusDrivenByPropertyHeatmap(\n      radius,\n      property,\n      zoomCompensation\n    );\n  } else if (!property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping\n    );\n    console.warn(\n      \"The option `.radius` can only be property-driven if the option `.property` is provided.\"\n    );\n  } else {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping\n    );\n  }\n  const returnedInfo = {\n    heatmapLayerId: layerId,\n    heatmapSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  map.addLayer({\n    id: layerId,\n    type: \"heatmap\",\n    source: sourceId,\n    minzoom,\n    maxzoom,\n    paint: {\n      \"heatmap-weight\": heatmapWeight,\n      \"heatmap-intensity\": typeof intensity === \"number\" ? intensity : rampedOptionsToLayerPaintSpec(\n        intensity\n      ),\n      \"heatmap-color\": heatmapIntensityFromColorRamp(colorRamp),\n      \"heatmap-radius\": radiusHeatmap,\n      \"heatmap-opacity\": typeof opacity === \"number\" ? opacity : rampedOptionsToLayerPaintSpec(\n        opacity\n      )\n    }\n  });\n  return returnedInfo;\n}\n\nconst helpers = {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap\n};\n\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol\n} = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\nconst MapMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map;\nconst MarkerMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker;\nconst PopupMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup;\nconst StyleMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style;\nconst CanvasSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource;\nconst GeoJSONSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource;\nconst ImageSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource;\nconst RasterTileSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource;\nconst VideoSourceMLGL = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl;\nmaplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl;\n\n\n//# sourceMappingURL=maptiler-sdk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ2xCO0FBQ087QUFDRDtBQUNtSDtBQUNtTjtBQUM5VTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBLDJCQUEyQixxREFBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDBEQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlEQUFpRDtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsRUFBRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1CQUFtQixFQUFFLFNBQVM7QUFDOUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDZEQUE2RDtBQUMvSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FB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QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSyxxQkFBcUIsY0FBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSx3Q0FBbUI7QUFDdkIsZ0JBQWdCLDRDQUF1QjtBQUN2QyxtQkFBbUIsK0NBQTBCO0FBQzdDLGtCQUFrQiw4Q0FBeUI7QUFDM0Msa0JBQWtCLDhDQUF5QjtBQUMzQyx5QkFBeUIscURBQWdDO0FBQ3pELDBCQUEwQixzREFBaUM7QUFDM0Qsd0JBQXdCLG9EQUErQjtBQUN2RCw2QkFBNkIseURBQW9DO0FBQ2pFLGdDQUFnQyw0REFBdUM7QUFDdkUsNkJBQTZCLHlEQUFvQztBQUNqRSx3QkFBd0Isb0RBQStCO0FBQ3ZELDBEQUFxQztBQUNyQyx5REFBb0M7QUFDcEMsMkRBQXNDO0FBQ3RDLG9EQUErQjtBQUMvQixxREFBZ0M7QUFDaEMsMERBQXFDO0FBQ3JDLHVEQUFrQzs7QUFFdzZCO0FBQzE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZvbGNhbl9jZXN0ZWFtdXAvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5tanM/ZDMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWFwbGlicmVnbF9fZGVmYXVsdCBmcm9tICdtYXBsaWJyZS1nbCc7XG5leHBvcnQgKiBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tICdqcy1iYXNlNjQnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgY29uZmlnIGFzIGNvbmZpZyQxLCBNYXBTdHlsZSwgbWFwU3R5bGVQcmVzZXRMaXN0LCBleHBhbmRNYXBTdHlsZSwgTWFwU3R5bGVWYXJpYW50LCBSZWZlcmVuY2VNYXBTdHlsZSwgZ2VvbG9jYXRpb24gfSBmcm9tICdAbWFwdGlsZXIvY2xpZW50JztcbmV4cG9ydCB7IExhbmd1YWdlR2VvY29kaW5nLCBNYXBTdHlsZSwgTWFwU3R5bGVWYXJpYW50LCBSZWZlcmVuY2VNYXBTdHlsZSwgU2VydmljZUVycm9yLCBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXIsIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlLCBjb29yZGluYXRlcywgZGF0YSwgZWxldmF0aW9uLCBleHBhbmRNYXBTdHlsZSwgZ2VvY29kaW5nLCBnZW9sb2NhdGlvbiwgZ2V0QXV0b0xhbmd1YWdlR2VvY29kaW5nLCBnZXRCdWZmZXJUb1BpeGVsRGF0YVBhcnNlciwgZ2V0VGlsZUNhY2hlLCBtYXBTdHlsZVByZXNldExpc3QsIG1hdGgsIG1pc2MsIHN0YXRpY01hcHMsIHN0eWxlVG9TdHlsZSB9IGZyb20gJ0BtYXB0aWxlci9jbGllbnQnO1xuaW1wb3J0IHsgdjQgfSBmcm9tICd1dWlkJztcblxuY29uc3QgTGFuZ3VhZ2UgPSB7XG4gIC8qKlxuICAgKiBUaGUgdmlzaXRvciBsYW5ndWFnZSBtb2RlIGNvbmNhdGVuYXRlcyB0aGUgcHJlZmVyZWQgbGFuZ3VhZ2UgZnJvbSB0aGUgdXNlciBzZXR0aW5ncyBhbmQgdGhlIFwiZGVmYXVsdCBuYW1lXCIuXG4gICAqIE5vdGU6IFRoZSBcImRlZmF1bHQgbmFtZVwiIGlzIGVxdWl2YWxlbnQgdG8gT1NNJ3MgYHtuYW1lfWAsIHdoaWNoIGNhbiBiZSB0aGUgbW9zdCByZWNvZ25pemVkIG5hbWVzIGEgZ2xvYmFsXG4gICAqIHNjYWxlIG9yIHRoZSBsb2NhbCBuYW1lLlxuICAgKiBUaGlzIG1vZGUgaXMgaGVscGZ1bCBpbiB0aGUgY29udGV4dCB3aGVyZSBhIHVzZXIgbmVlZHMgdG8gYWNjZXNzIGJvdGggdGhlIGxvY2FsIG5hbWVzIGFuZCB0aGUgbmFtZXMgaW4gdGhlaXJcbiAgICogb3duIGxhbmd1YWdlLCBmb3IgaW5zdGFuY2Ugd2hlbiB0cmF2ZWxpbmcgYWJyb2FkLCB3aGVyZSBzaWducyBsaWtlbHkgdG8gYmUgb25seSBhdmFpbGFibGUgaW4gdGhlIGxvY2FsIGxhbmd1YWdlLlxuICAgKi9cbiAgVklTSVRPUjogXCJ2aXNpdG9yXCIsXG4gIC8qKlxuICAgKiBUaGUgdmlzaXRvciBsYW5ndWFnZSBtb2RlIGNvbmNhdGVuYXRlcyBFbmdsaXNoIGFuZCB0aGUgXCJkZWZhdWx0IG5hbWVcIi5cbiAgICogTm90ZTogVGhlIFwiZGVmYXVsdCBuYW1lXCIgaXMgZXF1aXZhbGVudCB0byBPU00ncyBge25hbWV9YCwgd2hpY2ggY2FuIGJlIHRoZSBtb3N0IHJlY29nbml6ZWQgbmFtZXMgYSBnbG9iYWxcbiAgICogc2NhbGUgb3IgdGhlIGxvY2FsIG5hbWUuXG4gICAqIFRoaXMgbW9kZSBpcyBoZWxwZnVsIGluIHRoZSBjb250ZXh0IHdoZXJlIGEgdXNlciBuZWVkcyB0byBhY2Nlc3MgYm90aCB0aGUgbG9jYWwgbmFtZXMgYW5kIHRoZSBuYW1lcyBpbiB0aGVpclxuICAgKiBvd24gbGFuZ3VhZ2UsIGZvciBpbnN0YW5jZSB3aGVuIHRyYXZlbGluZyBhYnJvYWQsIHdoZXJlIHNpZ25zIGxpa2VseSB0byBiZSBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UuXG4gICAqL1xuICBWSVNJVE9SX0VOR0xJU0g6IFwidmlzaXRvcl9lblwiLFxuICAvKipcbiAgICogTGFuZ3VhZ2UgYXMgdGhlIHN0eWxlIGlzIGRlc2lnbmVkLiBOb3QgdGhhdCB0aGlzIGlzIHRoZSBkZWZhdWx0IHN0YXRlIGFuZCBvbmVcbiAgICogdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGNoYW5nZWQgdG8gYW5vdGhlciB0aGFuIGBTVFlMRWAsIHRoZW4gaXQgY2Fubm90IGJlIHNldCBiYWNrIHRvIGBTVFlMRWAuXG4gICAqL1xuICBTVFlMRTogXCJzdHlsZVwiLFxuICAvKipcbiAgICogQVVUTyBtb2RlIHVzZXMgdGhlIGxhbmd1YWdlIG9mIHRoZSBicm93c2VyXG4gICAqL1xuICBBVVRPOiBcImF1dG9cIixcbiAgLyoqXG4gICAqIFNUWUxFIGlzIGEgY3VzdG9tIGZsYWcgdG8ga2VlcCB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIG1hcCBhcyBkZWZpbmVkIGludG8gdGhlIHN0eWxlLlxuICAgKiBJZiBTVFlMRSBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGVuIGZ1cnRoZXIgbW9kaWZpY2F0aW9uIG9mIHRoZSBsYW5ndWFnZVxuICAgKiB3aXRoIGAuc2V0TGFuZ3VhZ2UoKWAgaXMgbm90IHBvc3NpYmxlLlxuICAgKi9cbiAgU1RZTEVfTE9DSzogXCJzdHlsZV9sb2NrXCIsXG4gIC8qKlxuICAgKiBEZWZhdWx0IGZhbGxiYWNrIGxhbmd1YWdlcyB0aGF0IHVzZXMgbGF0aW4gY2hhcmF0ZXJzXG4gICAqL1xuICBMQVRJTjogXCJuYW1lOmxhdGluXCIsXG4gIC8qKlxuICAgKiBEZWZhdWx0IGZhbGxiYWNrIGxhbmd1YWdlcyB0aGF0IHVzZXMgbm9uLWxhdGluIGNoYXJhdGVyc1xuICAgKi9cbiAgTk9OX0xBVElOOiBcIm5hbWU6bm9ubGF0aW5cIixcbiAgLyoqXG4gICAqIExhYmVscyBhcmUgaW4gdGhlaXIgbG9jYWwgbGFuZ3VhZ2UsIHdoZW4gYXZhaWxhYmxlXG4gICAqL1xuICBMT0NBTDogXCJuYW1lXCIsXG4gIC8qKlxuICAgKiBJbnRlcm5hdGlvbmFsIG5hbWVcbiAgICovXG4gIElOVEVSTkFUSU9OQUw6IFwibmFtZV9pbnRcIixcbiAgQUxCQU5JQU46IFwibmFtZTpzcVwiLFxuICBBTUhBUklDOiBcIm5hbWU6YW1cIixcbiAgQVJBQklDOiBcIm5hbWU6YXJcIixcbiAgQVJNRU5JQU46IFwibmFtZTpoeVwiLFxuICBBWkVSQkFJSkFOSTogXCJuYW1lOmF6XCIsXG4gIEJBU1FVRTogXCJuYW1lOmV1XCIsXG4gIEJFTE9SVVNTSUFOOiBcIm5hbWU6YmVcIixcbiAgQkVOR0FMSTogXCJuYW1lOmJuXCIsXG4gIEJPU05JQU46IFwibmFtZTpic1wiLFxuICBCUkVUT046IFwibmFtZTpiclwiLFxuICBCVUxHQVJJQU46IFwibmFtZTpiZ1wiLFxuICBDQVRBTEFOOiBcIm5hbWU6Y2FcIixcbiAgQ0hJTkVTRTogXCJuYW1lOnpoXCIsXG4gIFRSQURJVElPTkFMX0NISU5FU0U6IFwibmFtZTp6aC1IYW50XCIsXG4gIFNJTVBMSUZJRURfQ0hJTkVTRTogXCJuYW1lOnpoLUhhbnNcIixcbiAgQ09SU0lDQU46IFwibmFtZTpjb1wiLFxuICBDUk9BVElBTjogXCJuYW1lOmhyXCIsXG4gIENaRUNIOiBcIm5hbWU6Y3NcIixcbiAgREFOSVNIOiBcIm5hbWU6ZGFcIixcbiAgRFVUQ0g6IFwibmFtZTpubFwiLFxuICBFTkdMSVNIOiBcIm5hbWU6ZW5cIixcbiAgRVNQRVJBTlRPOiBcIm5hbWU6ZW9cIixcbiAgRVNUT05JQU46IFwibmFtZTpldFwiLFxuICBGSU5OSVNIOiBcIm5hbWU6ZmlcIixcbiAgRlJFTkNIOiBcIm5hbWU6ZnJcIixcbiAgRlJJU0lBTjogXCJuYW1lOmZ5XCIsXG4gIEdFT1JHSUFOOiBcIm5hbWU6a2FcIixcbiAgR0VSTUFOOiBcIm5hbWU6ZGVcIixcbiAgR1JFRUs6IFwibmFtZTplbFwiLFxuICBIRUJSRVc6IFwibmFtZTpoZVwiLFxuICBISU5ESTogXCJuYW1lOmhpXCIsXG4gIEhVTkdBUklBTjogXCJuYW1lOmh1XCIsXG4gIElDRUxBTkRJQzogXCJuYW1lOmlzXCIsXG4gIElORE9ORVNJQU46IFwibmFtZTppZFwiLFxuICBJUklTSDogXCJuYW1lOmdhXCIsXG4gIElUQUxJQU46IFwibmFtZTppdFwiLFxuICBKQVBBTkVTRTogXCJuYW1lOmphXCIsXG4gIEpBUEFORVNFX0hJUkFHQU5BOiBcIm5hbWU6amEtSGlyYVwiLFxuICBKQVBBTkVTRV9LQU5BOiBcIm5hbWU6amFfa2FuYVwiLFxuICBKQVBBTkVTRV9MQVRJTjogXCJuYW1lOmphX3JtXCIsXG4gIEpBUEFORVNFXzIwMTg6IFwibmFtZTpqYS1MYXRuXCIsXG4gIEtBTk5BREE6IFwibmFtZTprblwiLFxuICBLQVpBS0g6IFwibmFtZTpra1wiLFxuICBLT1JFQU46IFwibmFtZTprb1wiLFxuICBLT1JFQU5fTEFUSU46IFwibmFtZTprby1MYXRuXCIsXG4gIEtVUkRJU0g6IFwibmFtZTprdVwiLFxuICBST01BTl9MQVRJTjogXCJuYW1lOmxhXCIsXG4gIExBVFZJQU46IFwibmFtZTpsdlwiLFxuICBMSVRIVUFOSUFOOiBcIm5hbWU6bHRcIixcbiAgTFVYRU1CT1VSR0lTSDogXCJuYW1lOmxiXCIsXG4gIE1BQ0VET05JQU46IFwibmFtZTpta1wiLFxuICBNQUxBWUFMQU06IFwibmFtZTptbFwiLFxuICBNQUxURVNFOiBcIm5hbWU6bXRcIixcbiAgTk9SV0VHSUFOOiBcIm5hbWU6bm9cIixcbiAgT0NDSVRBTjogXCJuYW1lOm9jXCIsXG4gIFBFUlNJQU46IFwibmFtZTpmYVwiLFxuICBQT0xJU0g6IFwibmFtZTpwbFwiLFxuICBQT1JUVUdVRVNFOiBcIm5hbWU6cHRcIixcbiAgUFVOSkFCSTogXCJuYW1lOnBhXCIsXG4gIFdFU1RFUk5fUFVOSkFCSTogXCJuYW1lOnBuYlwiLFxuICBST01BTklBTjogXCJuYW1lOnJvXCIsXG4gIFJPTUFOU0g6IFwibmFtZTpybVwiLFxuICBSVVNTSUFOOiBcIm5hbWU6cnVcIixcbiAgU0NPVFRJU0hfR0FFTElDOiBcIm5hbWU6Z2RcIixcbiAgU0VSQklBTl9DWVJJTExJQzogXCJuYW1lOnNyXCIsXG4gIFNFUkJJQU5fTEFUSU46IFwibmFtZTpzci1MYXRuXCIsXG4gIFNMT1ZBSzogXCJuYW1lOnNrXCIsXG4gIFNMT1ZFTkU6IFwibmFtZTpzbFwiLFxuICBTUEFOSVNIOiBcIm5hbWU6ZXNcIixcbiAgU1dFRElTSDogXCJuYW1lOnN2XCIsXG4gIFRBTUlMOiBcIm5hbWU6dGFcIixcbiAgVEVMVUdVOiBcIm5hbWU6dGVcIixcbiAgVEhBSTogXCJuYW1lOnRoXCIsXG4gIFRVUktJU0g6IFwibmFtZTp0clwiLFxuICBVS1JBSU5JQU46IFwibmFtZTp1a1wiLFxuICBVUkRVOiBcIm5hbWU6dXJcIixcbiAgVklFVE5BTUlBTl9MQVRJTjogXCJuYW1lOnZpXCIsXG4gIFdFTFNIOiBcIm5hbWU6Y3lcIlxufTtcbmNvbnN0IGxhbmd1YWdlc0lzb1NldCA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhMYW5ndWFnZSkpO1xuZnVuY3Rpb24gaXNMYW5ndWFnZVN1cHBvcnRlZChsYW5nKSB7XG4gIHJldHVybiBsYW5ndWFnZXNJc29TZXQuaGFzKGxhbmcpO1xufVxuY29uc3QgbGFuZ3VhZ2VDb2RlU2V0ID0gbmV3IFNldChPYmplY3QudmFsdWVzKExhbmd1YWdlKSk7XG5mdW5jdGlvbiBnZXRCcm93c2VyTGFuZ3VhZ2UoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGBuYW1lOiR7SW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zcGxpdChcIi1cIilbMF19YDtcbiAgfVxuICBjb25zdCBjYW5kaXRhdGVsYW5ncyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldChuYXZpZ2F0b3IubGFuZ3VhZ2VzLm1hcCgobCkgPT4gYG5hbWU6JHtsLnNwbGl0KFwiLVwiKVswXX1gKSlcbiAgKS5maWx0ZXIoKGwpID0+IGxhbmd1YWdlQ29kZVNldC5oYXMobCkpO1xuICByZXR1cm4gY2FuZGl0YXRlbGFuZ3MubGVuZ3RoID8gY2FuZGl0YXRlbGFuZ3NbMF0gOiBMYW5ndWFnZS5MT0NBTDtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIG1hcHRpbGVyTG9nb1VSTDogXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vcmVzb3VyY2VzL2xvZ28uc3ZnXCIsXG4gIG1hcHRpbGVyVVJMOiBcImh0dHBzOi8vd3d3Lm1hcHRpbGVyLmNvbS9cIixcbiAgbWFwdGlsZXJBcGlIb3N0OiBcImFwaS5tYXB0aWxlci5jb21cIixcbiAgcnRsUGx1Z2luVVJMOiBcImh0dHBzOi8vY2RuLm1hcHRpbGVyLmNvbS9tYXBib3gtZ2wtcnRsLXRleHQvdjAuMi4zL21hcGJveC1nbC1ydGwtdGV4dC5taW4uanNcIixcbiAgcHJpbWFyeUxhbmd1YWdlOiBMYW5ndWFnZS5TVFlMRSxcbiAgc2Vjb25kYXJ5TGFuZ3VhZ2U6IExhbmd1YWdlLkxPQ0FMLFxuICB0ZXJyYWluU291cmNlVVJMOiBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS90aWxlcy90ZXJyYWluLXJnYi12Mi90aWxlcy5qc29uXCIsXG4gIHRlcnJhaW5Tb3VyY2VJZDogXCJtYXB0aWxlci10ZXJyYWluXCJcbn07XG5PYmplY3QuZnJlZXplKGRlZmF1bHRzKTtcblxudmFyIF9fZGVmUHJvcCRiID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCRiID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCRiKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDggPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCRiKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IE1BUFRJTEVSX1NFU1NJT05fSUQgPSB2NCgpO1xuY2xhc3MgU2RrQ29uZmlnIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSBsYW5ndWFnZS4gQnkgZGVmYXVsdCwgdGhlIGxhbmd1YWdlIG9mIHRoZSB3ZWIgYnJvd3NlciBpcyB1c2VkLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQkOCh0aGlzLCBcInByaW1hcnlMYW5ndWFnZVwiLCBkZWZhdWx0cy5wcmltYXJ5TGFuZ3VhZ2UpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRhcnkgbGFuZ3VhZ2UsIHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBsYW5ndWFnZSBkZWZpbmVkIGluIHRoZSBtYXAgc3R5bGUuXG4gICAgICogVGhpcyBzZXR0aW5ncyBpcyBoaWdobHkgZGVwZW5kYW50IG9uIHRoZSBzdHlsZSBjb21wYXRpYmlsaXR5IGFuZCBtYXkgbm90IHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkJDgodGhpcywgXCJzZWNvbmRhcnlMYW5ndWFnZVwiKTtcbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIG9uIHdoZXRoZXIgb2Ygbm90IHRoZSBTREsgcnVucyB3aXRoIGEgc2Vzc2lvbiBsb2dpYy5cbiAgICAgKiBBIFwic2Vzc2lvblwiIGlzIHN0YXJ0ZWQgYXQgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBTREsgYW5kIGZpbmlzaGVkIHdoZW4gdGhlIGJyb3dzZXJcbiAgICAgKiBwYWdlIGlzIGJlaW5nIHJlZnJlc2hlZC5cbiAgICAgKiBXaGVuIGBzZXNzaW9uYCBpcyBlbmFibGVkIChkZWZhdWx0OiB0cnVlKSwgdGhlIGV4dHJhIFVSTCBwYXJhbSBgbXRzaWRgIGlzIGFkZGVkIHRvIHF1ZXJpZXNcbiAgICAgKiBvbiB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJLiBUaGlzIGFsbG93cyBNYXBUaWxlciB0byBlbmFibGUgXCJzZXNzaW9uIGJhc2VkIGJpbGxpbmdcIi5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkJDgodGhpcywgXCJzZXNzaW9uXCIsIHRydWUpO1xuICAgIC8qKlxuICAgICAqIFVuaXQgdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQkOCh0aGlzLCBcIl91bml0XCIsIFwibWV0cmljXCIpO1xuICAgIC8qKlxuICAgICAqIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkJDgodGhpcywgXCJfYXBpS2V5XCIsIFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVuaXQgc3lzdGVtXG4gICAqL1xuICBzZXQgdW5pdCh1KSB7XG4gICAgdGhpcy5fdW5pdCA9IHU7XG4gICAgdGhpcy5lbWl0KFwidW5pdFwiLCB1KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB1bml0IHN5c3RlbVxuICAgKi9cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgKi9cbiAgc2V0IGFwaUtleShrKSB7XG4gICAgdGhpcy5fYXBpS2V5ID0gaztcbiAgICBjb25maWckMS5hcGlLZXkgPSBrO1xuICAgIHRoaXMuZW1pdChcImFwaUtleVwiLCBrKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAqL1xuICBnZXQgYXBpS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcGlLZXk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHRoZSBjdXN0b20gZmV0Y2ggZnVuY3Rpb24gdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBvbmVcbiAgICovXG4gIHNldCBmZXRjaChmKSB7XG4gICAgY29uZmlnJDEuZmV0Y2ggPSBmO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZldGNoIGZ1Y250aW9uXG4gICAqL1xuICBnZXQgZmV0Y2goKSB7XG4gICAgcmV0dXJuIGNvbmZpZyQxLmZldGNoO1xuICB9XG59XG5jb25zdCBjb25maWcgPSBuZXcgU2RrQ29uZmlnKCk7XG5cbmNsYXNzIExvZ29Db250cm9sIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5Mb2dvQ29udHJvbCB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkYSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkYShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQ3ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkYShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBNYXB0aWxlckxvZ29Db250cm9sIGV4dGVuZHMgTG9nb0NvbnRyb2wge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIF9fcHVibGljRmllbGQkNyh0aGlzLCBcImxvZ29VUkxcIiwgXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ3KHRoaXMsIFwibGlua1VSTFwiLCBcIlwiKTtcbiAgICB0aGlzLmxvZ29VUkwgPSAoX2EgPSBvcHRpb25zLmxvZ29VUkwpICE9IG51bGwgPyBfYSA6IGRlZmF1bHRzLm1hcHRpbGVyTG9nb1VSTDtcbiAgICB0aGlzLmxpbmtVUkwgPSAoX2IgPSBvcHRpb25zLmxpbmtVUkwpICE9IG51bGwgPyBfYiA6IGRlZmF1bHRzLm1hcHRpbGVyVVJMO1xuICB9XG4gIG9uQWRkKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fY29tcGFjdCA9IChfYSA9IHRoaXMub3B0aW9ucy5jb21wYWN0KSAhPSBudWxsID8gX2EgOiBmYWxzZTtcbiAgICB0aGlzLl9jb250YWluZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lID0gXCJtYXBsaWJyZWdsLWN0cmxcIjtcbiAgICBjb25zdCBhbmNob3IgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgYW5jaG9yLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiO1xuICAgIGFuY2hvci5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICBhbmNob3Iuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBhbmNob3Iuc3R5bGUuaGVpZ2h0ID0gXCIyM3B4XCI7XG4gICAgYW5jaG9yLnN0eWxlLm1hcmdpbiA9IFwiMCAwIC00cHggLTRweFwiO1xuICAgIGFuY2hvci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgYW5jaG9yLnN0eWxlLndpZHRoID0gXCI4OHB4XCI7XG4gICAgYW5jaG9yLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt0aGlzLmxvZ29VUkx9KWA7XG4gICAgYW5jaG9yLnN0eWxlLmJhY2tncm91bmRTaXplID0gXCIxMDBweCAzMHB4XCI7XG4gICAgYW5jaG9yLnN0eWxlLndpZHRoID0gXCIxMDBweFwiO1xuICAgIGFuY2hvci5zdHlsZS5oZWlnaHQgPSBcIjMwcHhcIjtcbiAgICBhbmNob3IudGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgICBhbmNob3IucmVsID0gXCJub29wZW5lclwiO1xuICAgIGFuY2hvci5ocmVmID0gdGhpcy5saW5rVVJMO1xuICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiTWFwVGlsZXIgbG9nb1wiKTtcbiAgICBhbmNob3Iuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXJcIik7XG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGFuY2hvcik7XG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5fbWFwLm9uKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbXBhY3QoKTtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkOSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzJDUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCQ1ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0kNSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wJDkgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDkob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzJDUgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcCQ1LmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AkOShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkNSlcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkNShiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bSQ1LmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcCQ5KGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuZnVuY3Rpb24gZW5hYmxlUlRMKCkge1xuICBpZiAobWFwbGlicmVnbF9fZGVmYXVsdC5nZXRSVExUZXh0UGx1Z2luU3RhdHVzKCkgPT09IFwidW5hdmFpbGFibGVcIikge1xuICAgIG1hcGxpYnJlZ2xfX2RlZmF1bHQuc2V0UlRMVGV4dFBsdWdpbihcbiAgICAgIGRlZmF1bHRzLnJ0bFBsdWdpblVSTCxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICAgLy8gTGF6eSBsb2FkIHRoZSBwbHVnaW5cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kQWxsKGZucywgY29udGV4dCkge1xuICBmbnMuZm9yRWFjaCgoZm4pID0+IHtcbiAgICBpZiAodHlwZW9mIGNvbnRleHRbZm5dICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm47XG4gICAgY29udGV4dFtmbl0gPSBjb250ZXh0W2ZuXS5iaW5kKGNvbnRleHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIERPTWNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICBjb25zdCBlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAoY2xhc3NOYW1lICE9PSB2b2lkIDApXG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICBpZiAoY29udGFpbmVyKVxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIERPTXJlbW92ZShub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcHRpbGVyQ2xvdWRUcmFuc2Zvcm1SZXF1ZXN0KHVybCwgX3Jlc291cmNlVHlwZSkge1xuICBsZXQgcmVxVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXFVcmwgPSBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuICBpZiAocmVxVXJsLmhvc3QgPT09IGRlZmF1bHRzLm1hcHRpbGVyQXBpSG9zdCkge1xuICAgIGlmICghcmVxVXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJrZXlcIikpIHtcbiAgICAgIHJlcVVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGNvbmZpZy5hcGlLZXkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNlc3Npb24pIHtcbiAgICAgIHJlcVVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibXRzaWRcIiwgTUFQVElMRVJfU0VTU0lPTl9JRCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXJsOiByZXFVcmwuaHJlZlxuICB9O1xufVxuZnVuY3Rpb24gY29tYmluZVRyYW5zZm9ybVJlcXVlc3QodXNlckRlZmluZWRSVEYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcmVzb3VyY2VUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh1c2VyRGVmaW5lZFJURiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBycCA9IHVzZXJEZWZpbmVkUlRGKHVybCwgcmVzb3VyY2VUeXBlKTtcbiAgICAgIGNvbnN0IHJwMiA9IG1hcHRpbGVyQ2xvdWRUcmFuc2Zvcm1SZXF1ZXN0KChfYSA9IHJwID09IG51bGwgPyB2b2lkIDAgOiBycC51cmwpICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDUoX19zcHJlYWRWYWx1ZXMkNSh7fSwgcnApLCBycDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFwdGlsZXJDbG91ZFRyYW5zZm9ybVJlcXVlc3QodXJsKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cbmZ1bmN0aW9uIGlzVVVJRChzKSB7XG4gIGNvbnN0IHJlZ2V4RXhwID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2dpO1xuICByZXR1cm4gcmVnZXhFeHAudGVzdChzKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZU5vVGhyb3coZG9jKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZG9jKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzdHlsZVRvU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBNYXBTdHlsZVttYXBTdHlsZVByZXNldExpc3RbMF0ucmVmZXJlbmNlU3R5bGVJRF0uZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRFeHBhbmRlZFN0eWxlVVJMKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIiB8fCBzdHlsZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGlmICghc3R5bGUuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgc3R5bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIi5qc29uXCIpKSB7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHBhbmRNYXBTdHlsZShzdHlsZSk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZSBpbnN0YW5jZW9mIE1hcFN0eWxlVmFyaWFudCkge1xuICAgIHJldHVybiBzdHlsZS5nZXRFeHBhbmRlZFN0eWxlVVJMKCk7XG4gIH1cbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgUmVmZXJlbmNlTWFwU3R5bGUpIHtcbiAgICByZXR1cm4gc3R5bGUuZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRFeHBhbmRlZFN0eWxlVVJMKCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG52YXIgX19kZWZQcm9wJDggPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDggPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDgob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDgob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgTWFwdGlsZXJUZXJyYWluQ29udHJvbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQkNih0aGlzLCBcIl9tYXBcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ2KHRoaXMsIFwiX2NvbnRhaW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDYodGhpcywgXCJfdGVycmFpbkJ1dHRvblwiKTtcbiAgICBiaW5kQWxsKFtcIl90b2dnbGVUZXJyYWluXCIsIFwiX3VwZGF0ZVRlcnJhaW5JY29uXCJdLCB0aGlzKTtcbiAgfVxuICBvbkFkZChtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fY29udGFpbmVyID0gRE9NY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKTtcbiAgICB0aGlzLl90ZXJyYWluQnV0dG9uID0gRE9NY3JlYXRlKFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW5cIixcbiAgICAgIHRoaXMuX2NvbnRhaW5lclxuICAgICk7XG4gICAgRE9NY3JlYXRlKFwic3BhblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1pY29uXCIsIHRoaXMuX3RlcnJhaW5CdXR0b24pLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1oaWRkZW5cIixcbiAgICAgIFwidHJ1ZVwiXG4gICAgKTtcbiAgICB0aGlzLl90ZXJyYWluQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiO1xuICAgIHRoaXMuX3RlcnJhaW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RvZ2dsZVRlcnJhaW4pO1xuICAgIHRoaXMuX3VwZGF0ZVRlcnJhaW5JY29uKCk7XG4gICAgdGhpcy5fbWFwLm9uKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBET01yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9tYXAub2ZmKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbik7XG4gICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICB9XG4gIF90b2dnbGVUZXJyYWluKCkge1xuICAgIGlmICh0aGlzLl9tYXAuaGFzVGVycmFpbigpKSB7XG4gICAgICB0aGlzLl9tYXAuZGlzYWJsZVRlcnJhaW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwLmVuYWJsZVRlcnJhaW4oKTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVGVycmFpbkljb24oKTtcbiAgfVxuICBfdXBkYXRlVGVycmFpbkljb24oKSB7XG4gICAgdGhpcy5fdGVycmFpbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW5cIik7XG4gICAgdGhpcy5fdGVycmFpbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW4tZW5hYmxlZFwiKTtcbiAgICBpZiAodGhpcy5fbWFwLmhhc1RlcnJhaW4oKSkge1xuICAgICAgdGhpcy5fdGVycmFpbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW4tZW5hYmxlZFwiKTtcbiAgICAgIHRoaXMuX3RlcnJhaW5CdXR0b24udGl0bGUgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFxuICAgICAgICBcIlRlcnJhaW5Db250cm9sLmRpc2FibGVUZXJyYWluXCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlcnJhaW5CdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC10ZXJyYWluXCIpO1xuICAgICAgdGhpcy5fdGVycmFpbkJ1dHRvbi50aXRsZSA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXG4gICAgICAgIFwiVGVycmFpbkNvbnRyb2wuZW5hYmxlVGVycmFpblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uQ29udHJvbCBleHRlbmRzIG1hcGxpYnJlZ2xfX2RlZmF1bHQuTmF2aWdhdGlvbkNvbnRyb2wge1xuICBvbkFkZChtYXApIHtcbiAgICByZXR1cm4gc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG52YXIgX19kZWZQcm9wJDcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDcgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDcob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDcob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgTWFwdGlsZXJOYXZpZ2F0aW9uQ29udHJvbCBleHRlbmRzIE5hdmlnYXRpb25Db250cm9sIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgc2hvd0NvbXBhc3M6IHRydWUsXG4gICAgICBzaG93Wm9vbTogdHJ1ZSxcbiAgICAgIHZpc3VhbGl6ZVBpdGNoOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWRpbmc6IExpbWl0IGhvdyBmbGF0IHRoZSBjb21wYXNzIGljb24gY2FuIGdldFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQkNSh0aGlzLCBcIl9yb3RhdGVDb21wYXNzQXJyb3dcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgcm90YXRlID0gdGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoID8gYHNjYWxlKCR7TWF0aC5taW4oXG4gICAgICAgIDEuNSxcbiAgICAgICAgMSAvIE1hdGgucG93KFxuICAgICAgICAgIE1hdGguY29zKHRoaXMuX21hcC50cmFuc2Zvcm0ucGl0Y2ggKiAoTWF0aC5QSSAvIDE4MCkpLFxuICAgICAgICAgIDAuNVxuICAgICAgICApXG4gICAgICApfSkgcm90YXRlWCgke01hdGgubWluKDcwLCB0aGlzLl9tYXAudHJhbnNmb3JtLnBpdGNoKX1kZWcpIHJvdGF0ZVooJHt0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICogKDE4MCAvIE1hdGguUEkpfWRlZylgIDogYHJvdGF0ZSgke3RoaXMuX21hcC50cmFuc2Zvcm0uYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSl9ZGVnKWA7XG4gICAgICB0aGlzLl9jb21wYXNzSWNvbi5zdHlsZS50cmFuc2Zvcm0gPSByb3RhdGU7XG4gICAgfSk7XG4gICAgdGhpcy5fY29tcGFzcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgdGhpcy5fY29tcGFzcy5jbGlja0Z1bmN0aW9uXG4gICAgKTtcbiAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAge1xuICAgICAgICBjb25zdCBjdXJyZW50UGl0Y2ggPSB0aGlzLl9tYXAuZ2V0UGl0Y2goKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQaXRjaCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX21hcC5lYXNlVG8oeyBwaXRjaDogTWF0aC5taW4odGhpcy5fbWFwLmdldE1heFBpdGNoKCksIDgwKSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVzZXROb3J0aFBpdGNoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZXNldE5vcnRoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJsb2FkaW5nOiB0aGUgYnV0dG9uIG5vdyBzdG9yZXMgaXRzIGNsaWNrIGNhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIG9uIGRlbGV0ZSBpdCBhbmQgcmVwbGFjZSBpdFxuICAgKi9cbiAgX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUsIGZuKSB7XG4gICAgY29uc3QgYnV0dG9uID0gc3VwZXIuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUsIGZuKTtcbiAgICBidXR0b24uY2xpY2tGdW5jdGlvbiA9IGZuO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbn1cblxuY2xhc3MgR2VvbG9jYXRlQ29udHJvbCBleHRlbmRzIG1hcGxpYnJlZ2xfX2RlZmF1bHQuR2VvbG9jYXRlQ29udHJvbCB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkNiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzJDMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyQzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyQ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AkNCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtJDQgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCQ2ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ2KG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyQ0ID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AkNC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wJDYoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDQpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDQoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0kNC5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AkNihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzJDMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyQzKGEsIF9fZ2V0T3duUHJvcERlc2NzJDMoYikpO1xudmFyIF9fcHVibGljRmllbGQkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDYob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgTWFya2VyJDEgPSBtYXBsaWJyZWdsX19kZWZhdWx0Lk1hcmtlcjtcbmNvbnN0IExuZ0xhdCQxID0gbWFwbGlicmVnbF9fZGVmYXVsdC5MbmdMYXQ7XG5jb25zdCBMbmdMYXRCb3VuZHMkMSA9IG1hcGxpYnJlZ2xfX2RlZmF1bHQuTG5nTGF0Qm91bmRzO1xuY2xhc3MgTWFwdGlsZXJHZW9sb2NhdGVDb250cm9sIGV4dGVuZHMgR2VvbG9jYXRlQ29udHJvbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwibGFzdFVwZGF0ZWRDZW50ZXJcIiwgbmV3IExuZ0xhdCQxKDAsIDApKTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNhbWVyYSBsb2NhdGlvbiB0byBjZW50ZXIgb24gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIHRoZSBHZW9sb2NhdGlvbiBBUEkgUG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcIl91cGRhdGVDYW1lcmFcIiwgKHBvc2l0aW9uKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBMbmdMYXQkMShcbiAgICAgICAgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlXG4gICAgICApO1xuICAgICAgY29uc3QgcmFkaXVzID0gcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5O1xuICAgICAgY29uc3QgYmVhcmluZyA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRQcm9wcyQzKF9fc3ByZWFkVmFsdWVzJDQoe1xuICAgICAgICBiZWFyaW5nXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuZml0Qm91bmRzT3B0aW9ucyksIHtcbiAgICAgICAgbGluZWFyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNYXBab29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgIGlmIChjdXJyZW50TWFwWm9vbSA+ICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maXRCb3VuZHNPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWF4Wm9vbSkgIT0gbnVsbCA/IF9jIDogMzApKSB7XG4gICAgICAgIG9wdGlvbnMuem9vbSA9IGN1cnJlbnRNYXBab29tO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhMbmdMYXRCb3VuZHMkMS5mcm9tTG5nTGF0KGNlbnRlciwgcmFkaXVzKSwgb3B0aW9ucywge1xuICAgICAgICBnZW9sb2NhdGVTb3VyY2U6IHRydWVcbiAgICAgICAgLy8gdGFnIHRoaXMgY2FtZXJhIGNoYW5nZSBzbyBpdCB3b24ndCBjYXVzZSB0aGUgY29udHJvbCB0byBjaGFuZ2UgdG8gYmFja2dyb3VuZCBzdGF0ZVxuICAgICAgfSk7XG4gICAgICBsZXQgaGFzRml0dGluZ0JlZW5EaXNydXB0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGZsYWdGaXR0aW5nRGlzcnVwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaGFzRml0dGluZ0JlZW5EaXNydXB0ZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX21hcC5vbmNlKFwiY2xpY2tcIiwgZmxhZ0ZpdHRpbmdEaXNydXB0aW9uKTtcbiAgICAgIHRoaXMuX21hcC5vbmNlKFwiZGJsY2xpY2tcIiwgZmxhZ0ZpdHRpbmdEaXNydXB0aW9uKTtcbiAgICAgIHRoaXMuX21hcC5vbmNlKFwiZHJhZ3N0YXJ0XCIsIGZsYWdGaXR0aW5nRGlzcnVwdGlvbik7XG4gICAgICB0aGlzLl9tYXAub25jZShcIm1vdXNlZG93blwiLCBmbGFnRml0dGluZ0Rpc3J1cHRpb24pO1xuICAgICAgdGhpcy5fbWFwLm9uY2UoXCJ0b3VjaHN0YXJ0XCIsIGZsYWdGaXR0aW5nRGlzcnVwdGlvbik7XG4gICAgICB0aGlzLl9tYXAub25jZShcIndoZWVsXCIsIGZsYWdGaXR0aW5nRGlzcnVwdGlvbik7XG4gICAgICB0aGlzLl9tYXAub25jZShcIm1vdmVlbmRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIiwgZmxhZ0ZpdHRpbmdEaXNydXB0aW9uKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZihcImRibGNsaWNrXCIsIGZsYWdGaXR0aW5nRGlzcnVwdGlvbik7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoXCJkcmFnc3RhcnRcIiwgZmxhZ0ZpdHRpbmdEaXNydXB0aW9uKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZihcIm1vdXNlZG93blwiLCBmbGFnRml0dGluZ0Rpc3J1cHRpb24pO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKFwidG91Y2hzdGFydFwiLCBmbGFnRml0dGluZ0Rpc3J1cHRpb24pO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKFwid2hlZWxcIiwgZmxhZ0ZpdHRpbmdEaXNydXB0aW9uKTtcbiAgICAgICAgaWYgKGhhc0ZpdHRpbmdCZWVuRGlzcnVwdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZWRDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJfc2V0dXBVSVwiLCAoc3VwcG9ydGVkKSA9PiB7XG4gICAgICB0aGlzLmxhc3RVcGRhdGVkQ2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY29udGV4dG1lbnVcIixcbiAgICAgICAgKGUpID0+IGUucHJldmVudERlZmF1bHQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbiA9IERPTWNyZWF0ZShcbiAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlXCIsXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lclxuICAgICAgKTtcbiAgICAgIERPTWNyZWF0ZShcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIFwibWFwbGlicmVnbC1jdHJsLWljb25cIixcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uXG4gICAgICApLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcbiAgICAgIGlmIChzdXBwb3J0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcbiAgICAgICAgICBcIkdlb2xvY2F0ZUNvbnRyb2wuTG9jYXRpb25Ob3RBdmFpbGFibGVcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSB0aXRsZTtcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGl0bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiR2VvbG9jYXRlQ29udHJvbC5GaW5kTXlMb2NhdGlvblwiKTtcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRpdGxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xuICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbikge1xuICAgICAgICB0aGlzLl9kb3RFbGVtZW50ID0gRE9NY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC11c2VyLWxvY2F0aW9uLWRvdFwiKTtcbiAgICAgICAgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyID0gbmV3IE1hcmtlciQxKHsgZWxlbWVudDogdGhpcy5fZG90RWxlbWVudCB9KTtcbiAgICAgICAgdGhpcy5fY2lyY2xlRWxlbWVudCA9IERPTWNyZWF0ZShcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIFwibWFwbGlicmVnbC11c2VyLWxvY2F0aW9uLWFjY3VyYWN5LWNpcmNsZVwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyID0gbmV3IE1hcmtlciQxKHtcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLl9jaXJjbGVFbGVtZW50LFxuICAgICAgICAgIHBpdGNoQWxpZ25tZW50OiBcIm1hcFwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uKVxuICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIk9GRlwiO1xuICAgICAgICB0aGlzLl9tYXAub24oXCJtb3ZlXCIsIHRoaXMuX29uWm9vbSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3NldHVwID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tUmVzaXplID0gZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgPT09IFwicmVzaXplXCI7XG4gICAgICAgICAgY29uc3QgbW92aW5nRGlzdGFuY2UgPSB0aGlzLmxhc3RVcGRhdGVkQ2VudGVyLmRpc3RhbmNlVG8oXG4gICAgICAgICAgICB0aGlzLl9tYXAuZ2V0Q2VudGVyKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghZXZlbnQuZ2VvbG9jYXRlU291cmNlICYmIHRoaXMuX3dhdGNoU3RhdGUgPT09IFwiQUNUSVZFX0xPQ0tcIiAmJiAhZnJvbVJlc2l6ZSAmJiBtb3ZpbmdEaXN0YW5jZSA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkJBQ0tHUk9VTkRcIjtcbiAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFxuICAgICAgICAgICAgICBcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgIFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZShuZXcgRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbmVuZFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJfb25ab29tXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLm9wdGlvbnMuc2hvd0FjY3VyYWN5Q2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNpcmNsZVJhZGl1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVDaXJjbGVSYWRpdXMoKSB7XG4gICAgaWYgKHRoaXMuX3dhdGNoU3RhdGUgIT09IFwiQkFDS0dST1VORFwiICYmIHRoaXMuX3dhdGNoU3RhdGUgIT09IFwiQUNUSVZFX0xPQ0tcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0S25vd25Mb2NhdGlvbiA9IFtcbiAgICAgIHRoaXMuX2xhc3RLbm93blBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICB0aGlzLl9sYXN0S25vd25Qb3NpdGlvbi5jb29yZHMubGF0aXR1ZGVcbiAgICBdO1xuICAgIGNvbnN0IHByb2plY3RlZExvY2F0aW9uID0gdGhpcy5fbWFwLnByb2plY3QobGFzdEtub3duTG9jYXRpb24pO1xuICAgIGNvbnN0IGEgPSB0aGlzLl9tYXAudW5wcm9qZWN0KFtwcm9qZWN0ZWRMb2NhdGlvbi54LCBwcm9qZWN0ZWRMb2NhdGlvbi55XSk7XG4gICAgY29uc3QgYiA9IHRoaXMuX21hcC51bnByb2plY3QoW1xuICAgICAgcHJvamVjdGVkTG9jYXRpb24ueCArIDIwLFxuICAgICAgcHJvamVjdGVkTG9jYXRpb24ueVxuICAgIF0pO1xuICAgIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gYS5kaXN0YW5jZVRvKGIpIC8gMjA7XG4gICAgY29uc3QgY2lyY2xlRGlhbWV0ZXIgPSBNYXRoLmNlaWwoMiAqIHRoaXMuX2FjY3VyYWN5IC8gbWV0ZXJzUGVyUGl4ZWwpO1xuICAgIHRoaXMuX2NpcmNsZUVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtjaXJjbGVEaWFtZXRlcn1weGA7XG4gICAgdGhpcy5fY2lyY2xlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtjaXJjbGVEaWFtZXRlcn1weGA7XG4gIH1cbn1cblxuY2xhc3MgQXR0cmlidXRpb25Db250cm9sIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5BdHRyaWJ1dGlvbkNvbnRyb2wge1xuICBvbkFkZChtYXApIHtcbiAgICByZXR1cm4gc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG5jbGFzcyBTY2FsZUNvbnRyb2wgZXh0ZW5kcyBtYXBsaWJyZWdsX19kZWZhdWx0LlNjYWxlQ29udHJvbCB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbmNsYXNzIEZ1bGxzY3JlZW5Db250cm9sIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5GdWxsc2NyZWVuQ29udHJvbCB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyQzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AkMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtJDMgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ1KG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyQzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AkMy5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wJDUoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0kMy5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AkNShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzJDIgPSAoYSwgYikgPT4gX19kZWZQcm9wcyQyKGEsIF9fZ2V0T3duUHJvcERlc2NzJDIoYikpO1xudmFyIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIik7XG4gIHJldHVybiBtZXRob2Q7XG59O1xudmFyIF9vcHRpb25zLCBfcGFyZW50TWFwLCBfY29udGFpbmVyLCBfY2FudmFzQ29udGFpbmVyLCBfcGFyZW50UmVjdCwgX2RpZmZlcmVudFN0eWxlLCBfZGVzeW5jLCBfYWRkUGFyZW50UmVjdCwgYWRkUGFyZW50UmVjdF9mbiwgX3NldFBhcmVudEJvdW5kcywgc2V0UGFyZW50Qm91bmRzX2ZuLCBfc3luY01hcHMsIHN5bmNNYXBzX2ZuO1xuY2xhc3MgTWluaW1hcCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIG1hcE9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2FkZFBhcmVudFJlY3QpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2V0UGFyZW50Qm91bmRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N5bmNNYXBzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMsIHZvaWQgMCk7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwibWFwXCIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGFyZW50TWFwLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY29udGFpbmVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2FudmFzQ29udGFpbmVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGFyZW50UmVjdCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RpZmZlcmVudFN0eWxlLCBmYWxzZSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kZXN5bmMsIHZvaWQgMCk7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRpb25zLnN0eWxlICE9PSB2b2lkIDApXG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RpZmZlcmVudFN0eWxlLCB0cnVlKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMsIF9fc3ByZWFkUHJvcHMkMihfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkUHJvcHMkMihfX3NwcmVhZFZhbHVlcyQzKHtcbiAgICAgIC8vIHNldCBkZWZhdWx0c1xuICAgICAgem9vbUFkanVzdDogLTQsXG4gICAgICBwb3NpdGlvbjogXCJ0b3AtcmlnaHRcIlxuICAgIH0sIG1hcE9wdGlvbnMpLCB7XG4gICAgICAvLyBvdmVycmlkZSBhbnkgbGluZ2VyaW5nIGNvbnRyb2wgb3B0aW9uc1xuICAgICAgZm9yY2VOb0F0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogZmFsc2UsXG4gICAgICBuYXZpZ2F0aW9uQ29udHJvbDogZmFsc2UsXG4gICAgICBnZW9sb2NhdGVDb250cm9sOiBmYWxzZSxcbiAgICAgIG1hcHRpbGVyTG9nbzogZmFsc2UsXG4gICAgICBtaW5pbWFwOiBmYWxzZSxcbiAgICAgIGhhc2g6IGZhbHNlLFxuICAgICAgcGl0Y2hBZGp1c3Q6IGZhbHNlXG4gICAgfSksIG9wdGlvbnMpLCB7XG4gICAgICBjb250YWluZXJTdHlsZTogX19zcHJlYWRWYWx1ZXMkMyh7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzAwMFwiLFxuICAgICAgICB3aWR0aDogXCI0MDBweFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMzAwcHhcIlxuICAgICAgfSwgKF9hID0gb3B0aW9ucy5jb250YWluZXJTdHlsZSkgIT0gbnVsbCA/IF9hIDoge30pXG4gICAgfSkpO1xuICAgIGlmIChvcHRpb25zLmxvY2tab29tICE9PSB2b2lkIDApIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9ucykubWluWm9vbSA9IG9wdGlvbnMubG9ja1pvb207XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnMpLm1heFpvb20gPSBvcHRpb25zLmxvY2tab29tO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9kaWZmZXJlbnRTdHlsZSkpXG4gICAgICB0aGlzLm1hcC5zZXRTdHlsZShzdHlsZSwgb3B0aW9ucyk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRQYXJlbnRCb3VuZHMsIHNldFBhcmVudEJvdW5kc19mbikuY2FsbCh0aGlzKTtcbiAgfVxuICBhZGRMYXllcihsYXllciwgYmVmb3JlSWQpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfZGlmZmVyZW50U3R5bGUpKVxuICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZUlkKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldFBhcmVudEJvdW5kcywgc2V0UGFyZW50Qm91bmRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLm1hcDtcbiAgfVxuICBtb3ZlTGF5ZXIoaWQsIGJlZm9yZUlkKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2RpZmZlcmVudFN0eWxlKSlcbiAgICAgIHRoaXMubWFwLm1vdmVMYXllcihpZCwgYmVmb3JlSWQpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfc2V0UGFyZW50Qm91bmRzLCBzZXRQYXJlbnRCb3VuZHNfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubWFwO1xuICB9XG4gIHJlbW92ZUxheWVyKGlkKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2RpZmZlcmVudFN0eWxlKSlcbiAgICAgIHRoaXMubWFwLnJlbW92ZUxheWVyKGlkKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldFBhcmVudEJvdW5kcywgc2V0UGFyZW50Qm91bmRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldExheWVyWm9vbVJhbmdlKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfZGlmZmVyZW50U3R5bGUpKVxuICAgICAgdGhpcy5tYXAuc2V0TGF5ZXJab29tUmFuZ2UobGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRQYXJlbnRCb3VuZHMsIHNldFBhcmVudEJvdW5kc19mbikuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRGaWx0ZXIobGF5ZXJJZCwgZmlsdGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2RpZmZlcmVudFN0eWxlKSlcbiAgICAgIHRoaXMubWFwLnNldEZpbHRlcihsYXllcklkLCBmaWx0ZXIsIG9wdGlvbnMpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfc2V0UGFyZW50Qm91bmRzLCBzZXRQYXJlbnRCb3VuZHNfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UGFpbnRQcm9wZXJ0eShsYXllcklkLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9kaWZmZXJlbnRTdHlsZSkpXG4gICAgICB0aGlzLm1hcC5zZXRQYWludFByb3BlcnR5KGxheWVySWQsIG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldFBhcmVudEJvdW5kcywgc2V0UGFyZW50Qm91bmRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldExheW91dFByb3BlcnR5KGxheWVySWQsIG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2RpZmZlcmVudFN0eWxlKSlcbiAgICAgIHRoaXMubWFwLnNldExheW91dFByb3BlcnR5KGxheWVySWQsIG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldFBhcmVudEJvdW5kcywgc2V0UGFyZW50Qm91bmRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEdseXBocyhnbHlwaHNVcmwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfZGlmZmVyZW50U3R5bGUpKVxuICAgICAgdGhpcy5tYXAuc2V0R2x5cGhzKGdseXBoc1VybCwgb3B0aW9ucyk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRQYXJlbnRCb3VuZHMsIHNldFBhcmVudEJvdW5kc19mbikuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkFkZChwYXJlbnRNYXApIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BhcmVudE1hcCwgcGFyZW50TWFwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRhaW5lciwgRE9NY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKS5jb250YWluZXJTdHlsZSkpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udGFpbmVyKS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKS5jb250YWluZXIgPSBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRhaW5lcik7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKS56b29tID0gcGFyZW50TWFwLmdldFpvb20oKSArIF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9ucykuem9vbUFkanVzdDtcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKSk7XG4gICAgdGhpcy5tYXAub25jZShcInN0eWxlLmxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5tYXAucmVzaXplKCk7XG4gICAgfSk7XG4gICAgdGhpcy5tYXAub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9hZGRQYXJlbnRSZWN0LCBhZGRQYXJlbnRSZWN0X2ZuKS5jYWxsKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9ucykucGFyZW50UmVjdCk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Rlc3luYywgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zeW5jTWFwcywgc3luY01hcHNfZm4pLmNhbGwodGhpcykpO1xuICAgIH0pO1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRhaW5lcik7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVzeW5jKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgRE9NcmVtb3ZlKF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udGFpbmVyKSk7XG4gIH1cbn1cbl9vcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbl9wYXJlbnRNYXAgPSBuZXcgV2Vha01hcCgpO1xuX2NvbnRhaW5lciA9IG5ldyBXZWFrTWFwKCk7XG5fY2FudmFzQ29udGFpbmVyID0gbmV3IFdlYWtNYXAoKTtcbl9wYXJlbnRSZWN0ID0gbmV3IFdlYWtNYXAoKTtcbl9kaWZmZXJlbnRTdHlsZSA9IG5ldyBXZWFrTWFwKCk7XG5fZGVzeW5jID0gbmV3IFdlYWtNYXAoKTtcbl9hZGRQYXJlbnRSZWN0ID0gbmV3IFdlYWtTZXQoKTtcbmFkZFBhcmVudFJlY3RfZm4gPSBmdW5jdGlvbihyZWN0KSB7XG4gIGlmIChyZWN0ID09PSB2b2lkIDAgfHwgcmVjdC5saW5lUGFpbnQgPT09IHZvaWQgMCAmJiByZWN0LmZpbGxQYWludCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGFyZW50UmVjdCwge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIG5hbWU6IFwicGFyZW50UmVjdFwiXG4gICAgfSxcbiAgICBnZW9tZXRyeToge1xuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICBjb29yZGluYXRlczogW1tbXSwgW10sIFtdLCBbXSwgW11dXVxuICAgIH1cbiAgfSk7XG4gIHRoaXMubWFwLmFkZFNvdXJjZShcInBhcmVudFJlY3RcIiwge1xuICAgIHR5cGU6IFwiZ2VvanNvblwiLFxuICAgIGRhdGE6IF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyZW50UmVjdClcbiAgfSk7XG4gIGlmIChyZWN0LmxpbmVMYXlvdXQgIT09IHZvaWQgMCB8fCByZWN0LmxpbmVQYWludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhpcy5tYXAuYWRkTGF5ZXIoe1xuICAgICAgaWQ6IFwicGFyZW50UmVjdE91dGxpbmVcIixcbiAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgc291cmNlOiBcInBhcmVudFJlY3RcIixcbiAgICAgIGxheW91dDogX19zcHJlYWRWYWx1ZXMkMyh7fSwgcmVjdC5saW5lTGF5b3V0KSxcbiAgICAgIHBhaW50OiBfX3NwcmVhZFZhbHVlcyQzKHtcbiAgICAgICAgXCJsaW5lLWNvbG9yXCI6IFwiI0ZGRlwiLFxuICAgICAgICBcImxpbmUtd2lkdGhcIjogMSxcbiAgICAgICAgXCJsaW5lLW9wYWNpdHlcIjogMC44NVxuICAgICAgfSwgcmVjdC5saW5lUGFpbnQpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY3QuZmlsbFBhaW50ICE9PSB2b2lkIDApIHtcbiAgICB0aGlzLm1hcC5hZGRMYXllcih7XG4gICAgICBpZDogXCJwYXJlbnRSZWN0RmlsbFwiLFxuICAgICAgdHlwZTogXCJmaWxsXCIsXG4gICAgICBzb3VyY2U6IFwicGFyZW50UmVjdFwiLFxuICAgICAgbGF5b3V0OiB7fSxcbiAgICAgIHBhaW50OiBfX3NwcmVhZFZhbHVlcyQzKHtcbiAgICAgICAgXCJmaWxsLWNvbG9yXCI6IFwiIzA4RlwiLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiAwLjEzNVxuICAgICAgfSwgcmVjdC5maWxsUGFpbnQpXG4gICAgfSk7XG4gIH1cbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRQYXJlbnRCb3VuZHMsIHNldFBhcmVudEJvdW5kc19mbikuY2FsbCh0aGlzKTtcbn07XG5fc2V0UGFyZW50Qm91bmRzID0gbmV3IFdlYWtTZXQoKTtcbnNldFBhcmVudEJvdW5kc19mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wYXJlbnRSZWN0KSA9PT0gdm9pZCAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBkZXZpY2VQaXhlbFJhdGlvIH0gPSB3aW5kb3c7XG4gIGNvbnN0IGNhbnZhcyA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyZW50TWFwKS5nZXRDYW52YXMoKTtcbiAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggLyBkZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgdW5wcm9qZWN0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9wYXJlbnRNYXApLnVucHJvamVjdC5iaW5kKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyZW50TWFwKSk7XG4gIGNvbnN0IG5vcnRoV2VzdCA9IHVucHJvamVjdChbMCwgMF0pO1xuICBjb25zdCBub3J0aEVhc3QgPSB1bnByb2plY3QoW3dpZHRoLCAwXSk7XG4gIGNvbnN0IHNvdXRoV2VzdCA9IHVucHJvamVjdChbMCwgaGVpZ2h0XSk7XG4gIGNvbnN0IHNvdXRoRWFzdCA9IHVucHJvamVjdChbd2lkdGgsIGhlaWdodF0pO1xuICBfX3ByaXZhdGVHZXQodGhpcywgX3BhcmVudFJlY3QpLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW1xuICAgIFtcbiAgICAgIHNvdXRoV2VzdC50b0FycmF5KCksXG4gICAgICBzb3V0aEVhc3QudG9BcnJheSgpLFxuICAgICAgbm9ydGhFYXN0LnRvQXJyYXkoKSxcbiAgICAgIG5vcnRoV2VzdC50b0FycmF5KCksXG4gICAgICBzb3V0aFdlc3QudG9BcnJheSgpXG4gICAgXVxuICBdO1xuICBjb25zdCBzb3VyY2UgPSB0aGlzLm1hcC5nZXRTb3VyY2UoXCJwYXJlbnRSZWN0XCIpO1xuICBzb3VyY2Uuc2V0RGF0YShfX3ByaXZhdGVHZXQodGhpcywgX3BhcmVudFJlY3QpKTtcbn07XG5fc3luY01hcHMgPSBuZXcgV2Vha1NldCgpO1xuc3luY01hcHNfZm4gPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgeyBwaXRjaEFkanVzdCB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKTtcbiAgY29uc3QgcGFyZW50Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgc3luYyhcInBhcmVudFwiKTtcbiAgfTtcbiAgY29uc3QgbWluaW1hcENhbGxiYWNrID0gKCkgPT4ge1xuICAgIHN5bmMoXCJtaW5pbWFwXCIpO1xuICB9O1xuICBjb25zdCBvbiA9ICgpID0+IHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3BhcmVudE1hcCkub24oXCJtb3ZlXCIsIHBhcmVudENhbGxiYWNrKTtcbiAgICB0aGlzLm1hcC5vbihcIm1vdmVcIiwgbWluaW1hcENhbGxiYWNrKTtcbiAgfTtcbiAgY29uc3Qgb2ZmID0gKCkgPT4ge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyZW50TWFwKS5vZmYoXCJtb3ZlXCIsIHBhcmVudENhbGxiYWNrKTtcbiAgICB0aGlzLm1hcC5vZmYoXCJtb3ZlXCIsIG1pbmltYXBDYWxsYmFjayk7XG4gIH07XG4gIGNvbnN0IHN5bmMgPSAod2hpY2gpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgb2ZmKCk7XG4gICAgY29uc3QgZnJvbSA9IHdoaWNoID09PSBcInBhcmVudFwiID8gX19wcml2YXRlR2V0KHRoaXMsIF9wYXJlbnRNYXApIDogdGhpcy5tYXA7XG4gICAgY29uc3QgdG8gPSB3aGljaCA9PT0gXCJwYXJlbnRcIiA/IHRoaXMubWFwIDogX19wcml2YXRlR2V0KHRoaXMsIF9wYXJlbnRNYXApO1xuICAgIGNvbnN0IGNlbnRlciA9IGZyb20uZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IGZyb20uZ2V0Wm9vbSgpICsgKChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9ucykuem9vbUFkanVzdCkgIT0gbnVsbCA/IF9hIDogLTQpICogKHdoaWNoID09PSBcInBhcmVudFwiID8gMSA6IC0xKTtcbiAgICBjb25zdCBiZWFyaW5nID0gZnJvbS5nZXRCZWFyaW5nKCk7XG4gICAgY29uc3QgcGl0Y2ggPSBmcm9tLmdldFBpdGNoKCk7XG4gICAgdG8uanVtcFRvKHtcbiAgICAgIGNlbnRlcixcbiAgICAgIHpvb20sXG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2g6IHBpdGNoQWRqdXN0ID8gcGl0Y2ggOiAwXG4gICAgfSk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRQYXJlbnRCb3VuZHMsIHNldFBhcmVudEJvdW5kc19mbikuY2FsbCh0aGlzKTtcbiAgICBvbigpO1xuICB9O1xuICBvbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIG9mZigpO1xuICB9O1xufTtcblxudmFyIF9fZGVmUHJvcCQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDQob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcCQyLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AkNChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMilcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMihiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bSQyLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcCQ0KGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMkMSA9IChhLCBiKSA9PiBfX2RlZlByb3BzJDEoYSwgX19nZXRPd25Qcm9wRGVzY3MkMShiKSk7XG52YXIgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkNChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19hc3luYyQxID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5jb25zdCBHZW9sb2NhdGlvblR5cGUgPSB7XG4gIFBPSU5UOiBcIlBPSU5UXCIsXG4gIENPVU5UUlk6IFwiQ09VTlRSWVwiXG59O1xuY2xhc3MgTWFwIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5NYXAge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICBjb25maWcuYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gc3R5bGVUb1N0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGNvbnN0IGhhc2hQcmVDb25zdHJ1Y3RvciA9IGxvY2F0aW9uLmhhc2g7XG4gICAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiTWFwVGlsZXIgQ2xvdWQgQVBJIGtleSBpcyBub3Qgc2V0LiBWaXNpdCBodHRwczovL21hcHRpbGVyLmNvbSBhbmQgdHJ5IENsb3VkIGZvciBmcmVlIVwiXG4gICAgICApO1xuICAgIH1cbiAgICBzdXBlcihfX3NwcmVhZFByb3BzJDEoX19zcHJlYWRWYWx1ZXMkMih7fSwgb3B0aW9ucyksIHtcbiAgICAgIHN0eWxlLFxuICAgICAgbWFwbGlicmVMb2dvOiBmYWxzZSxcbiAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGNvbWJpbmVUcmFuc2Zvcm1SZXF1ZXN0KG9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdClcbiAgICB9KSk7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaXNUZXJyYWluRW5hYmxlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwidGVycmFpbkV4YWdnZXJhdGlvblwiLCAxKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwcmltYXJ5TGFuZ3VhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwidGVycmFpbkdyb3dpbmdcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInRlcnJhaW5GbGF0dGVuaW5nXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJtaW5pbWFwXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImZvcmNlTGFuZ3VhZ2VVcGRhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwibGFuZ3VhZ2VBbHdheXNCZWVuU3R5bGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaXNSZWFkeVwiLCBmYWxzZSk7XG4gICAgdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPSAoX2EgPSBvcHRpb25zLmxhbmd1YWdlKSAhPSBudWxsID8gX2EgOiBjb25maWcucHJpbWFyeUxhbmd1YWdlO1xuICAgIHRoaXMuZm9yY2VMYW5ndWFnZVVwZGF0ZSA9IHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSBMYW5ndWFnZS5TVFlMRSB8fCB0aGlzLnByaW1hcnlMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuU1RZTEVfTE9DSyA/IGZhbHNlIDogdHJ1ZTtcbiAgICB0aGlzLmxhbmd1YWdlQWx3YXlzQmVlblN0eWxlID0gdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPT09IExhbmd1YWdlLlNUWUxFO1xuICAgIHRoaXMudGVycmFpbkV4YWdnZXJhdGlvbiA9IChfYiA9IG9wdGlvbnMudGVycmFpbkV4YWdnZXJhdGlvbikgIT0gbnVsbCA/IF9iIDogdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uO1xuICAgIHRoaXMub25jZShcInN0eWxlZGF0YVwiLCAoKSA9PiBfX2FzeW5jJDEodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghb3B0aW9ucy5nZW9sb2NhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhhc2ggJiYgISFoYXNoUHJlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZ2VvbG9jYXRlID09PSBHZW9sb2NhdGlvblR5cGUuQ09VTlRSWSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuZml0VG9JcEJvdW5kcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGxldCBpcExvY2F0ZWRDYW1lcmFIYXNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5jZW50ZXJPbklwUG9pbnQob3B0aW9ucy56b29tKTtcbiAgICAgICAgaXBMb2NhdGVkQ2FtZXJhSGFzaCA9IHRoaXMuZ2V0Q2FtZXJhSGFzaCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2F0aW9uUmVzdWx0ID0geWllbGQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgbmFtZTogXCJnZW9sb2NhdGlvblwiXG4gICAgICB9KTtcbiAgICAgIGlmIChsb2NhdGlvblJlc3VsdC5zdGF0ZSA9PT0gXCJncmFudGVkXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgICAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpcExvY2F0ZWRDYW1lcmFIYXNoICE9PSB0aGlzLmdldENhbWVyYUhhc2goKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXJyYWluKSB7XG4gICAgICAgICAgICAgIHRoaXMuZWFzZVRvKHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IFtkYXRhLmNvb3Jkcy5sb25naXR1ZGUsIGRhdGEuY29vcmRzLmxhdGl0dWRlXSxcbiAgICAgICAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20gfHwgMTIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDJlM1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMub25jZShcInRlcnJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFzZVRvKHtcbiAgICAgICAgICAgICAgICAgIGNlbnRlcjogW2RhdGEuY29vcmRzLmxvbmdpdHVkZSwgZGF0YS5jb29yZHMubGF0aXR1ZGVdLFxuICAgICAgICAgICAgICAgICAgem9vbTogb3B0aW9ucy56b29tIHx8IDEyLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDJlM1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGVycm9yIGNhbGxiYWNrXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWF4aW11bUFnZTogMjQgKiAzNjAwICogMWUzLFxuICAgICAgICAgICAgLy8gYSBkYXkgaW4gbWlsbGlzZWNcbiAgICAgICAgICAgIHRpbWVvdXQ6IDVlMyxcbiAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdGhpcy5vbihcInN0eWxlZGF0YVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldFByaW1hcnlMYW5ndWFnZSh0aGlzLnByaW1hcnlMYW5ndWFnZSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbihcInN0eWxlZGF0YVwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5nZXRUZXJyYWluKCkgPT09IG51bGwgJiYgdGhpcy5pc1RlcnJhaW5FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlVGVycmFpbih0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25jZShcImxvYWRcIiwgKCkgPT4gX19hc3luYyQxKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBlbmFibGVSVEwoKTtcbiAgICB9KSk7XG4gICAgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiBfX2FzeW5jJDEodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCB0aWxlSnNvbkNvbnRlbnQgPSB7IGxvZ286IG51bGwgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlU291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc3R5bGUuc291cmNlQ2FjaGVzKS5tYXAoKHNvdXJjZU5hbWUpID0+IHRoaXMuZ2V0U291cmNlKHNvdXJjZU5hbWUpKS5maWx0ZXIoXG4gICAgICAgICAgKHMpID0+IHMgJiYgXCJ1cmxcIiBpbiBzICYmIHR5cGVvZiBzLnVybCA9PT0gXCJzdHJpbmdcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy51cmwuaW5jbHVkZXMoXCJ0aWxlcy5qc29uXCIpKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzdHlsZVVybCA9IG5ldyBVUkwoXG4gICAgICAgICAgcG9zc2libGVTb3VyY2VzWzBdLnVybFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXN0eWxlVXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJrZXlcIikpIHtcbiAgICAgICAgICBzdHlsZVVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGNvbmZpZy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbGVKc29uUmVzID0geWllbGQgZmV0Y2goc3R5bGVVcmwuaHJlZik7XG4gICAgICAgIHRpbGVKc29uQ29udGVudCA9IHlpZWxkIHRpbGVKc29uUmVzLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmZvcmNlTm9BdHRyaWJ1dGlvbkNvbnRyb2wgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKFwibG9nb1wiIGluIHRpbGVKc29uQ29udGVudCAmJiB0aWxlSnNvbkNvbnRlbnQubG9nbykge1xuICAgICAgICAgIGNvbnN0IGxvZ29VUkwgPSB0aWxlSnNvbkNvbnRlbnQubG9nbztcbiAgICAgICAgICB0aGlzLmFkZENvbnRyb2woXG4gICAgICAgICAgICBuZXcgTWFwdGlsZXJMb2dvQ29udHJvbCh7IGxvZ29VUkwgfSksXG4gICAgICAgICAgICBvcHRpb25zLmxvZ29Qb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDb250cm9sKFxuICAgICAgICAgICAgICBuZXcgQXR0cmlidXRpb25Db250cm9sKHtcbiAgICAgICAgICAgICAgICBjdXN0b21BdHRyaWJ1dGlvbjogb3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvblxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXB0aWxlckxvZ28pIHtcbiAgICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IE1hcHRpbGVyTG9nb0NvbnRyb2woKSwgb3B0aW9ucy5sb2dvUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZUNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zLnNjYWxlQ29udHJvbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLnNjYWxlQ29udHJvbCA9PT0gdm9pZCAwID8gXCJib3R0b20tcmlnaHRcIiA6IG9wdGlvbnMuc2NhbGVDb250cm9sO1xuICAgICAgICBjb25zdCBzY2FsZUNvbnRyb2wgPSBuZXcgU2NhbGVDb250cm9sKHsgdW5pdDogY29uZmlnLnVuaXQgfSk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChzY2FsZUNvbnRyb2wsIHBvc2l0aW9uKTtcbiAgICAgICAgY29uZmlnLm9uKFwidW5pdFwiLCAodW5pdCkgPT4ge1xuICAgICAgICAgIHNjYWxlQ29udHJvbC5zZXRVbml0KHVuaXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm5hdmlnYXRpb25Db250cm9sICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnMubmF2aWdhdGlvbkNvbnRyb2wgPT09IHRydWUgfHwgb3B0aW9ucy5uYXZpZ2F0aW9uQ29udHJvbCA9PT0gdm9pZCAwID8gXCJ0b3AtcmlnaHRcIiA6IG9wdGlvbnMubmF2aWdhdGlvbkNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgTWFwdGlsZXJOYXZpZ2F0aW9uQ29udHJvbCgpLCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5nZW9sb2NhdGVDb250cm9sICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnMuZ2VvbG9jYXRlQ29udHJvbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLmdlb2xvY2F0ZUNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiBvcHRpb25zLmdlb2xvY2F0ZUNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChcbiAgICAgICAgICAvLyBuZXcgbWFwbGlicmVnbC5HZW9sb2NhdGVDb250cm9sKHtcbiAgICAgICAgICBuZXcgTWFwdGlsZXJHZW9sb2NhdGVDb250cm9sKHtcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uczoge1xuICAgICAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUsXG4gICAgICAgICAgICAgIG1heGltdW1BZ2U6IDAsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDZlM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kc09wdGlvbnM6IHtcbiAgICAgICAgICAgICAgbWF4Wm9vbTogMTVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja1VzZXJMb2NhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dBY2N1cmFjeUNpcmNsZTogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dVc2VyTG9jYXRpb246IHRydWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudGVycmFpbkNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zLnRlcnJhaW5Db250cm9sID09PSB0cnVlIHx8IG9wdGlvbnMudGVycmFpbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiBvcHRpb25zLnRlcnJhaW5Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IE1hcHRpbGVyVGVycmFpbkNvbnRyb2woKSwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sID09PSB0cnVlIHx8IG9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiBvcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IEZ1bGxzY3JlZW5Db250cm9sKHt9KSwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlyZShcInJlYWR5XCIsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgIH0pKTtcbiAgICBsZXQgbG9hZEV2ZW50VHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgbGV0IHRlcnJhaW5FdmVudFRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIGxldCB0ZXJyYWluRXZlbnREYXRhO1xuICAgIHRoaXMub25jZShcInJlYWR5XCIsICgpID0+IHtcbiAgICAgIGxvYWRFdmVudFRyaWdnZXJlZCA9IHRydWU7XG4gICAgICBpZiAodGVycmFpbkV2ZW50VHJpZ2dlcmVkKSB7XG4gICAgICAgIHRoaXMuZmlyZShcImxvYWRXaXRoVGVycmFpblwiLCB0ZXJyYWluRXZlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm9uY2UoXCJzdHlsZS5sb2FkXCIsICgpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBjb25zdCB7IG1pbmltYXAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIG1pbmltYXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHpvb20sXG4gICAgICAgICAgY2VudGVyLFxuICAgICAgICAgIHN0eWxlOiBzdHlsZTIsXG4gICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgIG1hcHRpbGVyTG9nbyxcbiAgICAgICAgICBhbnRpYWxpYXMsXG4gICAgICAgICAgcmVmcmVzaEV4cGlyZWRUaWxlcyxcbiAgICAgICAgICBtYXhCb3VuZHMsXG4gICAgICAgICAgc2Nyb2xsWm9vbSxcbiAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgYm94Wm9vbSxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgZmFkZUR1cmF0aW9uLFxuICAgICAgICAgIGNyb3NzU291cmNlQ29sbGlzaW9ucyxcbiAgICAgICAgICBjbGlja1RvbGVyYW5jZSxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgZml0Qm91bmRzT3B0aW9ucyxcbiAgICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICAgIHZhbGlkYXRlU3R5bGVcbiAgICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubWluaW1hcCA9IG5ldyBNaW5pbWFwKG1pbmltYXAsIHtcbiAgICAgICAgICB6b29tLFxuICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgICBzdHlsZTogc3R5bGUyLFxuICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICBjb250YWluZXI6IFwibnVsbFwiLFxuICAgICAgICAgIG1hcHRpbGVyTG9nbyxcbiAgICAgICAgICBhbnRpYWxpYXMsXG4gICAgICAgICAgcmVmcmVzaEV4cGlyZWRUaWxlcyxcbiAgICAgICAgICBtYXhCb3VuZHMsXG4gICAgICAgICAgc2Nyb2xsWm9vbSxcbiAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgYm94Wm9vbSxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgZmFkZUR1cmF0aW9uLFxuICAgICAgICAgIGNyb3NzU291cmNlQ29sbGlzaW9ucyxcbiAgICAgICAgICBjbGlja1RvbGVyYW5jZSxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgZml0Qm91bmRzT3B0aW9ucyxcbiAgICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICAgIHZhbGlkYXRlU3R5bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLm1pbmltYXAsIChfYTIgPSBtaW5pbWFwLnBvc2l0aW9uKSAhPSBudWxsID8gX2EyIDogXCJib3R0b20tbGVmdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobWluaW1hcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1pbmltYXAgPSBuZXcgTWluaW1hcCh7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLm1pbmltYXAsIFwiYm90dG9tLWxlZnRcIik7XG4gICAgICB9IGVsc2UgaWYgKG1pbmltYXAgIT09IHZvaWQgMCAmJiBtaW5pbWFwICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1pbmltYXAgPSBuZXcgTWluaW1hcCh7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLm1pbmltYXAsIG1pbmltYXApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRlcnJhaW5DYWxsYmFjayA9IChldnQpID0+IHtcbiAgICAgIGlmICghZXZ0LnRlcnJhaW4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRlcnJhaW5FdmVudFRyaWdnZXJlZCA9IHRydWU7XG4gICAgICB0ZXJyYWluRXZlbnREYXRhID0ge1xuICAgICAgICB0eXBlOiBcImxvYWRXaXRoVGVycmFpblwiLFxuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHRlcnJhaW46IGV2dC50ZXJyYWluXG4gICAgICB9O1xuICAgICAgdGhpcy5vZmYoXCJ0ZXJyYWluXCIsIHRlcnJhaW5DYWxsYmFjayk7XG4gICAgICBpZiAobG9hZEV2ZW50VHJpZ2dlcmVkKSB7XG4gICAgICAgIHRoaXMuZmlyZShcImxvYWRXaXRoVGVycmFpblwiLCB0ZXJyYWluRXZlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub24oXCJ0ZXJyYWluXCIsIHRlcnJhaW5DYWxsYmFjayk7XG4gICAgaWYgKG9wdGlvbnMudGVycmFpbikge1xuICAgICAgdGhpcy5lbmFibGVUZXJyYWluKFxuICAgICAgICAoX2MgPSBvcHRpb25zLnRlcnJhaW5FeGFnZ2VyYXRpb24pICE9IG51bGwgPyBfYyA6IHRoaXMudGVycmFpbkV4YWdnZXJhdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF3YWl0cyBmb3IgX3RoaXNfIE1hcCBpbnN0YW5jZSB0byBiZSBcImxvYWRlZFwiIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0byB0aGUgTWFwLlxuICAgKiBJZiBfdGhpc18gTWFwIGluc3RhbmNlIGlzIGFscmVhZHkgbG9hZGVkLCB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZCBkaXJlY3RseSxcbiAgICogb3RoZXJ3aXNlLCBpdCBpcyByZXNvbHZlZCBhcyBhIHJlc3VsdCBvZiB0aGUgXCJsb2FkXCIgZXZlbnQuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBvbkxvYWRBc3luYygpIHtcbiAgICByZXR1cm4gX19hc3luYyQxKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBd2FpdHMgZm9yIF90aGlzXyBNYXAgaW5zdGFuY2UgdG8gYmUgXCJyZWFkeVwiIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0byB0aGUgTWFwLlxuICAgKiBJZiBfdGhpc18gTWFwIGluc3RhbmNlIGlzIGFscmVhZHkgcmVhZHksIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkIGRpcmVjdGx5LFxuICAgKiBvdGhlcndpc2UsIGl0IGlzIHJlc29sdmVkIGFzIGEgcmVzdWx0IG9mIHRoZSBcInJlYWR5XCIgZXZlbnQuXG4gICAqIEEgbWFwIGluc3RhbmNlIGlzIFwicmVhZHlcIiB3aGVuIGFsbCB0aGUgY29udHJvbHMgdGhhdCBjYW4gYmUgbWFuYWdlZCBieSB0aGUgY29udHJ1Y3RvciBhcmVcbiAgICogZGVhbHQgd2l0aC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBcImxvYWRcIiBldmVudCwgZHVlIHRvIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlXG4gICAqIG9mIHNvbWUgYnVpbHQtaW4gY29udHJvbHMuXG4gICAqL1xuICBvblJlYWR5QXN5bmMoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmMkMSh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uY2UoXCJyZWFkeVwiLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXdhaXRzIGZvciBfdGhpc18gTWFwIGluc3RhbmNlIHRvIGJlIFwibG9hZGVkXCIgYXMgd2VsbCBhcyB3aXRoIHRlcnJhaW4gYmVpbmcgbm9uLW51bGwgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAqIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0byB0aGUgTWFwLlxuICAgKiBJZiBfdGhpc18gTWFwIGluc3RhbmNlIGlzIGFscmVhZHkgbG9hZGVkIHdpdGggdGVycmFpbiwgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQgZGlyZWN0bHksXG4gICAqIG90aGVyd2lzZSwgaXQgaXMgcmVzb2x2ZWQgYXMgYSByZXN1bHQgb2YgdGhlIFwibG9hZFdpdGhUZXJyYWluXCIgZXZlbnQuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBvbkxvYWRXaXRoVGVycmFpbkFzeW5jKCkge1xuICAgIHJldHVybiBfX2FzeW5jJDEodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1JlYWR5ICYmIHRoaXMudGVycmFpbikge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25jZShcImxvYWRXaXRoVGVycmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdHlsZSBvZiB0aGUgbWFwLlxuICAgKiBDYW4gYmU6XG4gICAqIC0gYSBmdWxsIHN0eWxlIFVSTCAocG9zc2libHkgd2l0aCBBUEkga2V5KVxuICAgKiAtIGEgc2hvcnRoYW5kIHdpdGggb25seSB0aGUgTWFwVElsZXIgc3R5bGUgbmFtZSAoZWcuIGBcInN0cmVldHMtdjJcImApXG4gICAqIC0gYSBsb25nZXIgZm9ybSB3aXRoIHRoZSBwcmVmaXggYFwibWFwdGlsZXI6Ly9cImAgKGVnLiBgXCJtYXB0aWxlcjovL3N0cmVldHMtdjJcImApXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLm1pbmltYXApID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRTdHlsZShzdHlsZSk7XG4gICAgdGhpcy5mb3JjZUxhbmd1YWdlVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uY2UoXCJpZGxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZm9yY2VMYW5ndWFnZVVwZGF0ZSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5zZXRTdHlsZShzdHlsZVRvU3R5bGUoc3R5bGUpLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIFtNYXBMaWJyZSBzdHlsZSBsYXllcl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9sYXllcnMpXG4gICAqIHRvIHRoZSBtYXAncyBzdHlsZS5cbiAgICpcbiAgICogQSBsYXllciBkZWZpbmVzIGhvdyBkYXRhIGZyb20gYSBzcGVjaWZpZWQgc291cmNlIHdpbGwgYmUgc3R5bGVkLiBSZWFkIG1vcmUgYWJvdXQgbGF5ZXIgdHlwZXNcbiAgICogYW5kIGF2YWlsYWJsZSBwYWludCBhbmQgbGF5b3V0IHByb3BlcnRpZXMgaW4gdGhlIFtNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjL2xheWVycykuXG4gICAqXG4gICAqIEBwYXJhbSBsYXllciAtIFRoZSBsYXllciB0byBhZGQsXG4gICAqIGNvbmZvcm1pbmcgdG8gZWl0aGVyIHRoZSBNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uJ3MgW2xheWVyIGRlZmluaXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzKSBvcixcbiAgICogbGVzcyBjb21tb25seSwgdGhlIHtAbGluayBDdXN0b21MYXllckludGVyZmFjZX0gc3BlY2lmaWNhdGlvbi5cbiAgICogVGhlIE1hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb24ncyBsYXllciBkZWZpbml0aW9uIGlzIGFwcHJvcHJpYXRlIGZvciBtb3N0IGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIGJlZm9yZUlkIC0gVGhlIElEIG9mIGFuIGV4aXN0aW5nIGxheWVyIHRvIGluc2VydCB0aGUgbmV3IGxheWVyIGJlZm9yZSxcbiAgICogcmVzdWx0aW5nIGluIHRoZSBuZXcgbGF5ZXIgYXBwZWFyaW5nIHZpc3VhbGx5IGJlbmVhdGggdGhlIGV4aXN0aW5nIGxheWVyLlxuICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBsYXllciB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxheWVycyBhcnJheVxuICAgKiBhbmQgYXBwZWFyIHZpc3VhbGx5IGFib3ZlIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKi9cbiAgYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZUlkKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMubWluaW1hcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFkZExheWVyKGxheWVyLCBiZWZvcmVJZCk7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExheWVyKGxheWVyLCBiZWZvcmVJZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmVzIGEgbGF5ZXIgdG8gYSBkaWZmZXJlbnQgei1wb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBsYXllciB0byBtb3ZlLlxuICAgKiBAcGFyYW0gYmVmb3JlSWQgLSBUaGUgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IHRoZSBuZXcgbGF5ZXIgYmVmb3JlLiBXaGVuIHZpZXdpbmcgdGhlIG1hcCwgdGhlIGBpZGAgbGF5ZXIgd2lsbCBhcHBlYXIgYmVuZWF0aCB0aGUgYGJlZm9yZUlkYCBsYXllci4gSWYgYGJlZm9yZUlkYCBpcyBvbWl0dGVkLCB0aGUgbGF5ZXIgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsYXllcnMgYXJyYXkgYW5kIGFwcGVhciBhYm92ZSBhbGwgb3RoZXIgbGF5ZXJzIG9uIHRoZSBtYXAuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBNb3ZlIGEgbGF5ZXIgd2l0aCBJRCAncG9seWdvbicgYmVmb3JlIHRoZSBsYXllciB3aXRoIElEICdjb3VudHJ5LWxhYmVsJy4gVGhlIGBwb2x5Z29uYCBsYXllciB3aWxsIGFwcGVhciBiZW5lYXRoIHRoZSBgY291bnRyeS1sYWJlbGAgbGF5ZXIgb24gdGhlIG1hcC5cbiAgICogYGBgdHNcbiAgICogbWFwLm1vdmVMYXllcigncG9seWdvbicsICdjb3VudHJ5LWxhYmVsJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgbW92ZUxheWVyKGlkLCBiZWZvcmVJZCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLm1pbmltYXApID09IG51bGwgPyB2b2lkIDAgOiBfYS5tb3ZlTGF5ZXIoaWQsIGJlZm9yZUlkKTtcbiAgICByZXR1cm4gc3VwZXIubW92ZUxheWVyKGlkLCBiZWZvcmVJZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIElEIGZyb20gdGhlIG1hcCdzIHN0eWxlLlxuICAgKlxuICAgKiBBbiB7QGxpbmsgRXJyb3JFdmVudH0gd2lsbCBiZSBmaXJlZCBpZiB0aGUgaW1hZ2UgcGFyYW1ldGVyIGlzIGludmFsZC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBsYXllciB0byByZW1vdmVcbiAgICogQHJldHVybnMgYHRoaXNgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIElmIGEgbGF5ZXIgd2l0aCBJRCAnc3RhdGUtZGF0YScgZXhpc3RzLCByZW1vdmUgaXQuXG4gICAqIGBgYHRzXG4gICAqIGlmIChtYXAuZ2V0TGF5ZXIoJ3N0YXRlLWRhdGEnKSkgbWFwLnJlbW92ZUxheWVyKCdzdGF0ZS1kYXRhJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgcmVtb3ZlTGF5ZXIoaWQpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5taW5pbWFwKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlTGF5ZXIoaWQpO1xuICAgIHJldHVybiBzdXBlci5yZW1vdmVMYXllcihpZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gZXh0ZW50IGZvciB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLiBUaGUgem9vbSBleHRlbnQgaW5jbHVkZXMgdGhlXG4gICAqIFttaW5pbXVtIHpvb20gbGV2ZWxdKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzLyNtaW56b29tKVxuICAgKiBhbmQgW21heGltdW0gem9vbSBsZXZlbF0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9sYXllcnMvI21heHpvb20pKVxuICAgKiBhdCB3aGljaCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZC5cbiAgICpcbiAgICogTm90ZTogRm9yIHN0eWxlIGxheWVycyB1c2luZyB2ZWN0b3Igc291cmNlcywgc3R5bGUgbGF5ZXJzIGNhbm5vdCBiZSByZW5kZXJlZCBhdCB6b29tIGxldmVscyBsb3dlciB0aGFuIHRoZVxuICAgKiBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIF9zb3VyY2UgbGF5ZXJfIGJlY2F1c2UgdGhlIGRhdGEgZG9lcyBub3QgZXhpc3QgYXQgdGhvc2Ugem9vbSBsZXZlbHMuIElmIHRoZSBtaW5pbXVtXG4gICAqIHpvb20gbGV2ZWwgb2YgdGhlIHNvdXJjZSBsYXllciBpcyBoaWdoZXIgdGhhbiB0aGUgbWluaW11bSB6b29tIGxldmVsIGRlZmluZWQgaW4gdGhlIHN0eWxlIGxheWVyLCB0aGUgc3R5bGVcbiAgICogbGF5ZXIgd2lsbCBub3QgYmUgcmVuZGVyZWQgYXQgYWxsIHpvb20gbGV2ZWxzIGluIHRoZSB6b29tIHJhbmdlLlxuICAgKi9cbiAgc2V0TGF5ZXJab29tUmFuZ2UobGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLm1pbmltYXApID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRMYXllclpvb21SYW5nZShsYXllcklkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgICByZXR1cm4gc3VwZXIuc2V0TGF5ZXJab29tUmFuZ2UobGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbHRlciBmb3IgdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICpcbiAgICogRmlsdGVycyBjb250cm9sIHdoaWNoIGZlYXR1cmVzIGEgc3R5bGUgbGF5ZXIgcmVuZGVycyBmcm9tIGl0cyBzb3VyY2UuXG4gICAqIEFueSBmZWF0dXJlIGZvciB3aGljaCB0aGUgZmlsdGVyIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCB3aWxsIGJlXG4gICAqIHJlbmRlcmVkIG9uIHRoZSBtYXAuIFRob3NlIHRoYXQgYXJlIGZhbHNlIHdpbGwgYmUgaGlkZGVuLlxuICAgKlxuICAgKiBVc2UgYHNldEZpbHRlcmAgdG8gc2hvdyBhIHN1YnNldCBvZiB5b3VyIHNvdXJjZSBkYXRhLlxuICAgKlxuICAgKiBUbyBjbGVhciB0aGUgZmlsdGVyLCBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cbiAgICovXG4gIHNldEZpbHRlcihsYXllcklkLCBmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5taW5pbWFwKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0RmlsdGVyKGxheWVySWQsIGZpbHRlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN1cGVyLnNldEZpbHRlcihsYXllcklkLCBmaWx0ZXIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHBhaW50IHByb3BlcnR5IGluIHRoZSBzcGVjaWZpZWQgc3R5bGUgbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBsYXllcklkIC0gVGhlIElEIG9mIHRoZSBsYXllciB0byBzZXQgdGhlIHBhaW50IHByb3BlcnR5IGluLlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYWludCBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFpbnQgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBNdXN0IGJlIG9mIGEgdHlwZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHByb3BlcnR5LCBhcyBkZWZpbmVkIGluIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy8pLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBgdGhpc2BcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogbWFwLnNldFBhaW50UHJvcGVydHkoJ215LWxheWVyJywgJ2ZpbGwtY29sb3InLCAnI2ZhYWZlZScpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldFBhaW50UHJvcGVydHkobGF5ZXJJZCwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5taW5pbWFwKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0UGFpbnRQcm9wZXJ0eShsYXllcklkLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN1cGVyLnNldFBhaW50UHJvcGVydHkobGF5ZXJJZCwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGxheW91dCBwcm9wZXJ0eSBpbiB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLlxuICAgKiBMYXlvdXQgcHJvcGVydGllcyBkZWZpbmUgaG93IHRoZSBsYXllciBpcyBzdHlsZWQuXG4gICAqIExheW91dCBwcm9wZXJ0aWVzIGZvciBsYXllcnMgb2YgdGhlIHNhbWUgdHlwZSBhcmUgZG9jdW1lbnRlZCB0b2dldGhlci5cbiAgICogTGF5ZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBoYXZlIGRpZmZlcmVudCBsYXlvdXQgcHJvcGVydGllcy5cbiAgICogU2VlIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy8pIGZvciB0aGUgY29tcGxldGUgbGlzdCBvZiBsYXlvdXQgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIGxheWVySWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHNldCB0aGUgbGF5b3V0IHByb3BlcnR5IGluLlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXlvdXQgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIE11c3QgYmUgb2YgYSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHksIGFzIGRlZmluZWQgaW4gdGhlIFtNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjLykuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKi9cbiAgc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJJZCwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5taW5pbWFwKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJJZCwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdXBlci5zZXRMYXlvdXRQcm9wZXJ0eShsYXllcklkLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzdHlsZSdzIGdseXBocyBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIGdseXBoc1VybCAtIEdseXBoIFVSTCB0byBzZXQuIE11c3QgY29uZm9ybSB0byB0aGUgW01hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvZ2x5cGhzLykuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBtYXAuc2V0R2x5cGhzKCdodHRwczovL2RlbW90aWxlcy5tYXBsaWJyZS5vcmcvZm9udC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZicpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEdseXBocyhnbHlwaHNVcmwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5taW5pbWFwKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0R2x5cGhzKGdseXBoc1VybCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN1cGVyLnNldEdseXBocyhnbHlwaHNVcmwsIG9wdGlvbnMpO1xuICB9XG4gIGdldFN0eWxlTGFuZ3VhZ2UoKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodHlwZW9mIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5tZXRhZGF0YSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChcIm1hcHRpbGVyOmxhbmd1YWdlXCIgaW4gdGhpcy5zdHlsZS5zdHlsZXNoZWV0Lm1ldGFkYXRhICYmIHR5cGVvZiB0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGFbXCJtYXB0aWxlcjpsYW5ndWFnZVwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5tZXRhZGF0YVtcIm1hcHRpbGVyOmxhbmd1YWdlXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgcHJpbWFyeSBsYW5ndWFnZSBvZiB0aGUgbWFwLiBOb3RlIHRoYXQgbm90IGFsbCB0aGUgbGFuZ3VhZ2VzIHNob3J0aGFuZHMgcHJvdmlkZWQgYXJlIGF2YWlsYWJsZS5cbiAgICovXG4gIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2IgPSAoX2EgPSB0aGlzLm1pbmltYXApID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXApID09IG51bGwgPyB2b2lkIDAgOiBfYi5zZXRMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgdGhpcy5vblN0eWxlUmVhZHkoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRQcmltYXJ5TGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIHByaW1hcnkgbGFuZ3VhZ2Ugb2YgdGhlIG1hcC4gTm90ZSB0aGF0IG5vdCBhbGwgdGhlIGxhbmd1YWdlcyBzaG9ydGhhbmRzIHByb3ZpZGVkIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzZXRQcmltYXJ5TGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcbiAgICBjb25zdCBzdHlsZUxhbmd1YWdlID0gdGhpcy5nZXRTdHlsZUxhbmd1YWdlKCk7XG4gICAgaWYgKCEobGFuZ3VhZ2UgPT09IExhbmd1YWdlLlNUWUxFICYmIChzdHlsZUxhbmd1YWdlID09PSBMYW5ndWFnZS5BVVRPIHx8IHN0eWxlTGFuZ3VhZ2UgPT09IExhbmd1YWdlLlZJU0lUT1IpKSkge1xuICAgICAgaWYgKGxhbmd1YWdlICE9PSBMYW5ndWFnZS5TVFlMRSkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlQWx3YXlzQmVlblN0eWxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYW5ndWFnZUFsd2F5c0JlZW5TdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPT09IGxhbmd1YWdlICYmICF0aGlzLmZvcmNlTGFuZ3VhZ2VVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTGFuZ3VhZ2VTdXBwb3J0ZWQobGFuZ3VhZ2UpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBsYW5ndWFnZSBcIiR7bGFuZ3VhZ2V9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSBMYW5ndWFnZS5TVFlMRV9MT0NLKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlIGxhbmd1YWdlIGNhbm5vdCBiZSBjaGFuZ2VkIGJlY2F1c2UgdGhpcyBtYXAgaGFzIGJlZW4gaW5zdGFudGlhdGVkIHdpdGggdGhlIFNUWUxFX0xPQ0sgbGFuZ3VhZ2UgZmxhZy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICBsZXQgbGFuZ3VhZ2VOb25TdHlsZSA9IGxhbmd1YWdlO1xuICAgIGlmIChsYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuU1RZTEUpIHtcbiAgICAgIGlmICghc3R5bGVMYW5ndWFnZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgc3R5bGUgaGFzIG5vIGRlZmF1bHQgbGFuZ3VhZ2VzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xhbmd1YWdlU3VwcG9ydGVkKHN0eWxlTGFuZ3VhZ2UpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBsYW5ndWFnZSBkZWZpbmVkIGluIHRoZSBzdHlsZSBpcyBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYW5ndWFnZU5vblN0eWxlID0gc3R5bGVMYW5ndWFnZTtcbiAgICB9XG4gICAgbGV0IGxhbmdTdHIgPSBMYW5ndWFnZS5MT0NBTDtcbiAgICBsZXQgcmVwbGFjZXIgPSBgeyR7bGFuZ1N0cn19YDtcbiAgICBpZiAobGFuZ3VhZ2VOb25TdHlsZSA9PSBMYW5ndWFnZS5WSVNJVE9SKSB7XG4gICAgICBsYW5nU3RyID0gZ2V0QnJvd3Nlckxhbmd1YWdlKCk7XG4gICAgICByZXBsYWNlciA9IFtcbiAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgIFtcImFsbFwiLCBbXCJoYXNcIiwgbGFuZ1N0cl0sIFtcImhhc1wiLCBMYW5ndWFnZS5MT0NBTF1dLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgICAgW1wiPT1cIiwgW1wiZ2V0XCIsIGxhbmdTdHJdLCBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdXSxcbiAgICAgICAgICBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICBbXCJnZXRcIiwgbGFuZ1N0cl0sXG4gICAgICAgICAgICB7IFwiZm9udC1zY2FsZVwiOiAwLjggfSxcbiAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdLFxuICAgICAgICAgICAgeyBcImZvbnQtc2NhbGVcIjogMS4xIH1cbiAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgIFtcImdldFwiLCBMYW5ndWFnZS5MT0NBTF1cbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChsYW5ndWFnZU5vblN0eWxlID09IExhbmd1YWdlLlZJU0lUT1JfRU5HTElTSCkge1xuICAgICAgbGFuZ1N0ciA9IExhbmd1YWdlLkVOR0xJU0g7XG4gICAgICByZXBsYWNlciA9IFtcbiAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgIFtcImFsbFwiLCBbXCJoYXNcIiwgbGFuZ1N0cl0sIFtcImhhc1wiLCBMYW5ndWFnZS5MT0NBTF1dLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgICAgW1wiPT1cIiwgW1wiZ2V0XCIsIGxhbmdTdHJdLCBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdXSxcbiAgICAgICAgICBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICBbXCJnZXRcIiwgbGFuZ1N0cl0sXG4gICAgICAgICAgICB7IFwiZm9udC1zY2FsZVwiOiAwLjggfSxcbiAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdLFxuICAgICAgICAgICAgeyBcImZvbnQtc2NhbGVcIjogMS4xIH1cbiAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgIFtcImdldFwiLCBMYW5ndWFnZS5MT0NBTF1cbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChsYW5ndWFnZU5vblN0eWxlID09PSBMYW5ndWFnZS5BVVRPKSB7XG4gICAgICBsYW5nU3RyID0gZ2V0QnJvd3Nlckxhbmd1YWdlKCk7XG4gICAgICByZXBsYWNlciA9IFtcbiAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgIFtcImhhc1wiLCBsYW5nU3RyXSxcbiAgICAgICAgW1wiZ2V0XCIsIGxhbmdTdHJdLFxuICAgICAgICBbXCJnZXRcIiwgTGFuZ3VhZ2UuTE9DQUxdXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2VOb25TdHlsZSA9PT0gTGFuZ3VhZ2UuTE9DQUwpIHtcbiAgICAgIGxhbmdTdHIgPSBMYW5ndWFnZS5MT0NBTDtcbiAgICAgIHJlcGxhY2VyID0gYHske2xhbmdTdHJ9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbmdTdHIgPSBsYW5ndWFnZU5vblN0eWxlO1xuICAgICAgcmVwbGFjZXIgPSBbXG4gICAgICAgIFwiY2FzZVwiLFxuICAgICAgICBbXCJoYXNcIiwgbGFuZ1N0cl0sXG4gICAgICAgIFtcImdldFwiLCBsYW5nU3RyXSxcbiAgICAgICAgW1wiZ2V0XCIsIExhbmd1YWdlLkxPQ0FMXVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgeyBsYXllcnMgfSA9IHRoaXMuZ2V0U3R5bGUoKTtcbiAgICBmb3IgKGNvbnN0IHsgaWQsIGxheW91dCB9IG9mIGxheWVycykge1xuICAgICAgaWYgKCFsYXlvdXQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIShcInRleHQtZmllbGRcIiBpbiBsYXlvdXQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dEZpZWxkTGF5b3V0UHJvcCA9IHRoaXMuZ2V0TGF5b3V0UHJvcGVydHkoaWQsIFwidGV4dC1maWVsZFwiKTtcbiAgICAgIGlmICh0eXBlb2YgdGV4dEZpZWxkTGF5b3V0UHJvcCA9PT0gXCJzdHJpbmdcIiAmJiAodGV4dEZpZWxkTGF5b3V0UHJvcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicmVmXCIpIHx8IHRleHRGaWVsZExheW91dFByb3AudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImhvdXNlbnVtYmVyXCIpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TGF5b3V0UHJvcGVydHkoaWQsIFwidGV4dC1maWVsZFwiLCByZXBsYWNlcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaW1hcnkgbGFuZ3VhZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFByaW1hcnlMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5TGFuZ3VhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZXhhZ2dlcmF0aW9uIGZhY3RvciBhcHBsaWVkIHRvIHRoZSB0ZXJyYWluXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUZXJyYWluRXhhZ2dlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIEtub3cgaWYgdGVycmlhbiBpcyBlbmFibGVkIG9yIG5vdFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVGVycmFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RlcnJhaW5FbmFibGVkO1xuICB9XG4gIGdyb3dUZXJyYWluKGV4YWdnZXJhdGlvbiwgZHVyYXRpb25NcyA9IDFlMykge1xuICAgIGlmICghdGhpcy50ZXJyYWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGN1cnJlbnRFeGFnZ2VyYXRpb24gPSB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uO1xuICAgIGNvbnN0IGRlbHRhRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uIC0gY3VycmVudEV4YWdnZXJhdGlvbjtcbiAgICBjb25zdCB1cGRhdGVFeGFnZ2VyYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudGVycmFpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXJyYWluRmxhdHRlbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NpdGlvbkluTG9vcCA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbk1zO1xuICAgICAgaWYgKHBvc2l0aW9uSW5Mb29wIDwgMC45OSkge1xuICAgICAgICBjb25zdCBleGFnZ2VyYXRpb25GYWN0b3IgPSAxIC0gTWF0aC5wb3coMSAtIHBvc2l0aW9uSW5Mb29wLCA0KTtcbiAgICAgICAgY29uc3QgbmV3RXhhZ2dlcmF0aW9uID0gY3VycmVudEV4YWdnZXJhdGlvbiArIGV4YWdnZXJhdGlvbkZhY3RvciAqIGRlbHRhRXhhZ2dlcmF0aW9uO1xuICAgICAgICB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gbmV3RXhhZ2dlcmF0aW9uO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRXhhZ2dlcmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVycmFpbkdyb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXJyYWluRmxhdHRlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyUmVwYWludCgpO1xuICAgIH07XG4gICAgdGhpcy50ZXJyYWluR3Jvd2luZyA9IHRydWU7XG4gICAgdGhpcy50ZXJyYWluRmxhdHRlbmluZyA9IGZhbHNlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVFeGFnZ2VyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSAzRCB0ZXJyYWluIHZpc3VhbGl6YXRpb25cbiAgICovXG4gIGVuYWJsZVRlcnJhaW4oZXhhZ2dlcmF0aW9uID0gdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uKSB7XG4gICAgaWYgKGV4YWdnZXJhdGlvbiA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRlcnJhaW4gZXhhZ2dlcmF0aW9uIGNhbm5vdCBiZSBuZWdhdGl2ZS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGFFdmVudFRlcnJhaW5Hcm93ID0gKGV2dCkgPT4gX19hc3luYyQxKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMudGVycmFpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LnR5cGUgIT09IFwiZGF0YVwiIHx8IGV2dC5kYXRhVHlwZSAhPT0gXCJzb3VyY2VcIiB8fCAhKFwic291cmNlXCIgaW4gZXZ0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LnNvdXJjZUlkICE9PSBcIm1hcHRpbGVyLXRlcnJhaW5cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzb3VyY2UgPSBldnQuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZS50eXBlICE9PSBcInJhc3Rlci1kZW1cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWV2dC5pc1NvdXJjZUxvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9mZihcImRhdGFcIiwgZGF0YUV2ZW50VGVycmFpbkdyb3cpO1xuICAgICAgdGhpcy5ncm93VGVycmFpbihleGFnZ2VyYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IGFkZFRlcnJhaW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzVGVycmFpbkVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uO1xuICAgICAgdGhpcy5vbihcImRhdGFcIiwgZGF0YUV2ZW50VGVycmFpbkdyb3cpO1xuICAgICAgdGhpcy5hZGRTb3VyY2UoZGVmYXVsdHMudGVycmFpblNvdXJjZUlkLCB7XG4gICAgICAgIHR5cGU6IFwicmFzdGVyLWRlbVwiLFxuICAgICAgICB1cmw6IGRlZmF1bHRzLnRlcnJhaW5Tb3VyY2VVUkxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRUZXJyYWluKHtcbiAgICAgICAgc291cmNlOiBkZWZhdWx0cy50ZXJyYWluU291cmNlSWQsXG4gICAgICAgIGV4YWdnZXJhdGlvbjogMFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5nZXRUZXJyYWluKCkpIHtcbiAgICAgIHRoaXMuaXNUZXJyYWluRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmdyb3dUZXJyYWluKGV4YWdnZXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmxvYWRlZCgpIHx8IHRoaXMuaXNUZXJyYWluRW5hYmxlZCkge1xuICAgICAgYWRkVGVycmFpbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGVycmFpbigpICYmIHRoaXMuZ2V0U291cmNlKGRlZmF1bHRzLnRlcnJhaW5Tb3VyY2VJZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRkVGVycmFpbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSAzRCB0ZXJyYWluIHZpc3VhbGl6YXRpb25cbiAgICovXG4gIGRpc2FibGVUZXJyYWluKCkge1xuICAgIGlmICghdGhpcy50ZXJyYWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNUZXJyYWluRW5hYmxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFuaW1hdGlvbkxvb3BEdXJhdGlvbiA9IDEgKiAxZTM7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgY3VycmVudEV4YWdnZXJhdGlvbiA9IHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb247XG4gICAgY29uc3QgdXBkYXRlRXhhZ2dlcmF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnRlcnJhaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGVycmFpbkdyb3dpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zaXRpb25Jbkxvb3AgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUpIC8gYW5pbWF0aW9uTG9vcER1cmF0aW9uO1xuICAgICAgaWYgKHBvc2l0aW9uSW5Mb29wIDwgMC45OSkge1xuICAgICAgICBjb25zdCBleGFnZ2VyYXRpb25GYWN0b3IgPSBNYXRoLnBvdygxIC0gcG9zaXRpb25Jbkxvb3AsIDQpO1xuICAgICAgICBjb25zdCBuZXdFeGFnZ2VyYXRpb24gPSBjdXJyZW50RXhhZ2dlcmF0aW9uICogZXhhZ2dlcmF0aW9uRmFjdG9yO1xuICAgICAgICB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gbmV3RXhhZ2dlcmF0aW9uO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRXhhZ2dlcmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLnRlcnJhaW5Hcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGVycmFpbkZsYXR0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRUZXJyYWluKCk7XG4gICAgICAgIGlmICh0aGlzLmdldFNvdXJjZShkZWZhdWx0cy50ZXJyYWluU291cmNlSWQpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTb3VyY2UoZGVmYXVsdHMudGVycmFpblNvdXJjZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyUmVwYWludCgpO1xuICAgIH07XG4gICAgdGhpcy50ZXJyYWluR3Jvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMudGVycmFpbkZsYXR0ZW5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVFeGFnZ2VyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSAzRCB0ZXJyYWluIGV4YWdlcmF0aW9uIGZhY3Rvci5cbiAgICogSWYgdGhlIHRlcnJhaW4gd2FzIG5vdCBlbmFibGVkIHByaW9yIHRvIHRoZSBjYWxsIG9mIHRoaXMgbWV0aG9kLFxuICAgKiB0aGUgbWV0aG9kIGAuZW5hYmxlVGVycmFpbigpYCB3aWxsIGJlIGNhbGxlZC5cbiAgICogSWYgYGFuaW1hdGVgIGlzIGB0cnVlYCwgdGhlIHRlcnJhaW4gdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBhbmltYXRlZCBpbiB0aGUgc3BhbiBvZiAxIHNlY29uZC5cbiAgICogSWYgYGFuaW1hdGVgIGlzIGBmYWxzZWAsIG5vIGFuaW1hdGVkIHRyYW5zaXRpb24gdG8gdGhlIG5ld2x5IGRlZmluZWQgZXhhZ2dlcmF0aW9uLlxuICAgKi9cbiAgc2V0VGVycmFpbkV4YWdnZXJhdGlvbihleGFnZ2VyYXRpb24sIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgaWYgKCFhbmltYXRlICYmIHRoaXMudGVycmFpbikge1xuICAgICAgdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uO1xuICAgICAgdGhpcy50ZXJyYWluLmV4YWdnZXJhdGlvbiA9IGV4YWdnZXJhdGlvbjtcbiAgICAgIHRoaXMudHJpZ2dlclJlcGFpbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGVUZXJyYWluKGV4YWdnZXJhdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIGFjdGlvbiB3aGVuIHRoZSBzdHlsZSBpcyByZWFkeS4gSXQgY291bGQgYmUgYXQgdGhlIG1vbWVudCBvZiBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIG9yIGxhdGVyLlxuICAgKi9cbiAgb25TdHlsZVJlYWR5KGNiKSB7XG4gICAgaWYgKHRoaXMuaXNTdHlsZUxvYWRlZCgpKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2UoXCJzdHlsZWRhdGFcIiwgKCkgPT4ge1xuICAgICAgICBjYigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZpdFRvSXBCb3VuZHMoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmMkMSh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgaXBHZW9sb2NhdGVSZXN1bHQgPSB5aWVsZCBnZW9sb2NhdGlvbi5pbmZvKCk7XG4gICAgICB0aGlzLmZpdEJvdW5kcyhcbiAgICAgICAgaXBHZW9sb2NhdGVSZXN1bHQuY291bnRyeV9ib3VuZHMsXG4gICAgICAgIHtcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBwYWRkaW5nOiAxMDBcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBjZW50ZXJPbklwUG9pbnQoem9vbSkge1xuICAgIHJldHVybiBfX2FzeW5jJDEodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBpcEdlb2xvY2F0ZVJlc3VsdCA9IHlpZWxkIGdlb2xvY2F0aW9uLmluZm8oKTtcbiAgICAgIHRoaXMuanVtcFRvKHtcbiAgICAgICAgY2VudGVyOiBbXG4gICAgICAgICAgKF9hID0gaXBHZW9sb2NhdGVSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IGlwR2VvbG9jYXRlUmVzdWx0LmxvbmdpdHVkZSkgIT0gbnVsbCA/IF9hIDogMCxcbiAgICAgICAgICAoX2IgPSBpcEdlb2xvY2F0ZVJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogaXBHZW9sb2NhdGVSZXN1bHQubGF0aXR1ZGUpICE9IG51bGwgPyBfYiA6IDBcbiAgICAgICAgXSxcbiAgICAgICAgem9vbTogem9vbSB8fCAxMVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FtZXJhSGFzaCgpIHtcbiAgICBjb25zdCBoYXNoQmluID0gbmV3IEZsb2F0MzJBcnJheSg1KTtcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuICAgIGhhc2hCaW5bMF0gPSBjZW50ZXIubG5nO1xuICAgIGhhc2hCaW5bMV0gPSBjZW50ZXIubGF0O1xuICAgIGhhc2hCaW5bMl0gPSB0aGlzLmdldFpvb20oKTtcbiAgICBoYXNoQmluWzNdID0gdGhpcy5nZXRQaXRjaCgpO1xuICAgIGhhc2hCaW5bNF0gPSB0aGlzLmdldEJlYXJpbmcoKTtcbiAgICByZXR1cm4gQmFzZTY0LmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGhhc2hCaW4uYnVmZmVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgU0RLIGNvbmZpZyBvYmplY3QuXG4gICAqIFRoaXMgaXMgY29udmVuaWVudCB0byBkaXNwYXRjaCB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gdG8gZXh0ZXJuYWxseSBidWlsdCBsYXllcnNcbiAgICogdGhhdCBkbyBub3QgZGlyZWN0bHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIFNESyBjb25maWd1cmF0aW9uIGJ1dCBkbyBoYXZlIGFjY2VzcyB0byBhIE1hcCBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNka0NvbmZpZygpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIHNlc3Npb24gSUQuIENvbnZlbmllbnQgdG8gZGlzcGF0Y2ggdG8gZXh0ZXJuYWx5IGJ1aWx0IGNvbXBvbmVudFxuICAgKiB0aGF0IGRvIG5vdCBkaXJlY3RseSBoYXZlIGFjY2VzcyB0byB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gYnV0IGRvIGhhdmUgYWNjZXNzIHRvIGEgTWFwIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0TWFwdGlsZXJTZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIE1BUFRJTEVSX1NFU1NJT05fSUQ7XG4gIH1cbiAgLyoqXG4gICAqICBVcGRhdGVzIHRoZSByZXF1ZXN0TWFuYWdlcidzIHRyYW5zZm9ybSByZXF1ZXN0IHdpdGggYSBuZXcgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1SZXF1ZXN0IEEgY2FsbGJhY2sgcnVuIGJlZm9yZSB0aGUgTWFwIG1ha2VzIGEgcmVxdWVzdCBmb3IgYW4gZXh0ZXJuYWwgVVJMLiBUaGUgY2FsbGJhY2sgY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHRoZSB1cmwsIHNldCBoZWFkZXJzLCBvciBzZXQgdGhlIGNyZWRlbnRpYWxzIHByb3BlcnR5IGZvciBjcm9zcy1vcmlnaW4gcmVxdWVzdHMuXG4gICAqICAgIEV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIGB1cmxgIHByb3BlcnR5IGFuZCBvcHRpb25hbGx5IGBoZWFkZXJzYCBhbmQgYGNyZWRlbnRpYWxzYCBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgKlxuICAgKiAgQGV4YW1wbGVcbiAgICogIG1hcC5zZXRUcmFuc2Zvcm1SZXF1ZXN0KCh1cmw6IHN0cmluZywgcmVzb3VyY2VUeXBlOiBzdHJpbmcpID0+IHt9KTtcbiAgICovXG4gIHNldFRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtUmVxdWVzdCkge1xuICAgIHN1cGVyLnNldFRyYW5zZm9ybVJlcXVlc3QoY29tYmluZVRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtUmVxdWVzdCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBhbiBpbWFnZS4gVGhpcyBpcyBhbiBhc3luYyBlcXVpdmFsZW50IG9mIGBNYXAubG9hZEltYWdlYFxuICAgKi9cbiAgbG9hZEltYWdlQXN5bmModXJsKSB7XG4gICAgcmV0dXJuIF9fYXN5bmMkMSh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2UoXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIChlcnJvciwgaW1hZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBNYXJrZXIgZXh0ZW5kcyBtYXBsaWJyZWdsX19kZWZhdWx0Lk1hcmtlciB7XG4gIGFkZFRvKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5hZGRUbyhtYXApO1xuICB9XG59XG5cbmNsYXNzIFBvcHVwIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5Qb3B1cCB7XG4gIGFkZFRvKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5hZGRUbyhtYXApO1xuICB9XG59XG5cbmNsYXNzIFN0eWxlIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5TdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG1hcCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIobWFwLCBvcHRpb25zKTtcbiAgfVxufVxuXG5jbGFzcyBDYW52YXNTb3VyY2UgZXh0ZW5kcyBtYXBsaWJyZWdsX19kZWZhdWx0LkNhbnZhc1NvdXJjZSB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHN1cGVyLm9uQWRkKG1hcCk7XG4gIH1cbn1cblxuY2xhc3MgR2VvSlNPTlNvdXJjZSBleHRlbmRzIG1hcGxpYnJlZ2xfX2RlZmF1bHQuR2VvSlNPTlNvdXJjZSB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHN1cGVyLm9uQWRkKG1hcCk7XG4gIH1cbn1cblxuY2xhc3MgSW1hZ2VTb3VyY2UgZXh0ZW5kcyBtYXBsaWJyZWdsX19kZWZhdWx0LkltYWdlU291cmNlIHtcbiAgb25BZGQobWFwKSB7XG4gICAgc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG5jbGFzcyBSYXN0ZXJUaWxlU291cmNlIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5SYXN0ZXJUaWxlU291cmNlIHtcbiAgb25BZGQobWFwKSB7XG4gICAgc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG5jbGFzcyBSYXN0ZXJERU1UaWxlU291cmNlIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5SYXN0ZXJERU1UaWxlU291cmNlIHtcbiAgb25BZGQobWFwKSB7XG4gICAgc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG5jbGFzcyBWZWN0b3JUaWxlU291cmNlIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5WZWN0b3JUaWxlU291cmNlIHtcbiAgb25BZGQobWFwKSB7XG4gICAgc3VwZXIub25BZGQobWFwKTtcbiAgfVxufVxuXG5jbGFzcyBWaWRlb1NvdXJjZSBleHRlbmRzIG1hcGxpYnJlZ2xfX2RlZmF1bHQuVmlkZW9Tb3VyY2Uge1xuICBvbkFkZChtYXApIHtcbiAgICBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbmNsYXNzIFRlcnJhaW5Db250cm9sIGV4dGVuZHMgbWFwbGlicmVnbF9fZGVmYXVsdC5UZXJyYWluQ29udHJvbCB7XG4gIG9uQWRkKG1hcCkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChtYXApO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMyhvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ4XCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInlcIik7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIF9tYXRNdWx0KG0pIHtcbiAgICBjb25zdCB4ID0gbVswXSAqIHRoaXMueCArIG1bMV0gKiB0aGlzLnk7XG4gICAgY29uc3QgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfYWRkKHApIHtcbiAgICB0aGlzLnggKz0gcC54O1xuICAgIHRoaXMueSArPSBwLnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3N1YihwKSB7XG4gICAgdGhpcy54IC09IHAueDtcbiAgICB0aGlzLnkgLT0gcC55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9tdWx0KGspIHtcbiAgICB0aGlzLnggKj0gaztcbiAgICB0aGlzLnkgKj0gaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZGl2KGspIHtcbiAgICB0aGlzLnggLz0gaztcbiAgICB0aGlzLnkgLz0gaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfbXVsdEJ5UG9pbnQocCkge1xuICAgIHRoaXMueCAqPSBwLng7XG4gICAgdGhpcy55ICo9IHAueTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZGl2QnlQb2ludChwKSB7XG4gICAgdGhpcy54IC89IHAueDtcbiAgICB0aGlzLnkgLz0gcC55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF91bml0KCkge1xuICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcGVycCgpIHtcbiAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICB0aGlzLnggPSAteTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB4ID0gY29zICogdGhpcy54IC0gc2luICogdGhpcy55O1xuICAgIGNvbnN0IHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9yb3RhdGVBcm91bmQoYW5nbGUsIHApIHtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHggPSBwLnggKyBjb3MgKiAodGhpcy54IC0gcC54KSAtIHNpbiAqICh0aGlzLnkgLSBwLnkpO1xuICAgIGNvbnN0IHkgPSBwLnkgKyBzaW4gKiAodGhpcy54IC0gcC54KSArIGNvcyAqICh0aGlzLnkgLSBwLnkpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcm91bmQoKSB7XG4gICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhpcyBwb2ludCwgcmV0dXJuaW5nIGEgbmV3IHBvaW50IHRoYXQgY2FuIGJlIG1vZGlmaWVkXG4gICAqIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBvbGQgb25lLlxuICAgKiBAcmV0dXJuIHtQb2ludH0gdGhlIGNsb25lXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICAvKipcbiAgICogQWRkIHRoaXMgcG9pbnQncyB4ICYgeSBjb29yZGluYXRlcyB0byBhbm90aGVyIHBvaW50LFxuICAgKiB5aWVsZGluZyBhIG5ldyBwb2ludC5cbiAgICogQHBhcmFtIHtQb2ludH0gcCB0aGUgb3RoZXIgcG9pbnRcbiAgICogQHJldHVybiB7UG9pbnR9IG91dHB1dCBwb2ludFxuICAgKi9cbiAgYWRkKHApIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnRyYWN0IHRoaXMgcG9pbnQncyB4ICYgeSBjb29yZGluYXRlcyB0byBmcm9tIHBvaW50LFxuICAgKiB5aWVsZGluZyBhIG5ldyBwb2ludC5cbiAgICogQHBhcmFtIHtQb2ludH0gcCB0aGUgb3RoZXIgcG9pbnRcbiAgICogQHJldHVybiB7UG9pbnR9IG91dHB1dCBwb2ludFxuICAgKi9cbiAgc3ViKHApIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIocCk7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgcG9pbnQncyB4ICYgeSBjb29yZGluYXRlcyBieSBwb2ludCxcbiAgICogeWllbGRpbmcgYSBuZXcgcG9pbnQuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAgdGhlIG90aGVyIHBvaW50XG4gICAqIEByZXR1cm4ge1BvaW50fSBvdXRwdXQgcG9pbnRcbiAgICovXG4gIG11bHRCeVBvaW50KHApIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0QnlQb2ludChwKTtcbiAgfVxuICAvKipcbiAgICogRGl2aWRlIHRoaXMgcG9pbnQncyB4ICYgeSBjb29yZGluYXRlcyBieSBwb2ludCxcbiAgICogeWllbGRpbmcgYSBuZXcgcG9pbnQuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAgdGhlIG90aGVyIHBvaW50XG4gICAqIEByZXR1cm4ge1BvaW50fSBvdXRwdXQgcG9pbnRcbiAgICovXG4gIGRpdkJ5UG9pbnQocCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2RpdkJ5UG9pbnQocCk7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgcG9pbnQncyB4ICYgeSBjb29yZGluYXRlcyBieSBhIGZhY3RvcixcbiAgICogeWllbGRpbmcgYSBuZXcgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBrIGZhY3RvclxuICAgKiBAcmV0dXJuIHtQb2ludH0gb3V0cHV0IHBvaW50XG4gICAqL1xuICBtdWx0KGspIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspO1xuICB9XG4gIC8qKlxuICAgKiBEaXZpZGUgdGhpcyBwb2ludCdzIHggJiB5IGNvb3JkaW5hdGVzIGJ5IGEgZmFjdG9yLFxuICAgKiB5aWVsZGluZyBhIG5ldyBwb2ludC5cbiAgICogQHBhcmFtIHtQb2ludH0gayBmYWN0b3JcbiAgICogQHJldHVybiB7UG9pbnR9IG91dHB1dCBwb2ludFxuICAgKi9cbiAgZGl2KGspIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7XG4gIH1cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGlzIHBvaW50IGFyb3VuZCB0aGUgMCwgMCBvcmlnaW4gYnkgYW4gYW5nbGUgYSxcbiAgICogZ2l2ZW4gaW4gcmFkaWFuc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYSBhbmdsZSB0byByb3RhdGUgYXJvdW5kLCBpbiByYWRpYW5zXG4gICAqIEByZXR1cm4ge1BvaW50fSBvdXRwdXQgcG9pbnRcbiAgICovXG4gIHJvdGF0ZShhKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpO1xuICB9XG4gIC8qKlxuICAgKiBSb3RhdGUgdGhpcyBwb2ludCBhcm91bmQgcCBwb2ludCBieSBhbiBhbmdsZSBhLFxuICAgKiBnaXZlbiBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQsIGluIHJhZGlhbnNcbiAgICogQHBhcmFtIHtQb2ludH0gcCBQb2ludCB0byByb3RhdGUgYXJvdW5kXG4gICAqIEByZXR1cm4ge1BvaW50fSBvdXRwdXQgcG9pbnRcbiAgICovXG4gIHJvdGF0ZUFyb3VuZChhLCBwKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlQXJvdW5kKGEsIHApO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIHBvaW50IGJ5IGEgNHgxIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IG0gdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAqIEByZXR1cm4ge1BvaW50fSBvdXRwdXQgcG9pbnRcbiAgICovXG4gIG1hdE11bHQobSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGlzIHBvaW50IGJ1dCBhcyBhIHVuaXQgdmVjdG9yIGZyb20gMCwgMCwgbWVhbmluZ1xuICAgKiB0aGF0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByZXN1bHRpbmcgcG9pbnQgdG8gdGhlIDAsIDBcbiAgICogY29vcmRpbmF0ZSB3aWxsIGJlIGVxdWFsIHRvIDEgYW5kIHRoZSBhbmdsZSBmcm9tIHRoZSByZXN1bHRpbmdcbiAgICogcG9pbnQgdG8gdGhlIDAsIDAgY29vcmRpbmF0ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIGJlZm9yZS5cbiAgICogQHJldHVybiB7UG9pbnR9IHVuaXQgdmVjdG9yIHBvaW50XG4gICAqL1xuICB1bml0KCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTtcbiAgfVxuICAvKipcbiAgICogQ29tcHV0ZSBhIHBlcnBlbmRpY3VsYXIgcG9pbnQsIHdoZXJlIHRoZSBuZXcgeSBjb29yZGluYXRlXG4gICAqIGlzIHRoZSBvbGQgeCBjb29yZGluYXRlIGFuZCB0aGUgbmV3IHggY29vcmRpbmF0ZSBpcyB0aGUgb2xkIHlcbiAgICogY29vcmRpbmF0ZSBtdWx0aXBsaWVkIGJ5IC0xXG4gICAqIEByZXR1cm4ge1BvaW50fSBwZXJwZW5kaWN1bGFyIHBvaW50XG4gICAqL1xuICBwZXJwKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGlzIHBvaW50IHdpdGggdGhlIHggJiB5IGNvb3JkaW5hdGVzXG4gICAqIHJvdW5kZWQgdG8gaW50ZWdlcnMuXG4gICAqIEByZXR1cm4ge1BvaW50fSByb3VuZGVkIHBvaW50XG4gICAqL1xuICByb3VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHBvaW50OiB0aGlzIGlzIHRoZSBFdWNsaWRlYW5cbiAgICogZGlzdGFuY2UgZnJvbSB0aGUgMCwgMCBjb29yZGluYXRlIHRvIHRoaXMgcG9pbnQncyB4IGFuZCB5XG4gICAqIGNvb3JkaW5hdGVzLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1hZ25pdHVkZVxuICAgKi9cbiAgbWFnKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgfVxuICAvKipcbiAgICogSnVkZ2Ugd2hldGhlciB0aGlzIHBvaW50IGlzIGVxdWFsIHRvIGFub3RoZXIgcG9pbnQsIHJldHVybmluZ1xuICAgKiB0cnVlIG9yIGZhbHNlLlxuICAgKiBAcGFyYW0ge1BvaW50fSBvdGhlciB0aGUgb3RoZXIgcG9pbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcG9pbnRzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAgICogQHBhcmFtIHtQb2ludH0gcCB0aGUgb3RoZXIgcG9pbnRcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZGlzdChwKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50LFxuICAgKiB3aXRob3V0IHRoZSBzcXVhcmUgcm9vdCBzdGVwLiBVc2VmdWwgaWYgeW91J3JlIGNvbXBhcmluZ1xuICAgKiByZWxhdGl2ZSBkaXN0YW5jZXMuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAgdGhlIG90aGVyIHBvaW50XG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGRpc3RTcXIocCkge1xuICAgIGNvbnN0IGR4ID0gcC54IC0gdGhpcy54O1xuICAgIGNvbnN0IGR5ID0gcC55IC0gdGhpcy55O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbmdsZSBmcm9tIHRoZSAwLCAwIGNvb3JkaW5hdGUgdG8gdGhpcyBwb2ludCwgaW4gcmFkaWFuc1xuICAgKiBjb29yZGluYXRlcy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgYW5nbGUoKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuZ2xlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50LCBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSB7UG9pbnR9IGIgdGhlIG90aGVyIHBvaW50XG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGFuZ2xlVG8oYikge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgcG9pbnQsIGluIHJhZGlhbnNcbiAgICogQHBhcmFtIHtQb2ludH0gYiB0aGUgb3RoZXIgcG9pbnRcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgYW5nbGVXaXRoKGIpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAoYi54LCBiLnkpO1xuICB9XG4gIC8qXG4gICAqIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3JcbiAgICogdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAgICovXG4gIGFuZ2xlV2l0aFNlcCh4LCB5KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy54ICogeSAtIHRoaXMueSAqIHgsIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgcG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnksIG90aGVyd2lzZSBpZiB0aGUgaW5wdXRcbiAgICogaXMgYWxyZWFkeSBhIFBvaW50LCBvciBhbiB1bmtub3duIHR5cGUsIHJldHVybiBpdCB1bmNoYW5nZWRcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+IHwgUG9pbnR9IGEgYW55IGtpbmQgb2YgaW5wdXQgdmFsdWVcbiAgICogQHJldHVybiB7UG9pbnR9IGNvbnN0cnVjdGVkIHBvaW50LCBvciBwYXNzZWQtdGhyb3VnaCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gdGhpc1xuICAgKiB2YXIgcG9pbnQgPSBQb2ludC5jb252ZXJ0KFswLCAxXSk7XG4gICAqIC8vIGlzIGVxdWl2YWxlbnQgdG9cbiAgICogdmFyIHBvaW50ID0gbmV3IFBvaW50KDAsIDEpO1xuICAgKi9cbiAgc3RhdGljIGNvbnZlcnQoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cblxudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSQxID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMkMSA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wJDEuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQxKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQxKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5mdW5jdGlvbiBzdHIyeG1sKHN0cikge1xuICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyLCBcImFwcGxpY2F0aW9uL3htbFwiKTtcbiAgICBpZiAoZG9jLnF1ZXJ5U2VsZWN0b3IoXCJwYXJzZXJlcnJvclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgdmFsaWQgWE1MXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFhNTCBwYXJzZXIgZm91bmRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkTm9kZVdpdGhOYW1lKGRvYywgbm9kZU5hbWUpIHtcbiAgaWYgKCFkb2MuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIEFycmF5LmZyb20oZG9jLmNoaWxkTm9kZXMpKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGVOYW1lID0gY2hpbGROb2RlLm5vZGVOYW1lO1xuICAgIGlmICh0eXBlb2YgY3VycmVudE5vZGVOYW1lID09PSBcInN0cmluZ1wiICYmIGN1cnJlbnROb2RlTmFtZS50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHhtbDJzdHIobm9kZSkge1xuICBpZiAodHlwZW9mIFhNTFNlcmlhbGl6ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhub2RlKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBYTUwgc2VyaWFsaXplciBmb3VuZFwiKTtcbn1cbmZ1bmN0aW9uIGdweChkb2MpIHtcbiAgaWYgKHR5cGVvZiBkb2MgPT09IFwic3RyaW5nXCIpXG4gICAgZG9jID0gc3RyMnhtbChkb2MpO1xuICBpZiAoIWhhc0NoaWxkTm9kZVdpdGhOYW1lKGRvYywgXCJncHhcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgWE1MIGRvY3VtZW50IGlzIG5vdCB2YWxpZCBHUFhcIik7XG4gIH1cbiAgY29uc3QgdHJhY2tzID0gZ2V0KGRvYywgXCJ0cmtcIik7XG4gIGNvbnN0IHJvdXRlcyA9IGdldChkb2MsIFwicnRlXCIpO1xuICBjb25zdCB3YXlwb2ludHMgPSBnZXQoZG9jLCBcIndwdFwiKTtcbiAgY29uc3QgZ2ogPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIGZlYXR1cmVzOiBbXVxuICB9O1xuICBmb3IgKGNvbnN0IHRyYWNrIG9mIEFycmF5LmZyb20odHJhY2tzKSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBnZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKGZlYXR1cmUpXG4gICAgICBnai5mZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICB9XG4gIGZvciAoY29uc3Qgcm91dGUgb2YgQXJyYXkuZnJvbShyb3V0ZXMpKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGdldFJvdXRlKHJvdXRlKTtcbiAgICBpZiAoZmVhdHVyZSlcbiAgICAgIGdqLmZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gIH1cbiAgZm9yIChjb25zdCB3YXlwb2ludCBvZiBBcnJheS5mcm9tKHdheXBvaW50cykpIHtcbiAgICBnai5mZWF0dXJlcy5wdXNoKGdldFBvaW50KHdheXBvaW50KSk7XG4gIH1cbiAgcmV0dXJuIGdqO1xufVxuZnVuY3Rpb24ga21sKGRvYywgeG1sMnN0cmluZykge1xuICB2YXIgX2E7XG4gIGlmICh0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiKVxuICAgIGRvYyA9IHN0cjJ4bWwoZG9jKTtcbiAgaWYgKCFoYXNDaGlsZE5vZGVXaXRoTmFtZShkb2MsIFwia21sXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFhNTCBkb2N1bWVudCBpcyBub3QgdmFsaWQgS01MXCIpO1xuICB9XG4gIGNvbnN0IGdqID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICBmZWF0dXJlczogW11cbiAgfTtcbiAgY29uc3Qgc3R5bGVJbmRleCA9IHt9O1xuICBjb25zdCBzdHlsZUJ5SGFzaCA9IHt9O1xuICBjb25zdCBzdHlsZU1hcEluZGV4ID0ge307XG4gIGNvbnN0IHBsYWNlbWFya3MgPSBnZXQoZG9jLCBcIlBsYWNlbWFya1wiKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0KGRvYywgXCJTdHlsZVwiKTtcbiAgY29uc3Qgc3R5bGVNYXBzID0gZ2V0KGRvYywgXCJTdHlsZU1hcFwiKTtcbiAgZm9yIChjb25zdCBzdHlsZSBvZiBBcnJheS5mcm9tKHN0eWxlcykpIHtcbiAgICBjb25zdCBoYXNoID0gb2toYXNoKFxuICAgICAgeG1sMnN0cmluZyAhPT0gdm9pZCAwID8geG1sMnN0cmluZyhzdHlsZSkgOiB4bWwyc3RyKHN0eWxlKVxuICAgICkudG9TdHJpbmcoMTYpO1xuICAgIHN0eWxlSW5kZXhbXCIjXCIgKyBhdHRyKHN0eWxlLCBcImlkXCIpXSA9IGhhc2g7XG4gICAgc3R5bGVCeUhhc2hbaGFzaF0gPSBzdHlsZTtcbiAgfVxuICBmb3IgKGNvbnN0IHN0eWxlTWFwIG9mIEFycmF5LmZyb20oc3R5bGVNYXBzKSkge1xuICAgIHN0eWxlSW5kZXhbXCIjXCIgKyBhdHRyKHN0eWxlTWFwLCBcImlkXCIpXSA9IG9raGFzaChcbiAgICAgIHhtbDJzdHJpbmcgIT09IHZvaWQgMCA/IHhtbDJzdHJpbmcoc3R5bGVNYXApIDogeG1sMnN0cihzdHlsZU1hcClcbiAgICApLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBwYWlycyA9IGdldChzdHlsZU1hcCwgXCJQYWlyXCIpO1xuICAgIGNvbnN0IHBhaXJzTWFwID0ge307XG4gICAgZm9yIChjb25zdCBwYWlyIG9mIEFycmF5LmZyb20ocGFpcnMpKSB7XG4gICAgICBwYWlyc01hcFsoX2EgPSBub2RlVmFsKGdldDEocGFpciwgXCJrZXlcIikpKSAhPSBudWxsID8gX2EgOiBcIlwiXSA9IG5vZGVWYWwoXG4gICAgICAgIGdldDEocGFpciwgXCJzdHlsZVVybFwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgc3R5bGVNYXBJbmRleFtcIiNcIiArIGF0dHIoc3R5bGVNYXAsIFwiaWRcIildID0gcGFpcnNNYXA7XG4gIH1cbiAgZm9yIChjb25zdCBwbGFjZW1hcmsgb2YgQXJyYXkuZnJvbShwbGFjZW1hcmtzKSkge1xuICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMuY29uY2F0KFxuICAgICAgZ2V0UGxhY2VtYXJrKHBsYWNlbWFyaywgc3R5bGVJbmRleCwgc3R5bGVCeUhhc2gsIHN0eWxlTWFwSW5kZXgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZ2o7XG59XG5mdW5jdGlvbiBrbWxDb2xvcih2KSB7XG4gIGlmICh2ID09PSBudWxsKVxuICAgIHJldHVybiBbXCIjMDAwMDAwXCIsIDFdO1xuICBsZXQgY29sb3IgPSBcIlwiO1xuICBsZXQgb3BhY2l0eSA9IDE7XG4gIGlmICh2LnN1YnN0cmluZygwLCAxKSA9PT0gXCIjXCIpXG4gICAgdiA9IHYuc3Vic3RyaW5nKDEpO1xuICBpZiAodi5sZW5ndGggPT09IDYgfHwgdi5sZW5ndGggPT09IDMpXG4gICAgY29sb3IgPSB2O1xuICBpZiAodi5sZW5ndGggPT09IDgpIHtcbiAgICBvcGFjaXR5ID0gcGFyc2VJbnQodi5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NTtcbiAgICBjb2xvciA9IFwiI1wiICsgdi5zdWJzdHJpbmcoNiwgOCkgKyB2LnN1YnN0cmluZyg0LCA2KSArIHYuc3Vic3RyaW5nKDIsIDQpO1xuICB9XG4gIHJldHVybiBbY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogXCIjMDAwMDAwXCIsIG9wYWNpdHkgIT0gbnVsbCA/IG9wYWNpdHkgOiAxXTtcbn1cbmZ1bmN0aW9uIGd4Q29vcmQodikge1xuICByZXR1cm4gbnVtYXJyYXkodi5zcGxpdChcIiBcIikpO1xufVxuZnVuY3Rpb24gZ3hDb29yZHMocm9vdCkge1xuICB2YXIgX2E7XG4gIGxldCBlbGVtcyA9IGdldChyb290LCBcImNvb3JkXCIpO1xuICBjb25zdCBjb29yZHMgPSBbXTtcbiAgY29uc3QgdGltZXMgPSBbXTtcbiAgaWYgKGVsZW1zLmxlbmd0aCA9PT0gMClcbiAgICBlbGVtcyA9IGdldChyb290LCBcImd4OmNvb3JkXCIpO1xuICBmb3IgKGNvbnN0IGVsZW0gb2YgQXJyYXkuZnJvbShlbGVtcykpIHtcbiAgICBjb29yZHMucHVzaChneENvb3JkKChfYSA9IG5vZGVWYWwoZWxlbSkpICE9IG51bGwgPyBfYSA6IFwiXCIpKTtcbiAgfVxuICBjb25zdCB0aW1lRWxlbXMgPSBnZXQocm9vdCwgXCJ3aGVuXCIpO1xuICBmb3IgKGNvbnN0IHRpbWVFbGVtIG9mIEFycmF5LmZyb20odGltZUVsZW1zKSlcbiAgICB0aW1lcy5wdXNoKG5vZGVWYWwodGltZUVsZW0pKTtcbiAgcmV0dXJuIHtcbiAgICBjb29yZHMsXG4gICAgdGltZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEdlb21ldHJ5KHJvb3QpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGdlb3R5cGVzID0gW1wiUG9seWdvblwiLCBcIkxpbmVTdHJpbmdcIiwgXCJQb2ludFwiLCBcIlRyYWNrXCIsIFwiZ3g6VHJhY2tcIl07XG4gIGxldCBnZW9tTm9kZSwgZ2VvbU5vZGVzLCBpLCBqLCBrO1xuICBjb25zdCBnZW9tcyA9IFtdO1xuICBjb25zdCBjb29yZFRpbWVzID0gW107XG4gIGlmIChnZXQxKHJvb3QsIFwiTXVsdGlHZW9tZXRyeVwiKSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRHZW9tZXRyeShnZXQxKHJvb3QsIFwiTXVsdGlHZW9tZXRyeVwiKSk7XG4gIH1cbiAgaWYgKGdldDEocm9vdCwgXCJNdWx0aVRyYWNrXCIpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldEdlb21ldHJ5KGdldDEocm9vdCwgXCJNdWx0aVRyYWNrXCIpKTtcbiAgfVxuICBpZiAoZ2V0MShyb290LCBcImd4Ok11bHRpVHJhY2tcIikgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0R2VvbWV0cnkoZ2V0MShyb290LCBcImd4Ok11bHRpVHJhY2tcIikpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBnZW90eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGdlb21Ob2RlcyA9IGdldChyb290LCBnZW90eXBlc1tpXSk7XG4gICAgaWYgKGdlb21Ob2Rlcykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21Ob2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBnZW9tTm9kZSA9IGdlb21Ob2Rlc1tqXTtcbiAgICAgICAgaWYgKGdlb3R5cGVzW2ldID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICBnZW9tcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZDEoKF9hID0gbm9kZVZhbChnZXQxKGdlb21Ob2RlLCBcImNvb3JkaW5hdGVzXCIpKSkgIT0gbnVsbCA/IF9hIDogXCJcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChnZW90eXBlc1tpXSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICBnZW9tcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkKChfYiA9IG5vZGVWYWwoZ2V0MShnZW9tTm9kZSwgXCJjb29yZGluYXRlc1wiKSkpICE9IG51bGwgPyBfYiA6IFwiXCIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvdHlwZXNbaV0gPT09IFwiUG9seWdvblwiKSB7XG4gICAgICAgICAgY29uc3QgcmluZ3MgPSBnZXQoZ2VvbU5vZGUsIFwiTGluZWFyUmluZ1wiKTtcbiAgICAgICAgICBjb25zdCBjb29yZHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKGNvb3JkKChfYyA9IG5vZGVWYWwoZ2V0MShyaW5nc1trXSwgXCJjb29yZGluYXRlc1wiKSkpICE9IG51bGwgPyBfYyA6IFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2VvbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChnZW90eXBlc1tpXSA9PT0gXCJUcmFja1wiIHx8IGdlb3R5cGVzW2ldID09PSBcImd4OlRyYWNrXCIpIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IGd4Q29vcmRzKGdlb21Ob2RlKTtcbiAgICAgICAgICBnZW9tcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHRyYWNrLmNvb3Jkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0cmFjay50aW1lcy5sZW5ndGgpXG4gICAgICAgICAgICBjb29yZFRpbWVzLnB1c2godHJhY2sudGltZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGdlb21zLCBjb29yZFRpbWVzIH07XG59XG5mdW5jdGlvbiBnZXRQbGFjZW1hcmsocm9vdCwgc3R5bGVJbmRleCwgc3R5bGVCeUhhc2gsIHN0eWxlTWFwSW5kZXgpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qO1xuICBjb25zdCBnZW9tc0FuZFRpbWVzID0gZ2V0R2VvbWV0cnkocm9vdCk7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgY29uc3QgbmFtZSA9IG5vZGVWYWwoZ2V0MShyb290LCBcIm5hbWVcIikpO1xuICBjb25zdCBhZGRyZXNzID0gbm9kZVZhbChnZXQxKHJvb3QsIFwiYWRkcmVzc1wiKSk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gbm9kZVZhbChnZXQxKHJvb3QsIFwiZGVzY3JpcHRpb25cIikpO1xuICBjb25zdCB0aW1lU3BhbiA9IGdldDEocm9vdCwgXCJUaW1lU3BhblwiKTtcbiAgY29uc3QgdGltZVN0YW1wID0gZ2V0MShyb290LCBcIlRpbWVTdGFtcFwiKTtcbiAgY29uc3QgZXh0ZW5kZWREYXRhID0gZ2V0MShyb290LCBcIkV4dGVuZGVkRGF0YVwiKTtcbiAgY29uc3QgdmlzaWJpbGl0eSA9IGdldDEocm9vdCwgXCJ2aXNpYmlsaXR5XCIpO1xuICBsZXQgaTtcbiAgbGV0IHN0eWxlVXJsID0gbm9kZVZhbChnZXQxKHJvb3QsIFwic3R5bGVVcmxcIikpO1xuICBsZXQgbGluZVN0eWxlID0gZ2V0MShyb290LCBcIkxpbmVTdHlsZVwiKTtcbiAgbGV0IHBvbHlTdHlsZSA9IGdldDEocm9vdCwgXCJQb2x5U3R5bGVcIik7XG4gIGlmICghZ2VvbXNBbmRUaW1lcy5nZW9tcy5sZW5ndGgpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAobmFtZSlcbiAgICBwcm9wZXJ0aWVzLm5hbWUgPSBuYW1lO1xuICBpZiAoYWRkcmVzcylcbiAgICBwcm9wZXJ0aWVzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICBpZiAoc3R5bGVVcmwpIHtcbiAgICBpZiAoc3R5bGVVcmxbMF0gIT09IFwiI1wiKVxuICAgICAgc3R5bGVVcmwgPSBcIiNcIiArIHN0eWxlVXJsO1xuICAgIHByb3BlcnRpZXMuc3R5bGVVcmwgPSBzdHlsZVVybDtcbiAgICBpZiAoc3R5bGVJbmRleFtzdHlsZVVybF0pIHtcbiAgICAgIHByb3BlcnRpZXMuc3R5bGVIYXNoID0gc3R5bGVJbmRleFtzdHlsZVVybF07XG4gICAgfVxuICAgIGlmIChzdHlsZU1hcEluZGV4W3N0eWxlVXJsXSkge1xuICAgICAgcHJvcGVydGllcy5zdHlsZU1hcEhhc2ggPSBzdHlsZU1hcEluZGV4W3N0eWxlVXJsXTtcbiAgICAgIHByb3BlcnRpZXMuc3R5bGVIYXNoID0gc3R5bGVJbmRleFsoX2EgPSBzdHlsZU1hcEluZGV4W3N0eWxlVXJsXS5ub3JtYWwpICE9IG51bGwgPyBfYSA6IFwiXCJdO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IHN0eWxlQnlIYXNoWyhfYiA9IHByb3BlcnRpZXMuc3R5bGVIYXNoKSAhPSBudWxsID8gX2IgOiBcIlwiXTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGlmICghbGluZVN0eWxlKVxuICAgICAgICBsaW5lU3R5bGUgPSBnZXQxKHN0eWxlLCBcIkxpbmVTdHlsZVwiKTtcbiAgICAgIGlmICghcG9seVN0eWxlKVxuICAgICAgICBwb2x5U3R5bGUgPSBnZXQxKHN0eWxlLCBcIlBvbHlTdHlsZVwiKTtcbiAgICAgIGNvbnN0IGljb25TdHlsZSA9IGdldDEoc3R5bGUsIFwiSWNvblN0eWxlXCIpO1xuICAgICAgaWYgKGljb25TdHlsZSkge1xuICAgICAgICBjb25zdCBpY29uID0gZ2V0MShpY29uU3R5bGUsIFwiSWNvblwiKTtcbiAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICBjb25zdCBocmVmID0gbm9kZVZhbChnZXQxKGljb24sIFwiaHJlZlwiKSk7XG4gICAgICAgICAgaWYgKGhyZWYpXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmljb24gPSBocmVmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkZXNjcmlwdGlvbilcbiAgICBwcm9wZXJ0aWVzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIGlmICh0aW1lU3Bhbikge1xuICAgIGNvbnN0IGJlZ2luID0gbm9kZVZhbChnZXQxKHRpbWVTcGFuLCBcImJlZ2luXCIpKTtcbiAgICBjb25zdCBlbmQgPSBub2RlVmFsKGdldDEodGltZVNwYW4sIFwiZW5kXCIpKTtcbiAgICBpZiAoYmVnaW4gJiYgZW5kKVxuICAgICAgcHJvcGVydGllcy50aW1lc3BhbiA9IHsgYmVnaW4sIGVuZCB9O1xuICB9XG4gIGlmICh0aW1lU3RhbXAgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzLnRpbWVzdGFtcCA9IChfYyA9IG5vZGVWYWwoZ2V0MSh0aW1lU3RhbXAsIFwid2hlblwiKSkpICE9IG51bGwgPyBfYyA6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKTtcbiAgfVxuICBpZiAobGluZVN0eWxlICE9PSBudWxsKSB7XG4gICAgY29uc3QgbGluZXN0eWxlcyA9IGttbENvbG9yKG5vZGVWYWwoZ2V0MShsaW5lU3R5bGUsIFwiY29sb3JcIikpKTtcbiAgICBjb25zdCBjb2xvciA9IGxpbmVzdHlsZXNbMF07XG4gICAgY29uc3Qgb3BhY2l0eSA9IGxpbmVzdHlsZXNbMV07XG4gICAgY29uc3Qgd2lkdGggPSBwYXJzZUZsb2F0KChfZCA9IG5vZGVWYWwoZ2V0MShsaW5lU3R5bGUsIFwid2lkdGhcIikpKSAhPSBudWxsID8gX2QgOiBcIlwiKTtcbiAgICBpZiAoY29sb3IpXG4gICAgICBwcm9wZXJ0aWVzLnN0cm9rZSA9IGNvbG9yO1xuICAgIGlmICghaXNOYU4ob3BhY2l0eSkpXG4gICAgICBwcm9wZXJ0aWVzW1wic3Ryb2tlLW9wYWNpdHlcIl0gPSBvcGFjaXR5O1xuICAgIGlmICghaXNOYU4od2lkdGgpKVxuICAgICAgcHJvcGVydGllc1tcInN0cm9rZS13aWR0aFwiXSA9IHdpZHRoO1xuICB9XG4gIGlmIChwb2x5U3R5bGUpIHtcbiAgICBjb25zdCBwb2x5c3R5bGVzID0ga21sQ29sb3Iobm9kZVZhbChnZXQxKHBvbHlTdHlsZSwgXCJjb2xvclwiKSkpO1xuICAgIGNvbnN0IHBjb2xvciA9IHBvbHlzdHlsZXNbMF07XG4gICAgY29uc3QgcG9wYWNpdHkgPSBwb2x5c3R5bGVzWzFdO1xuICAgIGNvbnN0IGZpbGwgPSBub2RlVmFsKGdldDEocG9seVN0eWxlLCBcImZpbGxcIikpO1xuICAgIGNvbnN0IG91dGxpbmUgPSBub2RlVmFsKGdldDEocG9seVN0eWxlLCBcIm91dGxpbmVcIikpO1xuICAgIGlmIChwY29sb3IpXG4gICAgICBwcm9wZXJ0aWVzLmZpbGwgPSBwY29sb3I7XG4gICAgaWYgKCFpc05hTihwb3BhY2l0eSkpXG4gICAgICBwcm9wZXJ0aWVzW1wiZmlsbC1vcGFjaXR5XCJdID0gcG9wYWNpdHk7XG4gICAgaWYgKGZpbGwpXG4gICAgICBwcm9wZXJ0aWVzW1wiZmlsbC1vcGFjaXR5XCJdID0gZmlsbCA9PT0gXCIxXCIgPyBwcm9wZXJ0aWVzW1wiZmlsbC1vcGFjaXR5XCJdIHx8IDEgOiAwO1xuICAgIGlmIChvdXRsaW5lKVxuICAgICAgcHJvcGVydGllc1tcInN0cm9rZS1vcGFjaXR5XCJdID0gb3V0bGluZSA9PT0gXCIxXCIgPyBwcm9wZXJ0aWVzW1wic3Ryb2tlLW9wYWNpdHlcIl0gfHwgMSA6IDA7XG4gIH1cbiAgaWYgKGV4dGVuZGVkRGF0YSkge1xuICAgIGNvbnN0IGRhdGFzID0gZ2V0KGV4dGVuZGVkRGF0YSwgXCJEYXRhXCIpLCBzaW1wbGVEYXRhcyA9IGdldChleHRlbmRlZERhdGEsIFwiU2ltcGxlRGF0YVwiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb3BlcnRpZXNbKF9lID0gZGF0YXNbaV0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSkgIT0gbnVsbCA/IF9lIDogXCJcIl0gPSAoX2YgPSBub2RlVmFsKGdldDEoZGF0YXNbaV0sIFwidmFsdWVcIikpKSAhPSBudWxsID8gX2YgOiBcIlwiO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2ltcGxlRGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb3BlcnRpZXNbKF9nID0gc2ltcGxlRGF0YXNbaV0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSkgIT0gbnVsbCA/IF9nIDogXCJcIl0gPSAoX2ggPSBub2RlVmFsKHNpbXBsZURhdGFzW2ldKSkgIT0gbnVsbCA/IF9oIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKHZpc2liaWxpdHkgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzLnZpc2liaWxpdHkgPSAoX2kgPSBub2RlVmFsKHZpc2liaWxpdHkpKSAhPSBudWxsID8gX2kgOiBcIlwiO1xuICB9XG4gIGlmIChnZW9tc0FuZFRpbWVzLmNvb3JkVGltZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgcHJvcGVydGllcy5jb29yZFRpbWVzID0gZ2VvbXNBbmRUaW1lcy5jb29yZFRpbWVzLmxlbmd0aCA9PT0gMSA/IGdlb21zQW5kVGltZXMuY29vcmRUaW1lc1swXSA6IGdlb21zQW5kVGltZXMuY29vcmRUaW1lcztcbiAgfVxuICBjb25zdCBmZWF0dXJlID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIGdlb21ldHJ5OiBnZW9tc0FuZFRpbWVzLmdlb21zLmxlbmd0aCA9PT0gMSA/IGdlb21zQW5kVGltZXMuZ2VvbXNbMF0gOiB7XG4gICAgICB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFxuICAgICAgZ2VvbWV0cmllczogZ2VvbXNBbmRUaW1lcy5nZW9tc1xuICAgIH0sXG4gICAgcHJvcGVydGllc1xuICB9O1xuICBpZiAoYXR0cihyb290LCBcImlkXCIpKVxuICAgIGZlYXR1cmUuaWQgPSAoX2ogPSBhdHRyKHJvb3QsIFwiaWRcIikpICE9IG51bGwgPyBfaiA6IHZvaWQgMDtcbiAgcmV0dXJuIFtmZWF0dXJlXTtcbn1cbmZ1bmN0aW9uIGdldFBvaW50cyhub2RlLCBwb2ludG5hbWUpIHtcbiAgY29uc3QgcHRzID0gZ2V0KG5vZGUsIHBvaW50bmFtZSk7XG4gIGNvbnN0IGxpbmUgPSBbXTtcbiAgY29uc3QgdGltZXMgPSBbXTtcbiAgbGV0IGhlYXJ0UmF0ZXMgPSBbXTtcbiAgY29uc3QgcHRzTGVuZ3RoID0gcHRzLmxlbmd0aDtcbiAgaWYgKHB0c0xlbmd0aCA8IDIpXG4gICAgcmV0dXJuO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHB0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY1BhaXIgPSBjb29yZFBhaXIocHRzW2ldKTtcbiAgICBsaW5lLnB1c2goY1BhaXIuY29vcmRpbmF0ZXMpO1xuICAgIGlmIChjUGFpci50aW1lKVxuICAgICAgdGltZXMucHVzaChjUGFpci50aW1lKTtcbiAgICBpZiAoY1BhaXIuaGVhcnRSYXRlIHx8IGhlYXJ0UmF0ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoaGVhcnRSYXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIGhlYXJ0UmF0ZXMgPSBuZXcgQXJyYXkoaSkuZmlsbChudWxsKTtcbiAgICAgIGhlYXJ0UmF0ZXMucHVzaChjUGFpci5oZWFydFJhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgdGltZXMsXG4gICAgaGVhcnRSYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhY2sobm9kZSkge1xuICBjb25zdCBzZWdtZW50cyA9IGdldChub2RlLCBcInRya3NlZ1wiKTtcbiAgY29uc3QgdHJhY2sgPSBbXTtcbiAgY29uc3QgdGltZXMgPSBbXTtcbiAgY29uc3QgaGVhcnRSYXRlcyA9IFtdO1xuICBsZXQgbGluZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxpbmUgPSBnZXRQb2ludHMoc2VnbWVudHNbaV0sIFwidHJrcHRcIik7XG4gICAgaWYgKGxpbmUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGxpbmUubGluZSlcbiAgICAgICAgdHJhY2sucHVzaChsaW5lLmxpbmUpO1xuICAgICAgaWYgKGxpbmUudGltZXMgJiYgbGluZS50aW1lcy5sZW5ndGgpXG4gICAgICAgIHRpbWVzLnB1c2gobGluZS50aW1lcyk7XG4gICAgICBpZiAoaGVhcnRSYXRlcy5sZW5ndGggfHwgbGluZS5oZWFydFJhdGVzICYmIGxpbmUuaGVhcnRSYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFoZWFydFJhdGVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgaTsgcysrKSB7XG4gICAgICAgICAgICBoZWFydFJhdGVzLnB1c2gobmV3IEFycmF5KHRyYWNrW3NdLmxlbmd0aCkuZmlsbChudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmhlYXJ0UmF0ZXMgJiYgbGluZS5oZWFydFJhdGVzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYXJ0UmF0ZXMucHVzaChsaW5lLmhlYXJ0UmF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYXJ0UmF0ZXMucHVzaChuZXcgQXJyYXkobGluZS5saW5lLmxlbmd0aCkuZmlsbChudWxsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRyYWNrLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIGdldFByb3BlcnRpZXMobm9kZSkpLCBnZXRMaW5lU3R5bGUoZ2V0MShub2RlLCBcImV4dGVuc2lvbnNcIikpKTtcbiAgaWYgKHRpbWVzLmxlbmd0aCAhPT0gMClcbiAgICBwcm9wZXJ0aWVzLmNvb3JkVGltZXMgPSB0cmFjay5sZW5ndGggPT09IDEgPyB0aW1lc1swXSA6IHRpbWVzO1xuICBpZiAoaGVhcnRSYXRlcy5sZW5ndGggIT09IDApIHtcbiAgICBwcm9wZXJ0aWVzLmhlYXJ0UmF0ZXMgPSB0cmFjay5sZW5ndGggPT09IDEgPyBoZWFydFJhdGVzWzBdIDogaGVhcnRSYXRlcztcbiAgfVxuICBpZiAodHJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogdHJhY2tbMF1cbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogdHJhY2tcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRSb3V0ZShub2RlKSB7XG4gIGNvbnN0IGxpbmUgPSBnZXRQb2ludHMobm9kZSwgXCJydGVwdFwiKTtcbiAgaWYgKGxpbmUgPT09IHZvaWQgMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHByb3AgPSBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIGdldFByb3BlcnRpZXMobm9kZSkpLCBnZXRMaW5lU3R5bGUoZ2V0MShub2RlLCBcImV4dGVuc2lvbnNcIikpKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBwcm9wZXJ0aWVzOiBwcm9wLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgIGNvb3JkaW5hdGVzOiBsaW5lLmxpbmVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRQb2ludChub2RlKSB7XG4gIGNvbnN0IHByb3AgPSBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIGdldFByb3BlcnRpZXMobm9kZSkpLCBnZXRNdWx0aShub2RlLCBbXCJzeW1cIl0pKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBwcm9wZXJ0aWVzOiBwcm9wLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICBjb29yZGluYXRlczogY29vcmRQYWlyKG5vZGUpLmNvb3JkaW5hdGVzXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0TGluZVN0eWxlKGV4dGVuc2lvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgaWYgKGV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBsaW5lU3R5bGUgPSBnZXQxKGV4dGVuc2lvbnMsIFwibGluZVwiKTtcbiAgICBpZiAobGluZVN0eWxlKSB7XG4gICAgICBjb25zdCBjb2xvciA9IG5vZGVWYWwoZ2V0MShsaW5lU3R5bGUsIFwiY29sb3JcIikpO1xuICAgICAgY29uc3Qgb3BhY2l0eSA9IHBhcnNlRmxvYXQoKF9hID0gbm9kZVZhbChnZXQxKGxpbmVTdHlsZSwgXCJvcGFjaXR5XCIpKSkgIT0gbnVsbCA/IF9hIDogXCIwXCIpO1xuICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUZsb2F0KChfYiA9IG5vZGVWYWwoZ2V0MShsaW5lU3R5bGUsIFwid2lkdGhcIikpKSAhPSBudWxsID8gX2IgOiBcIjBcIik7XG4gICAgICBpZiAoY29sb3IpXG4gICAgICAgIHN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgaWYgKCFpc05hTihvcGFjaXR5KSlcbiAgICAgICAgc3R5bGVbXCJzdHJva2Utb3BhY2l0eVwiXSA9IG9wYWNpdHk7XG4gICAgICBpZiAoIWlzTmFOKHdpZHRoKSlcbiAgICAgICAgc3R5bGVbXCJzdHJva2Utd2lkdGhcIl0gPSB3aWR0aCAqIDk2IC8gMjUuNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhub2RlKSB7XG4gIGNvbnN0IHByb3AgPSBnZXRNdWx0aShub2RlLCBbXG4gICAgXCJuYW1lXCIsXG4gICAgXCJjbXRcIixcbiAgICBcImRlc2NcIixcbiAgICBcInR5cGVcIixcbiAgICBcInRpbWVcIixcbiAgICBcImtleXdvcmRzXCJcbiAgXSk7XG4gIGNvbnN0IGxpbmtzID0gZ2V0KG5vZGUsIFwibGlua1wiKTtcbiAgaWYgKGxpbmtzLmxlbmd0aCAhPT0gMCkge1xuICAgIHByb3AubGlua3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGwgb2YgQXJyYXkuZnJvbShsaW5rcykpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBfX3NwcmVhZFZhbHVlcyQxKHtcbiAgICAgICAgaHJlZjogYXR0cihsLCBcImhyZWZcIilcbiAgICAgIH0sIGdldE11bHRpKGwsIFtcInRleHRcIiwgXCJ0eXBlXCJdKSk7XG4gICAgICBwcm9wLmxpbmtzLnB1c2gobGluayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wO1xufVxuZnVuY3Rpb24gb2toYXNoKHgpIHtcbiAgbGV0IGggPSAwO1xuICBpZiAoIXggfHwgIXgubGVuZ3RoKVxuICAgIHJldHVybiBoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICBoID0gKGggPDwgNSkgLSBoICsgeC5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgfVxuICByZXR1cm4gaDtcbn1cbmZ1bmN0aW9uIGdldCh4LCB5KSB7XG4gIHJldHVybiB4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHkpO1xufVxuZnVuY3Rpb24gYXR0cih4LCB5KSB7XG4gIHJldHVybiB4LmdldEF0dHJpYnV0ZSh5KTtcbn1cbmZ1bmN0aW9uIGF0dHJmKHgsIHkpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gcGFyc2VGbG9hdCgoX2EgPSBhdHRyKHgsIHkpKSAhPSBudWxsID8gX2EgOiBcIjBcIik7XG59XG5mdW5jdGlvbiBnZXQxKHgsIHkpIHtcbiAgY29uc3QgbiA9IGdldCh4LCB5KTtcbiAgcmV0dXJuIG4ubGVuZ3RoID8gblswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBub3JtKGVsKSB7XG4gIGlmIChlbC5ub3JtYWxpemUpXG4gICAgZWwubm9ybWFsaXplKCk7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIG51bWFycmF5KHgpIHtcbiAgcmV0dXJuIHgubWFwKHBhcnNlRmxvYXQpLm1hcCgobikgPT4gaXNOYU4obikgPyBudWxsIDogbik7XG59XG5mdW5jdGlvbiBub2RlVmFsKHgpIHtcbiAgaWYgKHgpXG4gICAgbm9ybSh4KTtcbiAgcmV0dXJuIHggJiYgeC50ZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGdldE11bHRpKHgsIHlzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbyA9IHt9O1xuICBsZXQgbjtcbiAgbGV0IGs7XG4gIGZvciAoayA9IDA7IGsgPCB5cy5sZW5ndGg7IGsrKykge1xuICAgIG4gPSBnZXQxKHgsIHlzW2tdKTtcbiAgICBpZiAobilcbiAgICAgIG9beXNba11dID0gKF9hID0gbm9kZVZhbChuKSkgIT0gbnVsbCA/IF9hIDogXCJcIjtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGNvb3JkMSh2KSB7XG4gIHJldHVybiBudW1hcnJheSh2LnJlcGxhY2UoL1xccyovZywgXCJcIikuc3BsaXQoXCIsXCIpKTtcbn1cbmZ1bmN0aW9uIGNvb3JkKHYpIHtcbiAgY29uc3QgY29vcmRzID0gdi5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCBcIlwiKS5zcGxpdCgvXFxzKy8pO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgZm9yIChjb25zdCBjb29yZDIgb2YgY29vcmRzKVxuICAgIG91dC5wdXNoKGNvb3JkMShjb29yZDIpKTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGNvb3JkUGFpcih4KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGxsID0gW2F0dHJmKHgsIFwibG9uXCIpLCBhdHRyZih4LCBcImxhdFwiKV07XG4gIGNvbnN0IGVsZSA9IGdldDEoeCwgXCJlbGVcIik7XG4gIGNvbnN0IGhlYXJ0UmF0ZSA9IGdldDEoeCwgXCJncHh0cHg6aHJcIikgfHwgZ2V0MSh4LCBcImhyXCIpO1xuICBjb25zdCB0aW1lID0gZ2V0MSh4LCBcInRpbWVcIik7XG4gIGxldCBlO1xuICBpZiAoZWxlKSB7XG4gICAgZSA9IHBhcnNlRmxvYXQoKF9hID0gbm9kZVZhbChlbGUpKSAhPSBudWxsID8gX2EgOiBcIjBcIik7XG4gICAgaWYgKCFpc05hTihlKSlcbiAgICAgIGxsLnB1c2goZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb29yZGluYXRlczogbGwsXG4gICAgdGltZTogdGltZSA/IG5vZGVWYWwodGltZSkgOiBudWxsLFxuICAgIGhlYXJ0UmF0ZTogaGVhcnRSYXRlICE9PSBudWxsID8gcGFyc2VGbG9hdCgoX2IgPSBub2RlVmFsKGhlYXJ0UmF0ZSkpICE9IG51bGwgPyBfYiA6IFwiMFwiKSA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdweE9yS21sKGRvYykge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiKVxuICAgICAgZG9jID0gc3RyMnhtbChkb2MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBncHgoZG9jKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBrbWwoZG9jKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gY29tcG9uZW50VG9IZXgoYykge1xuICBjb25zdCBoZXggPSBjLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuZnVuY3Rpb24gcmdiVG9IZXgocmdiKSB7XG4gIHJldHVybiBcIiNcIiArIGNvbXBvbmVudFRvSGV4KHJnYlswXSkgKyBjb21wb25lbnRUb0hleChyZ2JbMV0pICsgY29tcG9uZW50VG9IZXgocmdiWzJdKSArIChyZ2IubGVuZ3RoID09PSA0ID8gY29tcG9uZW50VG9IZXgocmdiWzNdKSA6IFwiXCIpO1xufVxuY2xhc3MgQ29sb3JSYW1wIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5cIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heFwiLCAxKTtcbiAgICBpZiAoXCJtaW5cIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm1pbiA9IG9wdGlvbnMubWluO1xuICAgIH1cbiAgICBpZiAoXCJtYXhcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm1heCA9IG9wdGlvbnMubWF4O1xuICAgIH1cbiAgICBpZiAoXCJzdG9wc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0U3RvcHMob3B0aW9ucy5zdG9wcywgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGFycmF5LWRlZmluaXRpb24gY29sb3IgcmFtcCBkZWZpbml0aW9uIGludG8gYSB1c2FibGUgQ29sb3JSYW1wIGluc3RhbmNlLlxuICAgKiBOb3RlOiB1bml0cyBhcmUgbm90IGNvbnZlcnRlZCBhbmQgbWF5IG5lZWQgdG8gdG8gYmUgY29udmVydGVkIGJlZm9yZWhhbmQgKGVnLiBrZWx2aW4gdG8gY2VudGlncmFkZSlcbiAgICogQHBhcmFtIGNyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZnJvbUFycmF5RGVmaW5pdGlvbihjcikge1xuICAgIHJldHVybiBuZXcgQ29sb3JSYW1wKHtcbiAgICAgIHN0b3BzOiBjci5tYXAoKGNzKSA9PiAoe1xuICAgICAgICB2YWx1ZTogY3NbMF0sXG4gICAgICAgIGNvbG9yOiBjc1sxXVxuICAgICAgfSkpXG4gICAgfSk7XG4gIH1cbiAgc2V0U3RvcHMoc3RvcHMsIG9wdGlvbnMgPSB7IGNsb25lOiB0cnVlIH0pIHtcbiAgICBjb25zdCBjb2xvclJhbXAgPSBvcHRpb25zLmNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcbiAgICBjb2xvclJhbXAubGVuZ3RoID0gMDtcbiAgICBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHN0b3BzW2ldLnZhbHVlKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc3RvcHNbaV0udmFsdWUpO1xuICAgICAgY29sb3JSYW1wLnB1c2goe1xuICAgICAgICB2YWx1ZTogc3RvcHNbaV0udmFsdWUsXG4gICAgICAgIGNvbG9yOiBzdG9wc1tpXS5jb2xvci5zbGljZSgpXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvIGEgZGVlcCBjb3B5IGFuZCBub3QgYSByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb2xvclJhbXAuc29ydChcbiAgICAgIChhLCBiKSA9PiBhLnZhbHVlIDwgYi52YWx1ZSA/IC0xIDogMVxuICAgICk7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgcmV0dXJuIGNvbG9yUmFtcDtcbiAgfVxuICBzY2FsZShtaW4sIG1heCwgb3B0aW9ucyA9IHsgY2xvbmU6IHRydWUgfSkge1xuICAgIGNvbnN0IGNsb25lID0gb3B0aW9ucy5jbG9uZTtcbiAgICBjb25zdCBjdXJyZW50TWluID0gdGhpc1swXS52YWx1ZTtcbiAgICBjb25zdCBjdXJyZW50TWF4ID0gdGhpcy5hdCgtMSkudmFsdWU7XG4gICAgY29uc3QgY3VycmVudFNwYW4gPSBjdXJyZW50TWF4IC0gY3VycmVudE1pbjtcbiAgICBjb25zdCBuZXdTcGFuID0gbWF4IC0gbWluO1xuICAgIGNvbnN0IHN0b3BzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzW2ldLnZhbHVlO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gKGN1cnJlbnRWYWx1ZSAtIGN1cnJlbnRNaW4pIC8gY3VycmVudFNwYW47XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIG5ld1NwYW4gKyBtaW47XG4gICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIGNvbG9yOiB0aGlzW2ldLmNvbG9yLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2ldLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSA/IG5ldyBDb2xvclJhbXAoeyBzdG9wcyB9KSA6IHRoaXM7XG4gIH1cbiAgLy8gZm9yIHNvbWUgcmVhc29uLCBJIGhhZCB0byByZWltcGxlbWVudCB0aGlzXG4gIGF0KHBvcykge1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCArIHBvc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3Bvc107XG4gICAgfVxuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3JSYW1wKHsgc3RvcHM6IHRoaXMuZ2V0UmF3Q29sb3JTdG9wcygpIH0pO1xuICB9XG4gIGdldFJhd0NvbG9yU3RvcHMoKSB7XG4gICAgY29uc3Qgc3RvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHN0b3BzLnB1c2goeyB2YWx1ZTogdGhpc1tpXS52YWx1ZSwgY29sb3I6IHRoaXNbaV0uY29sb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdG9wcztcbiAgfVxuICByZXZlcnNlKG9wdGlvbnMgPSB7IGNsb25lOiB0cnVlIH0pIHtcbiAgICBjb25zdCBjb2xvclJhbXAgPSBvcHRpb25zLmNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IH5+KGNvbG9yUmFtcC5sZW5ndGggLyAyKTsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjID0gY29sb3JSYW1wW2ldLmNvbG9yO1xuICAgICAgY29sb3JSYW1wW2ldLmNvbG9yID0gY29sb3JSYW1wLmF0KC0oaSArIDEpKS5jb2xvcjtcbiAgICAgIGNvbG9yUmFtcC5hdCgtKGkgKyAxKSkuY29sb3IgPSBjO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3JSYW1wO1xuICB9XG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4geyBtaW46IHRoaXMubWluLCBtYXg6IHRoaXMubWF4IH07XG4gIH1cbiAgZ2V0Q29sb3IodmFsdWUsIG9wdGlvbnMgPSB7IHNtb290aDogdHJ1ZSB9KSB7XG4gICAgaWYgKHZhbHVlIDw9IHRoaXNbMF0udmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdLmNvbG9yO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gdGhpcy5hdCgtMSkudmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0KC0xKS5jb2xvcjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKHZhbHVlID4gdGhpc1tpICsgMV0udmFsdWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xvckJlZm9yZSA9IHRoaXNbaV0uY29sb3I7XG4gICAgICBpZiAoIW9wdGlvbnMuc21vb3RoKSB7XG4gICAgICAgIHJldHVybiBjb2xvckJlZm9yZS5zbGljZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVCZWZvcmUgPSB0aGlzW2ldLnZhbHVlO1xuICAgICAgY29uc3QgdmFsdWVBZnRlciA9IHRoaXNbaSArIDFdLnZhbHVlO1xuICAgICAgY29uc3QgY29sb3JBZnRlciA9IHRoaXNbaSArIDFdLmNvbG9yO1xuICAgICAgY29uc3QgYmVmb3JlUmF0aW8gPSAodmFsdWVBZnRlciAtIHZhbHVlKSAvICh2YWx1ZUFmdGVyIC0gdmFsdWVCZWZvcmUpO1xuICAgICAgcmV0dXJuIGNvbG9yQmVmb3JlLm1hcChcbiAgICAgICAgKGNoYW4sIGkyKSA9PiBNYXRoLnJvdW5kKGNoYW4gKiBiZWZvcmVSYXRpbyArIGNvbG9yQWZ0ZXJbaTJdICogKDEgLSBiZWZvcmVSYXRpbykpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIGFzIGFuIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgZ2V0Q29sb3JIZXgodmFsdWUsIG9wdGlvbnMgPSB7XG4gICAgc21vb3RoOiB0cnVlLFxuICAgIHdpdGhBbHBoYTogZmFsc2VcbiAgfSkge1xuICAgIHJldHVybiByZ2JUb0hleCh0aGlzLmdldENvbG9yKHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3Igb2YgdGhlIGNvbG9yIHJhbXAgYXQgYSByZWxhdGl2ZSBwb3NpdGlvbiBpbiBbMCwgMV1cbiAgICovXG4gIGdldENvbG9yUmVsYXRpdmUodmFsdWUsIG9wdGlvbnMgPSB7IHNtb290aDogdHJ1ZSB9KSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5nZXRDb2xvcihcbiAgICAgIGJvdW5kcy5taW4gKyB2YWx1ZSAqIChib3VuZHMubWF4IC0gYm91bmRzLm1pbiksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICBnZXRDYW52YXNTdHJpcChvcHRpb25zID0ge1xuICAgIGhvcml6b250YWw6IHRydWUsXG4gICAgc2l6ZTogNTEyLFxuICAgIHNtb290aDogdHJ1ZVxuICB9KSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBvcHRpb25zLmhvcml6b250YWwgPyBvcHRpb25zLnNpemUgOiAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhvcml6b250YWwgPyAxIDogb3B0aW9ucy5zaXplO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52cyBjb250ZXh0IGlzIG1pc3NpbmdcIik7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGltYWdlRGF0YUFycmF5ID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgY29uc3Qgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICBjb25zdCBzdGFydFZhbHVlID0gdGhpc1swXS52YWx1ZTtcbiAgICBjb25zdCBlbmRWYWx1ZSA9IHRoaXMuYXQoLTEpLnZhbHVlO1xuICAgIGNvbnN0IHZhbHVlU3BhbiA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZVN0ZXAgPSB2YWx1ZVNwYW4gLyBzaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q29sb3Ioc3RhcnRWYWx1ZSArIGkgKiB2YWx1ZVN0ZXAsIHtcbiAgICAgICAgc21vb3RoOiBvcHRpb25zLnNtb290aFxuICAgICAgfSk7XG4gICAgICBpbWFnZURhdGFBcnJheVtpICogNF0gPSBjb2xvclswXTtcbiAgICAgIGltYWdlRGF0YUFycmF5W2kgKiA0ICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIGltYWdlRGF0YUFycmF5W2kgKiA0ICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIGltYWdlRGF0YUFycmF5W2kgKiA0ICsgM10gPSBjb2xvci5sZW5ndGggPiAzID8gY29sb3JbM10gOiAyNTU7XG4gICAgfVxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSBhIG5vbi1saW5lYXIgcmVzc2FtcGxpbmcuIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3JSYW1wIHdpdGggdGhlIHNhbWUgYm91bmRzLlxuICAgKi9cbiAgcmVzYW1wbGUobWV0aG9kLCBzYW1wbGVzID0gMTUpIHtcbiAgICBjb25zdCBpbnB1dEJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgaW5wdXROb3JtYWxpemVkID0gdGhpcy5zY2FsZSgwLCAxKTtcbiAgICBjb25zdCBzdGVwID0gMSAvIChzYW1wbGVzIC0gMSk7XG4gICAgbGV0IHN0b3BzO1xuICAgIGlmIChtZXRob2QgPT09IFwiZWFzZS1pbi1zcXVhcmVcIikge1xuICAgICAgc3RvcHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzYW1wbGVzIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpICogc3RlcDtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucG93KHgsIDIpO1xuICAgICAgICBjb25zdCBjb2xvciA9IGlucHV0Tm9ybWFsaXplZC5nZXRDb2xvcih5KTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHgsIGNvbG9yIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJlYXNlLW91dC1zcXVhcmVcIikge1xuICAgICAgc3RvcHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzYW1wbGVzIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpICogc3RlcDtcbiAgICAgICAgY29uc3QgeSA9IDEgLSBNYXRoLnBvdygxIC0geCwgMik7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaW5wdXROb3JtYWxpemVkLmdldENvbG9yKHkpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogeCwgY29sb3IgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcImVhc2Utb3V0LXNxcnRcIikge1xuICAgICAgc3RvcHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzYW1wbGVzIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpICogc3RlcDtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucG93KHgsIDAuNSk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaW5wdXROb3JtYWxpemVkLmdldENvbG9yKHkpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogeCwgY29sb3IgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcImVhc2UtaW4tc3FydFwiKSB7XG4gICAgICBzdG9wcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNhbXBsZXMgfSwgKF8sIGkpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGkgKiBzdGVwO1xuICAgICAgICBjb25zdCB5ID0gMSAtIE1hdGgucG93KDEgLSB4LCAwLjUpO1xuICAgICAgICBjb25zdCBjb2xvciA9IGlucHV0Tm9ybWFsaXplZC5nZXRDb2xvcih5KTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHgsIGNvbG9yIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJlYXNlLW91dC1leHBcIikge1xuICAgICAgc3RvcHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzYW1wbGVzIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpICogc3RlcDtcbiAgICAgICAgY29uc3QgeSA9IDEgLSBNYXRoLnBvdygyLCAtMTAgKiB4KTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBpbnB1dE5vcm1hbGl6ZWQuZ2V0Q29sb3IoeSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB4LCBjb2xvciB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwiZWFzZS1pbi1leHBcIikge1xuICAgICAgc3RvcHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzYW1wbGVzIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpICogc3RlcDtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucG93KDIsIDEwICogeCAtIDEwKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBpbnB1dE5vcm1hbGl6ZWQuZ2V0Q29sb3IoeSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB4LCBjb2xvciB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzc2FtcGxpbmcgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0Tm9ybWFsaXplZCA9IG5ldyBDb2xvclJhbXAoeyBzdG9wcyB9KTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXROb3JtYWxpemVkLnNjYWxlKGlucHV0Qm91bmRzLm1pbiwgaW5wdXRCb3VuZHMubWF4KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIGNsb25lIG9mIHRoaXMgY29sb3IgcmFtcCB0aGF0IGlzIGZ1bGx5IHRyYW5zcGFyYW50IGF0IHRoZSBiZWdpbmluZyBvZiB0aGVpciByYW5nZVxuICAgKi9cbiAgdHJhbnNwYXJlbnRTdGFydCgpIHtcbiAgICBjb25zdCBzdG9wcyA9IHRoaXMuZ2V0UmF3Q29sb3JTdG9wcygpO1xuICAgIHN0b3BzLnVuc2hpZnQoe1xuICAgICAgdmFsdWU6IHN0b3BzWzBdLnZhbHVlLFxuICAgICAgY29sb3I6IHN0b3BzWzBdLmNvbG9yLnNsaWNlKClcbiAgICB9KTtcbiAgICBzdG9wc1sxXS52YWx1ZSArPSAxZS0zO1xuICAgIHN0b3BzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChzLmNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBzLmNvbG9yLnB1c2goMjU1KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdG9wc1swXS5jb2xvclszXSA9IDA7XG4gICAgcmV0dXJuIG5ldyBDb2xvclJhbXAoeyBzdG9wcyB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyBjb2xvciByYW1wIGhhcyBhIHRyYW5zcGFyZW50IHN0YXJ0XG4gICAqL1xuICBoYXNUcmFuc3BhcmVudFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzWzBdLmNvbG9yLmxlbmd0aCA9PT0gNCAmJiB0aGlzWzBdLmNvbG9yWzNdID09PSAwO1xuICB9XG59XG5jb25zdCBDb2xvclJhbXBDb2xsZWN0aW9uID0ge1xuICAvKipcbiAgICogQSBmdWxseSB0cmFuc3BhcmVudCBbMCwgMCwgMCwgMF0gY29sb3JyYW1wIHRvIGhpZGUgZGF0YS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIE5VTEw6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzAsIDAsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICBHUkFZOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgamV0IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBKRVQ6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDEzMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzAsIDYwLCAxNzBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFs1LCAyNTUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzI1NSwgMjU1LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44NzUsIGNvbG9yOiBbMjUwLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxMjgsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBIU1YgY29sb3IgcmFtcCAoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSkuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBIU1Y6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzI1NSwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTY5LCBjb2xvcjogWzI1MywgMjU1LCAyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xNzMsIGNvbG9yOiBbMjQ3LCAyNTUsIDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjMzNywgY29sb3I6IFswLCAyNTIsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM0MSwgY29sb3I6IFswLCAyNTIsIDEwXSB9LFxuICAgICAgeyB2YWx1ZTogMC41MDYsIGNvbG9yOiBbMSwgMjQ5LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY3MSwgY29sb3I6IFsyLCAwLCAyNTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY3NSwgY29sb3I6IFs4LCAwLCAyNTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgzOSwgY29sb3I6IFsyNTUsIDAsIDI1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODQzLCBjb2xvcjogWzI1NSwgMCwgMjQ1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBob3QgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEhPVDogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMywgY29sb3I6IFsyMzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMjU1LCAyMTAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBzcHJpbmcgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFNQUklORzogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjU1LCAwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgc3VtbWVyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBTVU1NRVI6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDEyOCwgMTAyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMTAyXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYXV0b21tbiBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQVVUT01OOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsyNTUsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgd2ludGVyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBXSU5URVI6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMCwgMjU1LCAxMjhdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBib25lIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBCT05FOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzYsIGNvbG9yOiBbODQsIDg0LCAxMTZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1MywgY29sb3I6IFsxNjksIDIwMCwgMjAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY29wcGVyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDT1BQRVI6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgwNCwgY29sb3I6IFsyNTUsIDE2MCwgMTAyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDE5OSwgMTI3XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZ3JleXMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEdSRVlTOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgeWlnbmJ1IGNvbG9yIHJhbXAgKGJsdWUgdG8gbGlnaHQgeWVsbG93KS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFlJR05CVTogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbOCwgMjksIDg4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbMzcsIDUyLCAxNDhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzM0LCA5NCwgMTY4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbMjksIDE0NSwgMTkyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzY1LCAxODIsIDE5Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzEyNywgMjA1LCAxODddIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5OSwgMjMzLCAxODBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyMzcsIDI0OCwgMjE3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjE3XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZ3JlZW5zIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBHUkVFTlM6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDY4LCAyN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzAsIDEwOSwgNDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzM1LCAxMzksIDY5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbNjUsIDE3MSwgOTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTE2LCAxOTYsIDExOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzE2MSwgMjE3LCAxNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5OSwgMjMzLCAxOTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyMjksIDI0NSwgMjI0XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDcsIDI1MiwgMjQ1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgeWlvcnJkIGNvbG9yIHJhbXAgKHJlZCB0byBsaWdodCB5ZWxsb3cpLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgWUlPUlJEOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjgsIDAsIDM4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbMTg5LCAwLCAzOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMjI3LCAyNiwgMjhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFsyNTIsIDc4LCA0Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyNTMsIDE0MSwgNjBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsyNTQsIDE3OCwgNzZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzI1NCwgMjE3LCAxMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyNTUsIDIzNywgMTYwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjA0XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYmx1ZS1yZWQgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEJMVUVSRUQ6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAwLCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcmRidSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUkRCVTogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNSwgMTAsIDE3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzUsIGNvbG9yOiBbMTA2LCAxMzcsIDI0N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxOTAsIDE5MCwgMTkwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzIyMCwgMTcwLCAxMzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjcsIGNvbG9yOiBbMjMwLCAxNDUsIDkwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNzgsIDEwLCAyOF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHBpY25pYyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUElDTklDOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEsIGNvbG9yOiBbNTEsIDE1MywgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yLCBjb2xvcjogWzEwMiwgMjA0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjMsIGNvbG9yOiBbMTUzLCAyMDQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyMDQsIDIwNCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMjU1LCAyMDQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNywgY29sb3I6IFsyNTUsIDE1MywgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44LCBjb2xvcjogWzI1NSwgMTAyLCAyMDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjksIGNvbG9yOiBbMjU1LCAxMDIsIDEwMl0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAwLCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcmFpbmJvdyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUkFJTkJPVzogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTUwLCAwLCA5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzAsIDAsIDIwMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMCwgMjUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzAsIDE1MiwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzQ0LCAyNTUsIDE1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzE1MSwgMjU1LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNTUsIDIzNCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzI1NSwgMTExLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBQb3J0bGFuZCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUE9SVExBTkQ6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEyLCA1MSwgMTMxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMCwgMTM2LCAxODZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjQyLCAyMTEsIDU2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDIsIDE0MywgNTZdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIxNywgMzAsIDMwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYmxhY2tib2R5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBCTEFDS0JPRFk6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjIsIGNvbG9yOiBbMjMwLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzIzMCwgMjEwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC43LCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzE2MCwgMjAwLCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBlYXJ0aCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgRUFSVEg6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDEzMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMSwgY29sb3I6IFswLCAxODAsIDE4MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFs0MCwgMjEwLCA0MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyMzAsIDIzMCwgNTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMTIwLCA3MCwgMjBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBlbGVjdHJpYyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgRUxFQ1RSSUM6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjE1LCBjb2xvcjogWzMwLCAwLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMTIwLCAwLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMTYwLCA5MCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFsyMzAsIDIwMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTAsIDIyMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHZpcmlkaXMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFZJUklESVM6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzY4LCAxLCA4NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNzEsIDQ0LCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzU5LCA4MSwgMTM5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFs0NCwgMTEzLCAxNDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMzMsIDE0NCwgMTQxXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFszOSwgMTczLCAxMjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzkyLCAyMDAsIDk5XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxNzAsIDIyMCwgNTBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1MywgMjMxLCAzN10gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGluZmVybm8gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIElORkVSTk86IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzMxLCAxMiwgNzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzg1LCAxNSwgMTA5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMzYsIDM0LCAxMDZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTg2LCA1NCwgODVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIyNywgODksIDUxXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDksIDE0MCwgMTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzI0OSwgMjAxLCA1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUyLCAyNTUsIDE2NF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIG1hZ21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBNQUdNQTogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjgsIDE2LCA2OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNzksIDE4LCAxMjNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEyOSwgMzcsIDEyOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxODEsIDU0LCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIyOSwgODAsIDEwMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjUxLCAxMzUsIDk3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNTQsIDE5NCwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTIsIDI1MywgMTkxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGxhc21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQTEFTTUE6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEzLCA4LCAxMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzc1LCAzLCAxNjFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzEyNSwgMywgMTY4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNjgsIDM0LCAxNTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjAzLCA3MCwgMTIxXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMjksIDEwNywgOTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzI0OCwgMTQ4LCA2NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjUzLCAxOTUsIDQwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDAsIDI0OSwgMzNdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB3YXJtIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBXQVJNOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjUsIDAsIDE3OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTcyLCAwLCAxODddIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzIxOSwgMCwgMTcwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsyNTUsIDAsIDEzMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyNTUsIDYzLCA3NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjU1LCAxMjMsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIzNCwgMTc2LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxOTAsIDIyOCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTQ3LCAyNTUsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBjb29sIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDT09MOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjUsIDAsIDE3OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTE2LCAwLCAyMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzk4LCA3NCwgMjM3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFs2OCwgMTQ2LCAyMzFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMCwgMjA0LCAxOTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzAsIDI0NywgMTQ2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFswLCAyNTUsIDg4XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFs0MCwgMjU1LCA4XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNDcsIDI1NSwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHJhaW5ib3ogc29mdCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUkFJTkJPV19TT0ZUOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjUsIDAsIDE3OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMSwgY29sb3I6IFsxOTksIDAsIDE4MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFsyNTUsIDAsIDEyMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMywgY29sb3I6IFsyNTUsIDEwOCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyMjIsIDE5NCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxNTAsIDI1NSwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNiwgY29sb3I6IFswLCAyNTUsIDU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43LCBjb2xvcjogWzAsIDI0NiwgMTUwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44LCBjb2xvcjogWzUwLCAxNjcsIDIyMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOSwgY29sb3I6IFsxMDMsIDUxLCAyMzVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzEyNCwgMCwgMTg2XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYmF0aHltZXRyeSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQkFUSFlNRVRSWTogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNDAsIDI2LCA0NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNTksIDQ5LCA5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNjQsIDc2LCAxMzldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzYzLCAxMTAsIDE1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs3MiwgMTQyLCAxNThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzg1LCAxNzQsIDE2M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTIwLCAyMDYsIDE2M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMTg3LCAyMzAsIDE3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUzLCAyNTQsIDIwNF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGNkb20gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENET006IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzQ3LCAxNSwgNjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzg3LCAyMywgODZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzEzMCwgMjgsIDk5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNzEsIDQxLCA5Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyMDYsIDY3LCA4Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjMwLCAxMDYsIDg0XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDIsIDE0OSwgMTAzXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNDksIDE5MywgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTQsIDIzNywgMTc2XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY2hsb3JvcGh5bGwgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENITE9ST1BIWUxMOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxOCwgMzYsIDIwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsyNSwgNjMsIDQxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsyNCwgOTEsIDU5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMywgMTE5LCA3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxOCwgMTQ4LCA4MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbODAsIDE3MywgODldIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzEzMiwgMTk2LCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE3NSwgMjIxLCAxNjJdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIxNSwgMjQ5LCAyMDhdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBkZW5zaXR5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBERU5TSVRZOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs1NCwgMTQsIDM2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs4OSwgMjMsIDgwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMTAsIDQ1LCAxMzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEyMCwgNzcsIDE3OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxMjAsIDExMywgMjEzXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsxMTUsIDE1MSwgMjI4XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxMzQsIDE4NSwgMjI3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxNzcsIDIxNCwgMjI3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMzAsIDI0MSwgMjQxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZnJlZXN1cmZhY2UgYmx1ZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgRlJFRVNVUkZBQ0VfQkxVRTogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMzAsIDQsIDExMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNDcsIDE0LCAxNzZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzQxLCA0NSwgMjM2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsyNSwgOTksIDIxMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs2OCwgMTMxLCAyMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzExNCwgMTU2LCAxOTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE1NywgMTgxLCAyMDNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIwMCwgMjA4LCAyMTZdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI0MSwgMjM3LCAyMzZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBmcmVlc3VyZmFjZSByZWQgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEZSRUVTVVJGQUNFX1JFRDogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNjAsIDksIDE4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsxMDAsIDE3LCAyN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTQyLCAyMCwgMjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzE3NywgNDMsIDI3XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE5MiwgODcsIDYzXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMDUsIDEyNSwgMTA1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyMTYsIDE2MiwgMTQ4XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMjcsIDE5OSwgMTkzXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDEsIDIzNywgMjM2XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgb3h5Z2VuIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBPWFlHRU46IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzY0LCA1LCA1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsxMDYsIDYsIDE1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxNDQsIDI2LCA3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNjgsIDY0LCAzXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE4OCwgMTAwLCA0XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMDYsIDEzNiwgMTFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIyMCwgMTc0LCAyNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjMxLCAyMTUsIDQ0XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDgsIDI1NCwgMTA1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGFyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQQVI6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzUxLCAyMCwgMjRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzkwLCAzMiwgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzEyOSwgNDQsIDM0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNTksIDY4LCAyNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxODIsIDk5LCAxOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMTk5LCAxMzQsIDIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyMTIsIDE3MSwgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIyMSwgMjEwLCA1NF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjI1LCAyNTMsIDc1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGhhc2UgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFBIQVNFOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxNDUsIDEwNSwgMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzE4NCwgNzEsIDM4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxODYsIDU4LCAxMTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzE2MCwgNzEsIDE4NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxMTAsIDk3LCAyMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzUwLCAxMjMsIDE2NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMzEsIDEzMSwgMTEwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFs3NywgMTI5LCAzNF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTQ1LCAxMDUsIDE4XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgc2FsaW5pdHkgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFNBTElOSVRZOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0MiwgMjQsIDEwOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMzMsIDUwLCAxNjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzE1LCA5MCwgMTQ1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFs0MCwgMTE4LCAxMzddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNTksIDE0NiwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFs3OSwgMTc1LCAxMjZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzEyMCwgMjAzLCAxMDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE5MywgMjIxLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1MywgMjM5LCAxNTRdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB0ZW1wZXJhdHVyZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgVEVNUEVSQVRVUkU6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzQsIDM1LCA1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjMsIDUxLCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzg1LCA1OSwgMTU3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMjksIDc5LCAxNDNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTc1LCA5NSwgMTMwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMjIsIDExMiwgMTAxXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDksIDE0NiwgNjZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzI0OSwgMTk2LCA2NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjMyLCAyNTAsIDkxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgdHVyYmlkaXR5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBUVVJCSURJVFk6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzM0LCAzMSwgMjddIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzY1LCA1MCwgNDFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzk4LCA2OSwgNTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEzMSwgODksIDU3XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE2MSwgMTEyLCA1OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMTg1LCAxNDAsIDY2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyMDIsIDE3NCwgODhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIxNiwgMjA5LCAxMjZdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIzMywgMjQ2LCAxNzFdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB2ZWxvY2l0eSBibHVlIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBWRUxPQ0lUWV9CTFVFOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxNywgMzIsIDY0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFszNSwgNTIsIDExNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMjksIDgxLCAxNTZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzMxLCAxMTMsIDE2Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs1MCwgMTQ0LCAxNjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzg3LCAxNzMsIDE3Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTQ5LCAxOTYsIDE4OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjAzLCAyMjEsIDIxMV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU0LCAyNTEsIDIzMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHZlbG9jaXR5IGdyZWVuIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBWRUxPQ0lUWV9HUkVFTjogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjMsIDM1LCAxOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjQsIDY0LCAzOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTEsIDk1LCA0NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMzksIDEyMywgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbOTUsIDE0NiwgMTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzE1MiwgMTY1LCAxOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjAxLCAxODYsIDY5XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMzMsIDIxNiwgMTM3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1MywgMjA1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY3ViZSBoZWxpeCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQ1VCRUhFTElYOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4wNywgY29sb3I6IFsyMiwgNSwgNTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzYwLCA0LCAxMDVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjIsIGNvbG9yOiBbMTA5LCAxLCAxMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI3LCBjb2xvcjogWzE2MSwgMCwgMTQ3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zMywgY29sb3I6IFsyMTAsIDIsIDE0Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyNTEsIDExLCAxMjNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQ3LCBjb2xvcjogWzI1NSwgMjksIDk3XSB9LFxuICAgICAgeyB2YWx1ZTogMC41MywgY29sb3I6IFsyNTUsIDU0LCA2OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNiwgY29sb3I6IFsyNTUsIDg1LCA0Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjcsIGNvbG9yOiBbMjU1LCAxMjAsIDM0XSB9LFxuICAgICAgeyB2YWx1ZTogMC43MywgY29sb3I6IFsyNTUsIDE1NywgMzddIH0sXG4gICAgICB7IHZhbHVlOiAwLjgsIGNvbG9yOiBbMjQxLCAxOTEsIDU3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44NywgY29sb3I6IFsyMjQsIDIyMCwgOTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjkzLCBjb2xvcjogWzIxOCwgMjQxLCAxNDJdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIyNywgMjUzLCAxOThdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGNpdmlkaXMgY29sb3IgcmFtcCBpcyBjb2xvciBibGluZCBmcmllbmRseS5cbiAgICogUmVhZCBtb3JlIGhlcmUgaHR0cHM6Ly9qb3VybmFscy5wbG9zLm9yZy9wbG9zb25lL2FydGljbGU/aWQ9MTAuMTM3MS9qb3VybmFsLnBvbmUuMDE5OTIzOVxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQ0lWSURJUzogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMzIsIDc3LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFs1LCA1NCwgMTEwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzY1LCA3NywgMTA4LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFs5NywgMTAwLCAxMTEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxMjUsIDEyNCwgMTIxLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsxNTYsIDE0OSwgMTIwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5MCwgMTc1LCAxMTEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzIyNSwgMjA0LCA5NCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDIzNSwgNzAsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHR1cmJvIGNvbG9yIHJhbXAuXG4gICAqIFRoaXMgaXMgYSBsdW1pbmFuY2UtY29uc3RhbnQgYWx0ZXJuYXRpdmUgdG8gdGhlIGpldCwgbWFraW5nIGl0IG1vcmVcbiAgICogY2xvci1ibGluZCBmcmllbmRseS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFRVUkJPOiBuZXcgQ29sb3JSYW1wKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0OCwgMTgsIDU5LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFs3MCwgMTA3LCAyMjcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNDAsIDE4NywgMjM2LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFs0OSwgMjQyLCAxNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxNjIsIDI1MiwgNjAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzIzNywgMjA4LCA1OCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNTEsIDEyOCwgMzQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzIxMCwgNDksIDUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTIyLCA0LCAzLCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogVGhlIHJvY2tldCBjb2xvciByYW1wIGlzIHBlcmNlcHR1YWxseSB1bmlmb3JtLCB3aGljaCBtYWtlcyBpdCBtb3JlXG4gICAqIGNvbG9yIGJsaWVuZCBmcmllbmRseSB0aGFuIHRoZSBjbGFzc2ljIG1hZ21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBST0NLRVQ6IG5ldyBDb2xvclJhbXAoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzI1MCwgMjM1LCAyMjEsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzMywgY29sb3I6IFsyNTAsIDIzNSwgMjIxLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI2NiwgY29sb3I6IFsyNDYsIDE3MCwgMTMwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMjQwLCA5NiwgNjcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNTMzLCBjb2xvcjogWzIwMywgMjcsIDc5LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY2NiwgY29sb3I6IFsxMzIsIDMwLCA5MCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44LCBjb2xvcjogWzYzLCAyNywgNjgsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMywgNSwgMjYsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgbWFrbyBjb2xvciByYW1wIGlzIHBlcmNlcHR1YWxseSB1bmlmb3JtIGFuZCBjYW4gYmUgc2VlbiBhc1xuICAgKiBhIGNvbG9yIGJsaW5kIGZyaWVuZGx5IGFsdGVybmF0aXZlIHRvIGJhdGh5bWV0cnkgb3IgeWlnbmJ1LlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgTUFLTzogbmV3IENvbG9yUmFtcCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTEsIDQsIDUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzQzLCAyOCwgNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNjIsIDUzLCAxMDcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzU5LCA4NiwgMTUyLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNTMsIDEyMywgMTYyLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFs1MywgMTU4LCAxNzAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbNzMsIDE5MywgMTczLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsxNTAsIDIyMSwgMTgxLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIyMiwgMjQ1LCAyMjksIDI1NV0gfVxuICAgIF1cbiAgfSlcbn07XG5cbmNvbnN0IGNvbG9yUGFsZXR0ZXMgPSBbXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMWQ1Yjc5NDY4Yjk3ZWY2MjYyZjNhYTYwXG4gIFtcIiMxRDVCNzlcIiwgXCIjNDY4Qjk3XCIsIFwiI0VGNjI2MlwiLCBcIiNGM0FBNjBcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvNjE0YmMzMzNiYmM1ODVlNmM1YzhmZmUwXG4gIFtcIiM2MTRCQzNcIiwgXCIjMzNCQkM1XCIsIFwiIzg1RTZDNVwiLCBcIiNDOEZGRTBcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvNDYxOTU5N2EzMTZmY2Q2Njg4YWVkOGNjXG4gIFtcIiM0NjE5NTlcIiwgXCIjN0EzMTZGXCIsIFwiI0NENjY4OFwiLCBcIiNBRUQ4Q0NcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMDA3OWZmMDBkZmEyZjZmYTcwZmYwMDYwXG4gIFtcIiMwMDc5RkZcIiwgXCIjMDBERkEyXCIsIFwiI0Y2RkE3MFwiLCBcIiNGRjAwNjBcIl0sXG4gIC8vaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8zOWI1ZTBhMzFhY2JmZjc4ZjBmNWVhNWFcbiAgW1wiIzM5QjVFMFwiLCBcIiNBMzFBQ0JcIiwgXCIjRkY3OEYwXCIsIFwiI0Y1RUE1QVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8zN2UyZDU1OTA2OTZjNzBhODBmYmNiMGFcbiAgW1wiIzM3RTJENVwiLCBcIiM1OTA2OTZcIiwgXCIjQzcwQTgwXCIsIFwiI0ZCQ0IwQVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS9mZmQzNmVmZmY1NmQ5OWZmY2Q5ZmI0ZmZcbiAgW1wiI0ZGRDM2RVwiLCBcIiNGRkY1NkRcIiwgXCIjOTlGRkNEXCIsIFwiIzlGQjRGRlwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8wMGVhZDNmZmY1YjdmZjQ0OWYwMDVmOTlcbiAgW1wiIzAwRUFEM1wiLCBcIiNGRkY1QjdcIiwgXCIjRkY0NDlGXCIsIFwiIzAwNUY5OVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8xMGExOWQ1NDAzNzVmZjcwMDBmZmJmMDBcbiAgW1wiIzEwQTE5RFwiLCBcIiM1NDAzNzVcIiwgXCIjRkY3MDAwXCIsIFwiI0ZGQkYwMFwiXVxuXTtcbmZ1bmN0aW9uIGdldFJhbmRvbUNvbG9yKCkge1xuICByZXR1cm4gY29sb3JQYWxldHRlc1t+fihNYXRoLnJhbmRvbSgpICogY29sb3JQYWxldHRlcy5sZW5ndGgpXVt+fihNYXRoLnJhbmRvbSgpICogNCldO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Tb3VyY2VOYW1lKCkge1xuICByZXR1cm4gYG1hcHRpbGVyX3NvdXJjZV8ke2dlbmVyYXRlUmFuZG9tU3RyaW5nKCl9YDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tTGF5ZXJOYW1lKCkge1xuICByZXR1cm4gYG1hcHRpbGVyX2xheWVyXyR7Z2VuZXJhdGVSYW5kb21TdHJpbmcoKX1gO1xufVxuZnVuY3Rpb24gbGVycFpvb21OdW1iZXJWYWx1ZXMoem52LCB6KSB7XG4gIGlmICh6IDw9IHpudlswXS56b29tKSB7XG4gICAgcmV0dXJuIHpudlswXS52YWx1ZTtcbiAgfVxuICBpZiAoeiA+PSB6bnZbem52Lmxlbmd0aCAtIDFdLnpvb20pIHtcbiAgICByZXR1cm4gem52W3pudi5sZW5ndGggLSAxXS52YWx1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHpudi5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBpZiAoeiA+PSB6bnZbaV0uem9vbSAmJiB6IDwgem52W2kgKyAxXS56b29tKSB7XG4gICAgICBjb25zdCB6b29tUmFuZ2UgPSB6bnZbaSArIDFdLnpvb20gLSB6bnZbaV0uem9vbTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWREaXN0YW5jZUZyb21Mb3dlckJvdW5kID0gKHogLSB6bnZbaV0uem9vbSkgLyB6b29tUmFuZ2U7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZERpc3RhbmNlRnJvbUxvd2VyQm91bmQgKiB6bnZbaSArIDFdLnZhbHVlICsgKDEgLSBub3JtYWxpemVkRGlzdGFuY2VGcm9tTG93ZXJCb3VuZCkgKiB6bnZbaV0udmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcGFpbnRDb2xvck9wdGlvbnNUb1BhaW50U3BlYyhjb2xvcikge1xuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiem9vbVwiXSxcbiAgICAuLi5jb2xvci5tYXAoKGVsKSA9PiBbZWwuem9vbSwgZWwudmFsdWVdKS5mbGF0KClcbiAgXTtcbn1cbmZ1bmN0aW9uIHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKHJhbXApIHtcbiAgcmV0dXJuIFtcbiAgICBcImludGVycG9sYXRlXCIsXG4gICAgW1wibGluZWFyXCJdLFxuICAgIFtcInpvb21cIl0sXG4gICAgLi4ucmFtcC5tYXAoKGVsKSA9PiBbZWwuem9vbSwgZWwudmFsdWVdKS5mbGF0KClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYW1wZWRPdXRsaW5lV2lkdGgobGluZVdpZHRoLCBvdXRsaW5lV2lkdGgpIHtcbiAgaWYgKHR5cGVvZiBvdXRsaW5lV2lkdGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGxpbmVXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiAyICogb3V0bGluZVdpZHRoICsgbGluZVdpZHRoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvdXRsaW5lV2lkdGggPT09IFwibnVtYmVyXCIgJiYgQXJyYXkuaXNBcnJheShsaW5lV2lkdGgpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcInpvb21cIl0sXG4gICAgICAuLi5saW5lV2lkdGgubWFwKChlbCkgPT4gW2VsLnpvb20sIDIgKiBvdXRsaW5lV2lkdGggKyBlbC52YWx1ZV0pLmZsYXQoKVxuICAgIF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxpbmVXaWR0aCA9PT0gXCJudW1iZXJcIiAmJiBBcnJheS5pc0FycmF5KG91dGxpbmVXaWR0aCkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJpbnRlcnBvbGF0ZVwiLFxuICAgICAgW1wibGluZWFyXCJdLFxuICAgICAgW1wiem9vbVwiXSxcbiAgICAgIC4uLm91dGxpbmVXaWR0aC5tYXAoKGVsKSA9PiBbZWwuem9vbSwgMiAqIGVsLnZhbHVlICsgbGluZVdpZHRoXSkuZmxhdCgpXG4gICAgXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShsaW5lV2lkdGgpICYmIEFycmF5LmlzQXJyYXkob3V0bGluZVdpZHRoKSkge1xuICAgIGNvbnN0IGFsbFN0b3BzID0gQXJyYXkuZnJvbShcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgICAgLi4ubGluZVdpZHRoLm1hcCgoZWwpID0+IGVsLnpvb20pLFxuICAgICAgICAuLi5vdXRsaW5lV2lkdGgubWFwKChlbCkgPT4gZWwuem9vbSlcbiAgICAgIF0pXG4gICAgKS5zb3J0KChhLCBiKSA9PiBhIDwgYiA/IC0xIDogMSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcInpvb21cIl0sXG4gICAgICAuLi5hbGxTdG9wcy5tYXAoKHopID0+IFtcbiAgICAgICAgeixcbiAgICAgICAgMiAqIGxlcnBab29tTnVtYmVyVmFsdWVzKG91dGxpbmVXaWR0aCwgeikgKyBsZXJwWm9vbU51bWJlclZhbHVlcyhsaW5lV2lkdGgsIHopXG4gICAgICBdKS5mbGF0KClcbiAgICBdO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmFtcGVkUHJvcGVydHlWYWx1ZVdlaWdodChyYW1wLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiZ2V0XCIsIHByb3BlcnR5XSxcbiAgICAuLi5yYW1wLm1hcCgoZWwpID0+IFtlbC5wcm9wZXJ0eVZhbHVlLCBlbC52YWx1ZV0pLmZsYXQoKVxuICBdO1xufVxuZnVuY3Rpb24gZGFzaEFycmF5TWFrZXIocGF0dGVybikge1xuICBjb25zdCBzdGFydFRyaW1tZWRQYXR0ZXJuID0gcGF0dGVybi50cmltU3RhcnQoKTtcbiAgY29uc3QgZml4ZWRQYXR0ZXJuID0gYCR7c3RhcnRUcmltbWVkUGF0dGVybn0ke1wiIFwiLnJlcGVhdChcbiAgICBwYXR0ZXJuLmxlbmd0aCAtIHN0YXJ0VHJpbW1lZFBhdHRlcm4ubGVuZ3RoXG4gICl9YDtcbiAgY29uc3QgcGF0dGVybkFyciA9IEFycmF5LmZyb20oZml4ZWRQYXR0ZXJuKTtcbiAgY29uc3QgaXNPbmx5RGFzaGVzQW5kU3BhY2VzID0gcGF0dGVybkFyci5ldmVyeSgoYykgPT4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJfXCIpO1xuICBpZiAoIWlzT25seURhc2hlc0FuZFNwYWNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBkYXNoIHBhdHRlcm4gbXVzdCBiZSBjb21wb3NlZCBvbmx5IG9mIHdoaXRlc3BhY2UgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycy5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgaGFzQm90aERhc2hlc0FuZFdoaXRlc3BhY2VzID0gcGF0dGVybkFyci5zb21lKChjKSA9PiBjID09PSBcIl9cIikgJiYgcGF0dGVybkFyci5zb21lKChjKSA9PiBjID09PSBcIiBcIik7XG4gIGlmICghaGFzQm90aERhc2hlc0FuZFdoaXRlc3BhY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBIGRhc2ggcGF0dGVybiBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHVuZGVyc2NvcmUgYW5kIG9uZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBkYXNoQXJyYXkgPSBbMV07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0dGVybkFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gcGF0dGVybkFycltpIC0gMV07XG4gICAgY29uc3QgY3VycmVudCA9IHBhdHRlcm5BcnJbaV07XG4gICAgaWYgKHByZXZpb3VzID09PSBjdXJyZW50KSB7XG4gICAgICBkYXNoQXJyYXlbZGFzaEFycmF5Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhc2hBcnJheS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGFzaEFycmF5O1xufVxuZnVuY3Rpb24gY29sb3JEcml2ZW5CeVByb3BlcnR5KHN0eWxlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiZ2V0XCIsIHByb3BlcnR5XSxcbiAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwudmFsdWUsIGVsLmNvbG9yXSkuZmxhdCgpXG4gIF07XG59XG5mdW5jdGlvbiByYWRpdXNEcml2ZW5CeVByb3BlcnR5KHN0eWxlLCBwcm9wZXJ0eSwgem9vbUNvbXBlbnNhdGlvbiA9IHRydWUpIHtcbiAgaWYgKCF6b29tQ29tcGVuc2F0aW9uKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwudmFsdWUsIGVsLnBvaW50UmFkaXVzXSkuZmxhdCgpXG4gICAgXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiem9vbVwiXSxcbiAgICAwLFxuICAgIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwudmFsdWUsIGVsLnBvaW50UmFkaXVzICogMC4wMjVdKS5mbGF0KClcbiAgICBdLFxuICAgIDIsXG4gICAgW1xuICAgICAgXCJpbnRlcnBvbGF0ZVwiLFxuICAgICAgW1wibGluZWFyXCJdLFxuICAgICAgW1wiZ2V0XCIsIHByb3BlcnR5XSxcbiAgICAgIC4uLnN0eWxlLm1hcCgoZWwpID0+IFtlbC52YWx1ZSwgZWwucG9pbnRSYWRpdXMgKiAwLjA1XSkuZmxhdCgpXG4gICAgXSxcbiAgICA0LFxuICAgIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwudmFsdWUsIGVsLnBvaW50UmFkaXVzICogMC4xXSkuZmxhdCgpXG4gICAgXSxcbiAgICA4LFxuICAgIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwudmFsdWUsIGVsLnBvaW50UmFkaXVzICogMC4yNV0pLmZsYXQoKVxuICAgIF0sXG4gICAgMTYsXG4gICAgW1xuICAgICAgXCJpbnRlcnBvbGF0ZVwiLFxuICAgICAgW1wibGluZWFyXCJdLFxuICAgICAgW1wiZ2V0XCIsIHByb3BlcnR5XSxcbiAgICAgIC4uLnN0eWxlLm1hcCgoZWwpID0+IFtlbC52YWx1ZSwgZWwucG9pbnRSYWRpdXNdKS5mbGF0KClcbiAgICBdXG4gIF07XG59XG5mdW5jdGlvbiByYWRpdXNEcml2ZW5CeVByb3BlcnR5SGVhdG1hcChzdHlsZSwgcHJvcGVydHksIHpvb21Db21wZW5zYXRpb24gPSB0cnVlKSB7XG4gIGlmICghem9vbUNvbXBlbnNhdGlvbikge1xuICAgIHJldHVybiBbXG4gICAgICBcImludGVycG9sYXRlXCIsXG4gICAgICBbXCJsaW5lYXJcIl0sXG4gICAgICBbXCJnZXRcIiwgcHJvcGVydHldLFxuICAgICAgLi4uc3R5bGUubWFwKChlbCkgPT4gW2VsLnByb3BlcnR5VmFsdWUsIGVsLnZhbHVlXSkuZmxhdCgpXG4gICAgXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiem9vbVwiXSxcbiAgICAwLFxuICAgIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwucHJvcGVydHlWYWx1ZSwgZWwudmFsdWUgKiAwLjAyNV0pLmZsYXQoKVxuICAgIF0sXG4gICAgMixcbiAgICBbXG4gICAgICBcImludGVycG9sYXRlXCIsXG4gICAgICBbXCJsaW5lYXJcIl0sXG4gICAgICBbXCJnZXRcIiwgcHJvcGVydHldLFxuICAgICAgLi4uc3R5bGUubWFwKChlbCkgPT4gW2VsLnByb3BlcnR5VmFsdWUsIGVsLnZhbHVlICogMC4wNV0pLmZsYXQoKVxuICAgIF0sXG4gICAgNCxcbiAgICBbXG4gICAgICBcImludGVycG9sYXRlXCIsXG4gICAgICBbXCJsaW5lYXJcIl0sXG4gICAgICBbXCJnZXRcIiwgcHJvcGVydHldLFxuICAgICAgLi4uc3R5bGUubWFwKChlbCkgPT4gW2VsLnByb3BlcnR5VmFsdWUsIGVsLnZhbHVlICogMC4xXSkuZmxhdCgpXG4gICAgXSxcbiAgICA4LFxuICAgIFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcImxpbmVhclwiXSxcbiAgICAgIFtcImdldFwiLCBwcm9wZXJ0eV0sXG4gICAgICAuLi5zdHlsZS5tYXAoKGVsKSA9PiBbZWwucHJvcGVydHlWYWx1ZSwgZWwudmFsdWUgKiAwLjI1XSkuZmxhdCgpXG4gICAgXSxcbiAgICAxNixcbiAgICBbXG4gICAgICBcImludGVycG9sYXRlXCIsXG4gICAgICBbXCJsaW5lYXJcIl0sXG4gICAgICBbXCJnZXRcIiwgcHJvcGVydHldLFxuICAgICAgLi4uc3R5bGUubWFwKChlbCkgPT4gW2VsLnByb3BlcnR5VmFsdWUsIGVsLnZhbHVlXSkuZmxhdCgpXG4gICAgXVxuICBdO1xufVxuZnVuY3Rpb24gb3BhY2l0eURyaXZlbkJ5UHJvcGVydHkoY29sb3JyYW1wLCBwcm9wZXJ0eSkge1xuICBpZiAoY29sb3JyYW1wLmV2ZXJ5KChlbCkgPT4gZWwuY29sb3JbM10gPT09IGNvbG9ycmFtcFswXS5jb2xvclszXSkpIHtcbiAgICByZXR1cm4gY29sb3JyYW1wWzBdLmNvbG9yWzNdID8gY29sb3JyYW1wWzBdLmNvbG9yWzNdIC8gMjU1IDogMTtcbiAgfVxuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiZ2V0XCIsIHByb3BlcnR5XSxcbiAgICAuLi5jb2xvcnJhbXAuZ2V0UmF3Q29sb3JTdG9wcygpLm1hcCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZWwudmFsdWU7XG4gICAgICBjb25zdCBjb2xvciA9IGVsLmNvbG9yO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgY29sb3IubGVuZ3RoID09PSA0ID8gY29sb3JbM10gLyAyNTUgOiAxXTtcbiAgICB9KS5mbGF0KClcbiAgXTtcbn1cbmZ1bmN0aW9uIGhlYXRtYXBJbnRlbnNpdHlGcm9tQ29sb3JSYW1wKGNvbG9yUmFtcCwgc3RlcHMgPSAxMCkge1xuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiaGVhdG1hcC1kZW5zaXR5XCJdLFxuICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IHN0ZXBzICsgMSB9LCAoXywgaSkgPT4ge1xuICAgICAgY29uc3QgdW5pdFN0ZXAgPSBpIC8gc3RlcHM7XG4gICAgICByZXR1cm4gW3VuaXRTdGVwLCBjb2xvclJhbXAuZ2V0Q29sb3JIZXgodW5pdFN0ZXApXTtcbiAgICB9KS5mbGF0KClcbiAgXTtcbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gYWRkUG9seWxpbmUoXzAsIF8xKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChtYXAsIG9wdGlvbnMsIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKCFvcHRpb25zLnNvdXJjZUlkICYmICFvcHRpb25zLmRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDcmVhdGluZyBhIHBvbHlsaW5lIGxheWVyIHJlcXVpcmVzIGFuIGV4aXN0aW5nIC5zb3VyY2VJZCBvciBhIHZhbGlkIC5kYXRhIHByb3BlcnR5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGlzVVVJRChkYXRhKSkge1xuICAgICAgICBkYXRhID0gYGh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9kYXRhLyR7b3B0aW9ucy5kYXRhfS9mZWF0dXJlcy5qc29uP2tleT0ke2NvbmZpZy5hcGlLZXl9YDtcbiAgICAgIH0gZWxzZSBpZiAoKChfYSA9IGRhdGEuc3BsaXQoXCIuXCIpLnBvcCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS50cmltKCkpID09PSBcImdweFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKGRhdGEsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGdweFN0ciA9IHlpZWxkIHJlcy50ZXh0KCk7XG4gICAgICAgIGRhdGEgPSBncHgoZ3B4U3RyKTtcbiAgICAgIH0gZWxzZSBpZiAoKChfYiA9IGRhdGEuc3BsaXQoXCIuXCIpLnBvcCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKS50cmltKCkpID09PSBcImttbFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKGRhdGEsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGttbFN0ciA9IHlpZWxkIHJlcy50ZXh0KCk7XG4gICAgICAgIGRhdGEgPSBrbWwoa21sU3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRtcERhdGEgPSAoX2MgPSBqc29uUGFyc2VOb1Rocm93KFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgKSkgIT0gbnVsbCA/IF9jIDogZ3B4T3JLbWwoZGF0YSk7XG4gICAgICAgIGlmICh0bXBEYXRhKVxuICAgICAgICAgIGRhdGEgPSB0bXBEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlBvbHlsaW5lIGRhdGEgd2FzIHByb3ZpZGVkIGFzIHN0cmluZyBidXQgaXMgaW5jb21wYXRpYmxlIHdpdGggdmFsaWQgZm9ybWF0cy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWRkR2VvSlNPTlBvbHlsaW5lKG1hcCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIGRhdGFcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkR2VvSlNPTlBvbHlsaW5lKG1hcCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfciwgX3MsIF90O1xuICBpZiAob3B0aW9ucy5sYXllcklkICYmIG1hcC5nZXRMYXllcihvcHRpb25zLmxheWVySWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEEgbGF5ZXIgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgbGF5ZXIgaWQ6ICR7b3B0aW9ucy5sYXllcklkfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHNvdXJjZUlkID0gKF9hID0gb3B0aW9ucy5zb3VyY2VJZCkgIT0gbnVsbCA/IF9hIDogZ2VuZXJhdGVSYW5kb21Tb3VyY2VOYW1lKCk7XG4gIGNvbnN0IGxheWVySWQgPSAoX2IgPSBvcHRpb25zLmxheWVySWQpICE9IG51bGwgPyBfYiA6IGdlbmVyYXRlUmFuZG9tTGF5ZXJOYW1lKCk7XG4gIGNvbnN0IHJldHVybmVkSW5mbyA9IHtcbiAgICBwb2x5bGluZUxheWVySWQ6IGxheWVySWQsXG4gICAgcG9seWxpbmVPdXRsaW5lTGF5ZXJJZDogXCJcIixcbiAgICBwb2x5bGluZVNvdXJjZUlkOiBzb3VyY2VJZFxuICB9O1xuICBpZiAob3B0aW9ucy5kYXRhICYmICFtYXAuZ2V0U291cmNlKHNvdXJjZUlkKSkge1xuICAgIG1hcC5hZGRTb3VyY2Uoc291cmNlSWQsIHtcbiAgICAgIHR5cGU6IFwiZ2VvanNvblwiLFxuICAgICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGluZVdpZHRoID0gKF9jID0gb3B0aW9ucy5saW5lV2lkdGgpICE9IG51bGwgPyBfYyA6IDM7XG4gIGNvbnN0IGxpbmVDb2xvciA9IChfZCA9IG9wdGlvbnMubGluZUNvbG9yKSAhPSBudWxsID8gX2QgOiBnZXRSYW5kb21Db2xvcigpO1xuICBjb25zdCBsaW5lT3BhY2l0eSA9IChfZSA9IG9wdGlvbnMubGluZU9wYWNpdHkpICE9IG51bGwgPyBfZSA6IDE7XG4gIGNvbnN0IGxpbmVCbHVyID0gKF9mID0gb3B0aW9ucy5saW5lQmx1cikgIT0gbnVsbCA/IF9mIDogMDtcbiAgY29uc3QgbGluZUdhcFdpZHRoID0gKF9nID0gb3B0aW9ucy5saW5lR2FwV2lkdGgpICE9IG51bGwgPyBfZyA6IDA7XG4gIGxldCBsaW5lRGFzaEFycmF5ID0gKF9oID0gb3B0aW9ucy5saW5lRGFzaEFycmF5KSAhPSBudWxsID8gX2ggOiBudWxsO1xuICBjb25zdCBvdXRsaW5lV2lkdGggPSAoX2kgPSBvcHRpb25zLm91dGxpbmVXaWR0aCkgIT0gbnVsbCA/IF9pIDogMTtcbiAgY29uc3Qgb3V0bGluZUNvbG9yID0gKF9qID0gb3B0aW9ucy5vdXRsaW5lQ29sb3IpICE9IG51bGwgPyBfaiA6IFwiI0ZGRkZGRlwiO1xuICBjb25zdCBvdXRsaW5lT3BhY2l0eSA9IChfayA9IG9wdGlvbnMub3V0bGluZU9wYWNpdHkpICE9IG51bGwgPyBfayA6IDE7XG4gIGNvbnN0IG91dGxpbmVCbHVyID0gKF9sID0gb3B0aW9ucy5vdXRsaW5lQmx1cikgIT0gbnVsbCA/IF9sIDogMDtcbiAgaWYgKHR5cGVvZiBsaW5lRGFzaEFycmF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbGluZURhc2hBcnJheSA9IGRhc2hBcnJheU1ha2VyKGxpbmVEYXNoQXJyYXkpO1xuICB9XG4gIGlmIChvcHRpb25zLm91dGxpbmUgPT09IHRydWUpIHtcbiAgICBjb25zdCBvdXRsaW5lTGF5ZXJJZCA9IGAke2xheWVySWR9X291dGxpbmVgO1xuICAgIHJldHVybmVkSW5mby5wb2x5bGluZU91dGxpbmVMYXllcklkID0gb3V0bGluZUxheWVySWQ7XG4gICAgbWFwLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogb3V0bGluZUxheWVySWQsXG4gICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZUlkLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiAoX20gPSBvcHRpb25zLmxpbmVKb2luKSAhPSBudWxsID8gX20gOiBcInJvdW5kXCIsXG4gICAgICAgICAgXCJsaW5lLWNhcFwiOiAoX24gPSBvcHRpb25zLmxpbmVDYXApICE9IG51bGwgPyBfbiA6IFwicm91bmRcIlxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiAoX28gPSBvcHRpb25zLm1pbnpvb20pICE9IG51bGwgPyBfbyA6IDAsXG4gICAgICAgIG1heHpvb206IChfcCA9IG9wdGlvbnMubWF4em9vbSkgIT0gbnVsbCA/IF9wIDogMjMsXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJsaW5lLW9wYWNpdHlcIjogdHlwZW9mIG91dGxpbmVPcGFjaXR5ID09PSBcIm51bWJlclwiID8gb3V0bGluZU9wYWNpdHkgOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhvdXRsaW5lT3BhY2l0eSksXG4gICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IHR5cGVvZiBvdXRsaW5lQ29sb3IgPT09IFwic3RyaW5nXCIgPyBvdXRsaW5lQ29sb3IgOiBwYWludENvbG9yT3B0aW9uc1RvUGFpbnRTcGVjKG91dGxpbmVDb2xvciksXG4gICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IGNvbXB1dGVSYW1wZWRPdXRsaW5lV2lkdGgobGluZVdpZHRoLCBvdXRsaW5lV2lkdGgpLFxuICAgICAgICAgIFwibGluZS1ibHVyXCI6IHR5cGVvZiBvdXRsaW5lQmx1ciA9PT0gXCJudW1iZXJcIiA/IG91dGxpbmVCbHVyIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZUJsdXIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLmJlZm9yZUlkXG4gICAgKTtcbiAgfVxuICBtYXAuYWRkTGF5ZXIoXG4gICAge1xuICAgICAgaWQ6IGxheWVySWQsXG4gICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgIHNvdXJjZTogc291cmNlSWQsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgXCJsaW5lLWpvaW5cIjogKF9xID0gb3B0aW9ucy5saW5lSm9pbikgIT0gbnVsbCA/IF9xIDogXCJyb3VuZFwiLFxuICAgICAgICBcImxpbmUtY2FwXCI6IChfciA9IG9wdGlvbnMubGluZUNhcCkgIT0gbnVsbCA/IF9yIDogXCJyb3VuZFwiXG4gICAgICB9LFxuICAgICAgbWluem9vbTogKF9zID0gb3B0aW9ucy5taW56b29tKSAhPSBudWxsID8gX3MgOiAwLFxuICAgICAgbWF4em9vbTogKF90ID0gb3B0aW9ucy5tYXh6b29tKSAhPSBudWxsID8gX3QgOiAyMyxcbiAgICAgIHBhaW50OiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIFwibGluZS1vcGFjaXR5XCI6IHR5cGVvZiBsaW5lT3BhY2l0eSA9PT0gXCJudW1iZXJcIiA/IGxpbmVPcGFjaXR5IDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMobGluZU9wYWNpdHkpLFxuICAgICAgICBcImxpbmUtY29sb3JcIjogdHlwZW9mIGxpbmVDb2xvciA9PT0gXCJzdHJpbmdcIiA/IGxpbmVDb2xvciA6IHBhaW50Q29sb3JPcHRpb25zVG9QYWludFNwZWMobGluZUNvbG9yKSxcbiAgICAgICAgXCJsaW5lLXdpZHRoXCI6IHR5cGVvZiBsaW5lV2lkdGggPT09IFwibnVtYmVyXCIgPyBsaW5lV2lkdGggOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhsaW5lV2lkdGgpLFxuICAgICAgICBcImxpbmUtYmx1clwiOiB0eXBlb2YgbGluZUJsdXIgPT09IFwibnVtYmVyXCIgPyBsaW5lQmx1ciA6IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKGxpbmVCbHVyKSxcbiAgICAgICAgXCJsaW5lLWdhcC13aWR0aFwiOiB0eXBlb2YgbGluZUdhcFdpZHRoID09PSBcIm51bWJlclwiID8gbGluZUdhcFdpZHRoIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMobGluZUdhcFdpZHRoKVxuICAgICAgfSwgbGluZURhc2hBcnJheSAmJiB7IFwibGluZS1kYXNoYXJyYXlcIjogbGluZURhc2hBcnJheSB9KVxuICAgIH0sXG4gICAgb3B0aW9ucy5iZWZvcmVJZFxuICApO1xuICByZXR1cm4gcmV0dXJuZWRJbmZvO1xufVxuZnVuY3Rpb24gYWRkUG9seWdvbihtYXAsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaztcbiAgaWYgKG9wdGlvbnMubGF5ZXJJZCAmJiBtYXAuZ2V0TGF5ZXIob3B0aW9ucy5sYXllcklkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBIGxheWVyIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIGxheWVyIGlkOiAke29wdGlvbnMubGF5ZXJJZH1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBzb3VyY2VJZCA9IChfYSA9IG9wdGlvbnMuc291cmNlSWQpICE9IG51bGwgPyBfYSA6IGdlbmVyYXRlUmFuZG9tU291cmNlTmFtZSgpO1xuICBjb25zdCBsYXllcklkID0gKF9iID0gb3B0aW9ucy5sYXllcklkKSAhPSBudWxsID8gX2IgOiBnZW5lcmF0ZVJhbmRvbUxheWVyTmFtZSgpO1xuICBjb25zdCByZXR1cm5lZEluZm8gPSB7XG4gICAgcG9seWdvbkxheWVySWQ6IGxheWVySWQsXG4gICAgcG9seWdvbk91dGxpbmVMYXllcklkOiBvcHRpb25zLm91dGxpbmUgPyBgJHtsYXllcklkfV9vdXRsaW5lYCA6IFwiXCIsXG4gICAgcG9seWdvblNvdXJjZUlkOiBzb3VyY2VJZFxuICB9O1xuICBpZiAob3B0aW9ucy5kYXRhICYmICFtYXAuZ2V0U291cmNlKHNvdXJjZUlkKSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBpc1VVSUQoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBgaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL2RhdGEvJHtkYXRhfS9mZWF0dXJlcy5qc29uP2tleT0ke2NvbmZpZy5hcGlLZXl9YDtcbiAgICB9XG4gICAgbWFwLmFkZFNvdXJjZShzb3VyY2VJZCwge1xuICAgICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgbGV0IG91dGxpbmVEYXNoQXJyYXkgPSAoX2MgPSBvcHRpb25zLm91dGxpbmVEYXNoQXJyYXkpICE9IG51bGwgPyBfYyA6IG51bGw7XG4gIGNvbnN0IG91dGxpbmVXaWR0aCA9IChfZCA9IG9wdGlvbnMub3V0bGluZVdpZHRoKSAhPSBudWxsID8gX2QgOiAxO1xuICBjb25zdCBvdXRsaW5lQ29sb3IgPSAoX2UgPSBvcHRpb25zLm91dGxpbmVDb2xvcikgIT0gbnVsbCA/IF9lIDogXCIjRkZGRkZGXCI7XG4gIGNvbnN0IG91dGxpbmVPcGFjaXR5ID0gKF9mID0gb3B0aW9ucy5vdXRsaW5lT3BhY2l0eSkgIT0gbnVsbCA/IF9mIDogMTtcbiAgY29uc3Qgb3V0bGluZUJsdXIgPSAoX2cgPSBvcHRpb25zLm91dGxpbmVCbHVyKSAhPSBudWxsID8gX2cgOiAwO1xuICBjb25zdCBmaWxsQ29sb3IgPSAoX2ggPSBvcHRpb25zLmZpbGxDb2xvcikgIT0gbnVsbCA/IF9oIDogZ2V0UmFuZG9tQ29sb3IoKTtcbiAgY29uc3QgZmlsbE9wYWNpdHkgPSAoX2kgPSBvcHRpb25zLmZpbGxPcGFjaXR5KSAhPSBudWxsID8gX2kgOiAxO1xuICBjb25zdCBvdXRsaW5lUG9zaXRpb24gPSAoX2ogPSBvcHRpb25zLm91dGxpbmVQb3NpdGlvbikgIT0gbnVsbCA/IF9qIDogXCJjZW50ZXJcIjtcbiAgY29uc3QgcGF0dGVybiA9IChfayA9IG9wdGlvbnMucGF0dGVybikgIT0gbnVsbCA/IF9rIDogbnVsbDtcbiAgaWYgKHR5cGVvZiBvdXRsaW5lRGFzaEFycmF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3V0bGluZURhc2hBcnJheSA9IGRhc2hBcnJheU1ha2VyKG91dGxpbmVEYXNoQXJyYXkpO1xuICB9XG4gIGNvbnN0IGFkZExheWVycyA9IChwYXR0ZXJuSW1hZ2VJZCA9IG51bGwpID0+IHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMjtcbiAgICBtYXAuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBsYXllcklkLFxuICAgICAgICB0eXBlOiBcImZpbGxcIixcbiAgICAgICAgc291cmNlOiBzb3VyY2VJZCxcbiAgICAgICAgbWluem9vbTogKF9hMiA9IG9wdGlvbnMubWluem9vbSkgIT0gbnVsbCA/IF9hMiA6IDAsXG4gICAgICAgIG1heHpvb206IChfYjIgPSBvcHRpb25zLm1heHpvb20pICE9IG51bGwgPyBfYjIgOiAyMyxcbiAgICAgICAgcGFpbnQ6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBcImZpbGwtY29sb3JcIjogdHlwZW9mIGZpbGxDb2xvciA9PT0gXCJzdHJpbmdcIiA/IGZpbGxDb2xvciA6IHBhaW50Q29sb3JPcHRpb25zVG9QYWludFNwZWMoZmlsbENvbG9yKSxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0eXBlb2YgZmlsbE9wYWNpdHkgPT09IFwibnVtYmVyXCIgPyBmaWxsT3BhY2l0eSA6IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKGZpbGxPcGFjaXR5KVxuICAgICAgICB9LCBwYXR0ZXJuSW1hZ2VJZCAmJiB7IFwiZmlsbC1wYXR0ZXJuXCI6IHBhdHRlcm5JbWFnZUlkIH0pXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5iZWZvcmVJZFxuICAgICk7XG4gICAgaWYgKG9wdGlvbnMub3V0bGluZSA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbXB1dGVkT3V0bGluZU9mZnNldDtcbiAgICAgIGlmIChvdXRsaW5lUG9zaXRpb24gPT09IFwiaW5zaWRlXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvdXRsaW5lV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb21wdXRlZE91dGxpbmVPZmZzZXQgPSAwLjUgKiBvdXRsaW5lV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZWRPdXRsaW5lT2Zmc2V0ID0gcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMoXG4gICAgICAgICAgICBvdXRsaW5lV2lkdGgubWFwKCh7IHpvb20sIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgIHZhbHVlOiAwLjUgKiB2YWx1ZVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvdXRsaW5lUG9zaXRpb24gPT09IFwib3V0c2lkZVwiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0bGluZVdpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29tcHV0ZWRPdXRsaW5lT2Zmc2V0ID0gLTAuNSAqIG91dGxpbmVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wdXRlZE91dGxpbmVPZmZzZXQgPSByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhcbiAgICAgICAgICAgIG91dGxpbmVXaWR0aC5tYXAoKGVsKSA9PiAoe1xuICAgICAgICAgICAgICB6b29tOiBlbC56b29tLFxuICAgICAgICAgICAgICB2YWx1ZTogLTAuNSAqIGVsLnZhbHVlXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wdXRlZE91dGxpbmVPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgbWFwLmFkZExheWVyKFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IHJldHVybmVkSW5mby5wb2x5Z29uT3V0bGluZUxheWVySWQsXG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2VJZCxcbiAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIFwibGluZS1qb2luXCI6IChfYzIgPSBvcHRpb25zLm91dGxpbmVKb2luKSAhPSBudWxsID8gX2MyIDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgXCJsaW5lLWNhcFwiOiAoX2QyID0gb3B0aW9ucy5vdXRsaW5lQ2FwKSAhPSBudWxsID8gX2QyIDogXCJidXR0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pbnpvb206IChfZTIgPSBvcHRpb25zLm1pbnpvb20pICE9IG51bGwgPyBfZTIgOiAwLFxuICAgICAgICAgIG1heHpvb206IChfZjIgPSBvcHRpb25zLm1heHpvb20pICE9IG51bGwgPyBfZjIgOiAyMyxcbiAgICAgICAgICBwYWludDogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgXCJsaW5lLW9wYWNpdHlcIjogdHlwZW9mIG91dGxpbmVPcGFjaXR5ID09PSBcIm51bWJlclwiID8gb3V0bGluZU9wYWNpdHkgOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhvdXRsaW5lT3BhY2l0eSksXG4gICAgICAgICAgICBcImxpbmUtY29sb3JcIjogdHlwZW9mIG91dGxpbmVDb2xvciA9PT0gXCJzdHJpbmdcIiA/IG91dGxpbmVDb2xvciA6IHBhaW50Q29sb3JPcHRpb25zVG9QYWludFNwZWMob3V0bGluZUNvbG9yKSxcbiAgICAgICAgICAgIFwibGluZS13aWR0aFwiOiB0eXBlb2Ygb3V0bGluZVdpZHRoID09PSBcIm51bWJlclwiID8gb3V0bGluZVdpZHRoIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZVdpZHRoKSxcbiAgICAgICAgICAgIFwibGluZS1ibHVyXCI6IHR5cGVvZiBvdXRsaW5lQmx1ciA9PT0gXCJudW1iZXJcIiA/IG91dGxpbmVCbHVyIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZUJsdXIpLFxuICAgICAgICAgICAgXCJsaW5lLW9mZnNldFwiOiBjb21wdXRlZE91dGxpbmVPZmZzZXRcbiAgICAgICAgICB9LCBvdXRsaW5lRGFzaEFycmF5ICYmIHtcbiAgICAgICAgICAgIFwibGluZS1kYXNoYXJyYXlcIjogb3V0bGluZURhc2hBcnJheVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMuYmVmb3JlSWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBpZiAocGF0dGVybikge1xuICAgIGlmIChtYXAuaGFzSW1hZ2UocGF0dGVybikpIHtcbiAgICAgIGFkZExheWVycyhwYXR0ZXJuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmxvYWRJbWFnZShcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgLy8gKGVycm9yPzogRXJyb3IgfCBudWxsLCBpbWFnZT86IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IG51bGwsIGV4cGlyeT86IEV4cGlyeURhdGEgfCBudWxsKVxuICAgICAgICAoZXJyb3IsIGltYWdlKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgdGhlIHBhdHRlcm4gaW1hZ2UuXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZExheWVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgQW4gaW1hZ2UgY2Fubm90IGJlIGNyZWF0ZWQgZnJvbSB0aGUgcGF0dGVybiBVUkwgJHtwYXR0ZXJufS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFkZExheWVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuYWRkSW1hZ2UocGF0dGVybiwgaW1hZ2UpO1xuICAgICAgICAgIGFkZExheWVycyhwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWRkTGF5ZXJzKCk7XG4gIH1cbiAgcmV0dXJuIHJldHVybmVkSW5mbztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50KG1hcCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3A7XG4gIGlmIChvcHRpb25zLmxheWVySWQgJiYgbWFwLmdldExheWVyKG9wdGlvbnMubGF5ZXJJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQSBsYXllciBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBsYXllciBpZDogJHtvcHRpb25zLmxheWVySWR9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgbWluUG9pbnRSYWRpdXMgPSAoX2EgPSBvcHRpb25zLm1pblBvaW50UmFkaXVzKSAhPSBudWxsID8gX2EgOiAxMDtcbiAgY29uc3QgbWF4UG9pbnRSYWRpdXMgPSAoX2IgPSBvcHRpb25zLm1heFBvaW50UmFkaXVzKSAhPSBudWxsID8gX2IgOiA1MDtcbiAgY29uc3QgY2x1c3RlciA9IChfYyA9IG9wdGlvbnMuY2x1c3RlcikgIT0gbnVsbCA/IF9jIDogZmFsc2U7XG4gIGNvbnN0IG5iRGVmYXVsdERhdGFEcml2ZW5TdHlsZVN0ZXBzID0gMjA7XG4gIGNvbnN0IGNvbG9ycmFtcCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wb2ludENvbG9yKSA/IG9wdGlvbnMucG9pbnRDb2xvciA6IENvbG9yUmFtcENvbGxlY3Rpb24uVFVSQk8uc2NhbGUoXG4gICAgMTAsXG4gICAgb3B0aW9ucy5jbHVzdGVyID8gMWU0IDogMWUzXG4gICkucmVzYW1wbGUoXCJlYXNlLW91dC1zcXVhcmVcIik7XG4gIGNvbnN0IGNvbG9yUmFtcEJvdW5kcyA9IGNvbG9ycmFtcC5nZXRCb3VuZHMoKTtcbiAgY29uc3Qgc291cmNlSWQgPSAoX2QgPSBvcHRpb25zLnNvdXJjZUlkKSAhPSBudWxsID8gX2QgOiBnZW5lcmF0ZVJhbmRvbVNvdXJjZU5hbWUoKTtcbiAgY29uc3QgbGF5ZXJJZCA9IChfZSA9IG9wdGlvbnMubGF5ZXJJZCkgIT0gbnVsbCA/IF9lIDogZ2VuZXJhdGVSYW5kb21MYXllck5hbWUoKTtcbiAgY29uc3Qgc2hvd0xhYmVsID0gKF9mID0gb3B0aW9ucy5zaG93TGFiZWwpICE9IG51bGwgPyBfZiA6IGNsdXN0ZXI7XG4gIGNvbnN0IGFsaWduT25WaWV3cG9ydCA9IChfZyA9IG9wdGlvbnMuYWxpZ25PblZpZXdwb3J0KSAhPSBudWxsID8gX2cgOiB0cnVlO1xuICBjb25zdCBvdXRsaW5lID0gKF9oID0gb3B0aW9ucy5vdXRsaW5lKSAhPSBudWxsID8gX2ggOiBmYWxzZTtcbiAgY29uc3Qgb3V0bGluZU9wYWNpdHkgPSAoX2kgPSBvcHRpb25zLm91dGxpbmVPcGFjaXR5KSAhPSBudWxsID8gX2kgOiAxO1xuICBjb25zdCBvdXRsaW5lV2lkdGggPSAoX2ogPSBvcHRpb25zLm91dGxpbmVXaWR0aCkgIT0gbnVsbCA/IF9qIDogMTtcbiAgY29uc3Qgb3V0bGluZUNvbG9yID0gKF9rID0gb3B0aW9ucy5vdXRsaW5lQ29sb3IpICE9IG51bGwgPyBfayA6IFwiI0ZGRkZGRlwiO1xuICBsZXQgcG9pbnRPcGFjaXR5O1xuICBjb25zdCB6b29tQ29tcGVuc2F0aW9uID0gKF9sID0gb3B0aW9ucy56b29tQ29tcGVuc2F0aW9uKSAhPSBudWxsID8gX2wgOiB0cnVlO1xuICBjb25zdCBtaW56b29tID0gKF9tID0gb3B0aW9ucy5taW56b29tKSAhPSBudWxsID8gX20gOiAwO1xuICBjb25zdCBtYXh6b29tID0gKF9uID0gb3B0aW9ucy5tYXh6b29tKSAhPSBudWxsID8gX24gOiAyMztcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnBvaW50T3BhY2l0eSA9PT0gXCJudW1iZXJcIikge1xuICAgIHBvaW50T3BhY2l0eSA9IG9wdGlvbnMucG9pbnRPcGFjaXR5O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wb2ludE9wYWNpdHkpKSB7XG4gICAgcG9pbnRPcGFjaXR5ID0gcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3B0aW9ucy5wb2ludE9wYWNpdHkpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY2x1c3Rlcikge1xuICAgIHBvaW50T3BhY2l0eSA9IG9wYWNpdHlEcml2ZW5CeVByb3BlcnR5KGNvbG9ycmFtcCwgXCJwb2ludF9jb3VudFwiKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnByb3BlcnR5KSB7XG4gICAgcG9pbnRPcGFjaXR5ID0gb3BhY2l0eURyaXZlbkJ5UHJvcGVydHkoY29sb3JyYW1wLCBvcHRpb25zLnByb3BlcnR5KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludE9wYWNpdHkgPSByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhbXG4gICAgICB7IHpvb206IG1pbnpvb20sIHZhbHVlOiAwIH0sXG4gICAgICB7IHpvb206IG1pbnpvb20gKyAwLjI1LCB2YWx1ZTogMSB9LFxuICAgICAgeyB6b29tOiBtYXh6b29tIC0gMC4yNSwgdmFsdWU6IDEgfSxcbiAgICAgIHsgem9vbTogbWF4em9vbSwgdmFsdWU6IDAgfVxuICAgIF0pO1xuICB9XG4gIGNvbnN0IHJldHVybmVkSW5mbyA9IHtcbiAgICBwb2ludExheWVySWQ6IGxheWVySWQsXG4gICAgY2x1c3RlckxheWVySWQ6IFwiXCIsXG4gICAgbGFiZWxMYXllcklkOiBcIlwiLFxuICAgIHBvaW50U291cmNlSWQ6IHNvdXJjZUlkXG4gIH07XG4gIGlmIChvcHRpb25zLmRhdGEgJiYgIW1hcC5nZXRTb3VyY2Uoc291cmNlSWQpKSB7XG4gICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGlzVVVJRChkYXRhKSkge1xuICAgICAgZGF0YSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke2RhdGF9L2ZlYXR1cmVzLmpzb24/a2V5PSR7Y29uZmlnLmFwaUtleX1gO1xuICAgIH1cbiAgICBtYXAuYWRkU291cmNlKHNvdXJjZUlkLCB7XG4gICAgICB0eXBlOiBcImdlb2pzb25cIixcbiAgICAgIGRhdGEsXG4gICAgICBjbHVzdGVyXG4gICAgfSk7XG4gIH1cbiAgaWYgKGNsdXN0ZXIpIHtcbiAgICByZXR1cm5lZEluZm8uY2x1c3RlckxheWVySWQgPSBgJHtsYXllcklkfV9jbHVzdGVyYDtcbiAgICBjb25zdCBjbHVzdGVyU3R5bGUgPSBBcnJheS5mcm9tKFxuICAgICAgeyBsZW5ndGg6IG5iRGVmYXVsdERhdGFEcml2ZW5TdHlsZVN0ZXBzIH0sXG4gICAgICAoXywgaSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbG9yUmFtcEJvdW5kcy5taW4gKyBpICogKGNvbG9yUmFtcEJvdW5kcy5tYXggLSBjb2xvclJhbXBCb3VuZHMubWluKSAvIChuYkRlZmF1bHREYXRhRHJpdmVuU3R5bGVTdGVwcyAtIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHBvaW50UmFkaXVzOiBtaW5Qb2ludFJhZGl1cyArIChtYXhQb2ludFJhZGl1cyAtIG1pblBvaW50UmFkaXVzKSAqIE1hdGgucG93KGkgLyAobmJEZWZhdWx0RGF0YURyaXZlblN0eWxlU3RlcHMgLSAxKSwgMC41KSxcbiAgICAgICAgICBjb2xvcjogY29sb3JyYW1wLmdldENvbG9ySGV4KHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gICAgbWFwLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogcmV0dXJuZWRJbmZvLmNsdXN0ZXJMYXllcklkLFxuICAgICAgICB0eXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZUlkLFxuICAgICAgICBmaWx0ZXI6IFtcImhhc1wiLCBcInBvaW50X2NvdW50XCJdLFxuICAgICAgICBwYWludDogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIC8vICdjaXJjbGUtY29sb3InOiBvcHRpb25zLnBvaW50Q29sb3IgPz8gY29sb3JEcml2ZW5CeVByb3BlcnR5KGNsdXN0ZXJTdHlsZSwgXCJwb2ludF9jb3VudFwiKSxcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiB0eXBlb2Ygb3B0aW9ucy5wb2ludENvbG9yID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5wb2ludENvbG9yIDogY29sb3JEcml2ZW5CeVByb3BlcnR5KGNsdXN0ZXJTdHlsZSwgXCJwb2ludF9jb3VudFwiKSxcbiAgICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogdHlwZW9mIG9wdGlvbnMucG9pbnRSYWRpdXMgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnBvaW50UmFkaXVzIDogQXJyYXkuaXNBcnJheShvcHRpb25zLnBvaW50UmFkaXVzKSA/IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKG9wdGlvbnMucG9pbnRSYWRpdXMpIDogcmFkaXVzRHJpdmVuQnlQcm9wZXJ0eShjbHVzdGVyU3R5bGUsIFwicG9pbnRfY291bnRcIiwgZmFsc2UpLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiBhbGlnbk9uVmlld3BvcnQgPyBcInZpZXdwb3J0XCIgOiBcIm1hcFwiLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IFwibWFwXCIsXG4gICAgICAgICAgLy8gc2NhbGUgd2l0aCBjYW1lcmEgZGlzdGFuY2UgcmVnYXJkbGVzcyBvZiB2aWV3cG9ydC9iaWV3cG9ydCBhbGlnbmVtZW50XG4gICAgICAgICAgXCJjaXJjbGUtb3BhY2l0eVwiOiBwb2ludE9wYWNpdHlcbiAgICAgICAgfSwgb3V0bGluZSAmJiB7XG4gICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjogdHlwZW9mIG91dGxpbmVPcGFjaXR5ID09PSBcIm51bWJlclwiID8gb3V0bGluZU9wYWNpdHkgOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhvdXRsaW5lT3BhY2l0eSksXG4gICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IHR5cGVvZiBvdXRsaW5lV2lkdGggPT09IFwibnVtYmVyXCIgPyBvdXRsaW5lV2lkdGggOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhvdXRsaW5lV2lkdGgpLFxuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB0eXBlb2Ygb3V0bGluZUNvbG9yID09PSBcInN0cmluZ1wiID8gb3V0bGluZUNvbG9yIDogcGFpbnRDb2xvck9wdGlvbnNUb1BhaW50U3BlYyhvdXRsaW5lQ29sb3IpXG4gICAgICAgIH0pLFxuICAgICAgICBtaW56b29tLFxuICAgICAgICBtYXh6b29tXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5iZWZvcmVJZFxuICAgICk7XG4gICAgbWFwLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogcmV0dXJuZWRJbmZvLnBvaW50TGF5ZXJJZCxcbiAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc291cmNlOiBzb3VyY2VJZCxcbiAgICAgICAgZmlsdGVyOiBbXCIhXCIsIFtcImhhc1wiLCBcInBvaW50X2NvdW50XCJdXSxcbiAgICAgICAgcGFpbnQ6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjogYWxpZ25PblZpZXdwb3J0ID8gXCJ2aWV3cG9ydFwiIDogXCJtYXBcIixcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1zY2FsZVwiOiBcIm1hcFwiLFxuICAgICAgICAgIC8vIHNjYWxlIHdpdGggY2FtZXJhIGRpc3RhbmNlIHJlZ2FyZGxlc3Mgb2Ygdmlld3BvcnQvYmlld3BvcnQgYWxpZ25lbWVudFxuICAgICAgICAgIC8vICdjaXJjbGUtY29sb3InOiAgb3B0aW9ucy5wb2ludENvbG9yID8/IGNsdXN0ZXJTdHlsZVswXS5jb2xvcixcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiB0eXBlb2Ygb3B0aW9ucy5wb2ludENvbG9yID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5wb2ludENvbG9yIDogY29sb3JyYW1wLmdldENvbG9ySGV4KGNvbG9ycmFtcC5nZXRCb3VuZHMoKS5taW4pLFxuICAgICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiB0eXBlb2Ygb3B0aW9ucy5wb2ludFJhZGl1cyA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucG9pbnRSYWRpdXMgOiBBcnJheS5pc0FycmF5KG9wdGlvbnMucG9pbnRSYWRpdXMpID8gcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3B0aW9ucy5wb2ludFJhZGl1cykgOiBjbHVzdGVyU3R5bGVbMF0ucG9pbnRSYWRpdXMgKiAwLjc1LFxuICAgICAgICAgIFwiY2lyY2xlLW9wYWNpdHlcIjogcG9pbnRPcGFjaXR5XG4gICAgICAgIH0sIG91dGxpbmUgJiYge1xuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHR5cGVvZiBvdXRsaW5lT3BhY2l0eSA9PT0gXCJudW1iZXJcIiA/IG91dGxpbmVPcGFjaXR5IDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZU9wYWNpdHkpLFxuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB0eXBlb2Ygb3V0bGluZVdpZHRoID09PSBcIm51bWJlclwiID8gb3V0bGluZVdpZHRoIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZVdpZHRoKSxcbiAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogdHlwZW9mIG91dGxpbmVDb2xvciA9PT0gXCJzdHJpbmdcIiA/IG91dGxpbmVDb2xvciA6IHBhaW50Q29sb3JPcHRpb25zVG9QYWludFNwZWMob3V0bGluZUNvbG9yKVxuICAgICAgICB9KSxcbiAgICAgICAgbWluem9vbSxcbiAgICAgICAgbWF4em9vbVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMuYmVmb3JlSWRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludENvbG9yID0gdHlwZW9mIG9wdGlvbnMucG9pbnRDb2xvciA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMucG9pbnRDb2xvciA6IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wb2ludENvbG9yKSA/IG9wdGlvbnMucG9pbnRDb2xvci5nZXRDb2xvckhleChvcHRpb25zLnBvaW50Q29sb3IuZ2V0Qm91bmRzKCkubWluKSA6IGdldFJhbmRvbUNvbG9yKCk7XG4gICAgbGV0IHBvaW50UmFkaXVzID0gdHlwZW9mIG9wdGlvbnMucG9pbnRSYWRpdXMgPT09IFwibnVtYmVyXCIgPyB6b29tQ29tcGVuc2F0aW9uID8gcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMoW1xuICAgICAgeyB6b29tOiAwLCB2YWx1ZTogb3B0aW9ucy5wb2ludFJhZGl1cyAqIDAuMDI1IH0sXG4gICAgICB7IHpvb206IDIsIHZhbHVlOiBvcHRpb25zLnBvaW50UmFkaXVzICogMC4wNSB9LFxuICAgICAgeyB6b29tOiA0LCB2YWx1ZTogb3B0aW9ucy5wb2ludFJhZGl1cyAqIDAuMSB9LFxuICAgICAgeyB6b29tOiA4LCB2YWx1ZTogb3B0aW9ucy5wb2ludFJhZGl1cyAqIDAuMjUgfSxcbiAgICAgIHsgem9vbTogMTYsIHZhbHVlOiBvcHRpb25zLnBvaW50UmFkaXVzICogMSB9XG4gICAgXSkgOiBvcHRpb25zLnBvaW50UmFkaXVzIDogQXJyYXkuaXNBcnJheShvcHRpb25zLnBvaW50UmFkaXVzKSA/IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKG9wdGlvbnMucG9pbnRSYWRpdXMpIDogem9vbUNvbXBlbnNhdGlvbiA/IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKFtcbiAgICAgIHsgem9vbTogMCwgdmFsdWU6IG1pblBvaW50UmFkaXVzICogMC4wNSB9LFxuICAgICAgeyB6b29tOiAyLCB2YWx1ZTogbWluUG9pbnRSYWRpdXMgKiAwLjEgfSxcbiAgICAgIHsgem9vbTogNCwgdmFsdWU6IG1pblBvaW50UmFkaXVzICogMC4yIH0sXG4gICAgICB7IHpvb206IDgsIHZhbHVlOiBtaW5Qb2ludFJhZGl1cyAqIDAuNSB9LFxuICAgICAgeyB6b29tOiAxNiwgdmFsdWU6IG1pblBvaW50UmFkaXVzICogMSB9XG4gICAgXSkgOiBtaW5Qb2ludFJhZGl1cztcbiAgICBpZiAob3B0aW9ucy5wcm9wZXJ0eSAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMucG9pbnRDb2xvcikpIHtcbiAgICAgIGNvbnN0IGRhdGFEcml2ZW5TdHlsZSA9IEFycmF5LmZyb20oXG4gICAgICAgIHsgbGVuZ3RoOiBuYkRlZmF1bHREYXRhRHJpdmVuU3R5bGVTdGVwcyB9LFxuICAgICAgICAoXywgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29sb3JSYW1wQm91bmRzLm1pbiArIGkgKiAoY29sb3JSYW1wQm91bmRzLm1heCAtIGNvbG9yUmFtcEJvdW5kcy5taW4pIC8gKG5iRGVmYXVsdERhdGFEcml2ZW5TdHlsZVN0ZXBzIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcG9pbnRSYWRpdXM6IHR5cGVvZiBvcHRpb25zLnBvaW50UmFkaXVzID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5wb2ludFJhZGl1cyA6IG1pblBvaW50UmFkaXVzICsgKG1heFBvaW50UmFkaXVzIC0gbWluUG9pbnRSYWRpdXMpICogTWF0aC5wb3coaSAvIChuYkRlZmF1bHREYXRhRHJpdmVuU3R5bGVTdGVwcyAtIDEpLCAwLjUpLFxuICAgICAgICAgICAgY29sb3I6IHR5cGVvZiBvcHRpb25zLnBvaW50Q29sb3IgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnBvaW50Q29sb3IgOiBjb2xvcnJhbXAuZ2V0Q29sb3JIZXgodmFsdWUpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHBvaW50Q29sb3IgPSBjb2xvckRyaXZlbkJ5UHJvcGVydHkoZGF0YURyaXZlblN0eWxlLCBvcHRpb25zLnByb3BlcnR5KTtcbiAgICAgIHBvaW50UmFkaXVzID0gcmFkaXVzRHJpdmVuQnlQcm9wZXJ0eShcbiAgICAgICAgZGF0YURyaXZlblN0eWxlLFxuICAgICAgICBvcHRpb25zLnByb3BlcnR5LFxuICAgICAgICB6b29tQ29tcGVuc2F0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBtYXAuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiByZXR1cm5lZEluZm8ucG9pbnRMYXllcklkLFxuICAgICAgICB0eXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZUlkLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAvLyBDb250cmFyeSB0byBsYWJlbHMsIHdlIHdhbnQgdG8gc2VlIHRoZSBzbWFsbCBvbmUgaW4gZnJvbnQuIFdlaXJkbHkgXCJjaXJjbGUtc29ydC1rZXlcIiB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGFzIFwic3ltYm9sLXNvcnQta2V5XCIuXG4gICAgICAgICAgXCJjaXJjbGUtc29ydC1rZXlcIjogb3B0aW9ucy5wcm9wZXJ0eSA/IFtcIi9cIiwgMSwgW1wiZ2V0XCIsIG9wdGlvbnMucHJvcGVydHldXSA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjogYWxpZ25PblZpZXdwb3J0ID8gXCJ2aWV3cG9ydFwiIDogXCJtYXBcIixcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1zY2FsZVwiOiBcIm1hcFwiLFxuICAgICAgICAgIC8vIHNjYWxlIHdpdGggY2FtZXJhIGRpc3RhbmNlIHJlZ2FyZGxlc3Mgb2Ygdmlld3BvcnQvYmlld3BvcnQgYWxpZ25lbWVudFxuICAgICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IHBvaW50Q29sb3IsXG4gICAgICAgICAgXCJjaXJjbGUtb3BhY2l0eVwiOiBwb2ludE9wYWNpdHksXG4gICAgICAgICAgXCJjaXJjbGUtcmFkaXVzXCI6IHBvaW50UmFkaXVzXG4gICAgICAgIH0sIG91dGxpbmUgJiYge1xuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHR5cGVvZiBvdXRsaW5lT3BhY2l0eSA9PT0gXCJudW1iZXJcIiA/IG91dGxpbmVPcGFjaXR5IDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZU9wYWNpdHkpLFxuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB0eXBlb2Ygb3V0bGluZVdpZHRoID09PSBcIm51bWJlclwiID8gb3V0bGluZVdpZHRoIDogcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMob3V0bGluZVdpZHRoKSxcbiAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogdHlwZW9mIG91dGxpbmVDb2xvciA9PT0gXCJzdHJpbmdcIiA/IG91dGxpbmVDb2xvciA6IHBhaW50Q29sb3JPcHRpb25zVG9QYWludFNwZWMob3V0bGluZUNvbG9yKVxuICAgICAgICB9KSxcbiAgICAgICAgbWluem9vbSxcbiAgICAgICAgbWF4em9vbVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMuYmVmb3JlSWRcbiAgICApO1xuICB9XG4gIGlmIChzaG93TGFiZWwgIT09IGZhbHNlICYmIChvcHRpb25zLmNsdXN0ZXIgfHwgb3B0aW9ucy5wcm9wZXJ0eSkpIHtcbiAgICByZXR1cm5lZEluZm8ubGFiZWxMYXllcklkID0gYCR7bGF5ZXJJZH1fbGFiZWxgO1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSAoX28gPSBvcHRpb25zLmxhYmVsQ29sb3IpICE9IG51bGwgPyBfbyA6IFwiI2ZmZlwiO1xuICAgIGNvbnN0IGxhYmVsU2l6ZSA9IChfcCA9IG9wdGlvbnMubGFiZWxTaXplKSAhPSBudWxsID8gX3AgOiAxMjtcbiAgICBtYXAuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiByZXR1cm5lZEluZm8ubGFiZWxMYXllcklkLFxuICAgICAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZUlkLFxuICAgICAgICBmaWx0ZXI6IFtcbiAgICAgICAgICBcImhhc1wiLFxuICAgICAgICAgIG9wdGlvbnMuY2x1c3RlciA/IFwicG9pbnRfY291bnRcIiA6IG9wdGlvbnMucHJvcGVydHlcbiAgICAgICAgXSxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgXCJ0ZXh0LWZpZWxkXCI6IG9wdGlvbnMuY2x1c3RlciA/IFwie3BvaW50X2NvdW50X2FiYnJldmlhdGVkfVwiIDogYHske29wdGlvbnMucHJvcGVydHl9fWAsXG4gICAgICAgICAgXCJ0ZXh0LWZvbnRcIjogW1wiTm90byBTYW5zIFJlZ3VsYXJcIl0sXG4gICAgICAgICAgXCJ0ZXh0LXNpemVcIjogbGFiZWxTaXplLFxuICAgICAgICAgIFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIjogYWxpZ25PblZpZXdwb3J0ID8gXCJ2aWV3cG9ydFwiIDogXCJtYXBcIixcbiAgICAgICAgICBcInN5bWJvbC1zb3J0LWtleVwiOiBbXG4gICAgICAgICAgICBcIi9cIixcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFwiZ2V0XCIsXG4gICAgICAgICAgICAgIG9wdGlvbnMuY2x1c3RlciA/IFwicG9pbnRfY291bnRcIiA6IG9wdGlvbnMucHJvcGVydHlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICBdXG4gICAgICAgICAgLy8gc28gdGhhdCB0aGUgbGFyZ2VzdCB2YWx1ZSBnb2VzIG9uIHRvcFxuICAgICAgICB9LFxuICAgICAgICBwYWludDoge1xuICAgICAgICAgIFwidGV4dC1jb2xvclwiOiBsYWJlbENvbG9yLFxuICAgICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IHBvaW50T3BhY2l0eVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tLFxuICAgICAgICBtYXh6b29tXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5iZWZvcmVJZFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJldHVybmVkSW5mbztcbn1cbmZ1bmN0aW9uIGFkZEhlYXRtYXAobWFwLCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgaWYgKG9wdGlvbnMubGF5ZXJJZCAmJiBtYXAuZ2V0TGF5ZXIob3B0aW9ucy5sYXllcklkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBIGxheWVyIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIGxheWVyIGlkOiAke29wdGlvbnMubGF5ZXJJZH1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBzb3VyY2VJZCA9IChfYSA9IG9wdGlvbnMuc291cmNlSWQpICE9IG51bGwgPyBfYSA6IGdlbmVyYXRlUmFuZG9tU291cmNlTmFtZSgpO1xuICBjb25zdCBsYXllcklkID0gKF9iID0gb3B0aW9ucy5sYXllcklkKSAhPSBudWxsID8gX2IgOiBnZW5lcmF0ZVJhbmRvbUxheWVyTmFtZSgpO1xuICBjb25zdCBtaW56b29tID0gKF9jID0gb3B0aW9ucy5taW56b29tKSAhPSBudWxsID8gX2MgOiAwO1xuICBjb25zdCBtYXh6b29tID0gKF9kID0gb3B0aW9ucy5tYXh6b29tKSAhPSBudWxsID8gX2QgOiAyMztcbiAgY29uc3Qgem9vbUNvbXBlbnNhdGlvbiA9IChfZSA9IG9wdGlvbnMuem9vbUNvbXBlbnNhdGlvbikgIT0gbnVsbCA/IF9lIDogdHJ1ZTtcbiAgY29uc3Qgb3BhY2l0eSA9IChfZiA9IG9wdGlvbnMub3BhY2l0eSkgIT0gbnVsbCA/IF9mIDogW1xuICAgIHsgem9vbTogbWluem9vbSwgdmFsdWU6IDAgfSxcbiAgICB7IHpvb206IG1pbnpvb20gKyAwLjI1LCB2YWx1ZTogMSB9LFxuICAgIHsgem9vbTogbWF4em9vbSAtIDAuMjUsIHZhbHVlOiAxIH0sXG4gICAgeyB6b29tOiBtYXh6b29tLCB2YWx1ZTogMCB9XG4gIF07XG4gIGxldCBjb2xvclJhbXAgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY29sb3JSYW1wKSA/IG9wdGlvbnMuY29sb3JSYW1wIDogQ29sb3JSYW1wQ29sbGVjdGlvbi5UVVJCTy50cmFuc3BhcmVudFN0YXJ0KCk7XG4gIGNvbnN0IGNyQm91bmRzID0gY29sb3JSYW1wLmdldEJvdW5kcygpO1xuICBpZiAoY3JCb3VuZHMubWluICE9PSAwIHx8IGNyQm91bmRzLm1heCAhPT0gMSkge1xuICAgIGNvbG9yUmFtcCA9IGNvbG9yUmFtcC5zY2FsZSgwLCAxKTtcbiAgfVxuICBpZiAoIWNvbG9yUmFtcC5oYXNUcmFuc3BhcmVudFN0YXJ0KCkpIHtcbiAgICBjb2xvclJhbXAgPSBjb2xvclJhbXAudHJhbnNwYXJlbnRTdGFydCgpO1xuICB9XG4gIGNvbnN0IGludGVuc2l0eSA9IChfZyA9IG9wdGlvbnMuaW50ZW5zaXR5KSAhPSBudWxsID8gX2cgOiBbXG4gICAgeyB6b29tOiAwLCB2YWx1ZTogMC4wMSB9LFxuICAgIHsgem9vbTogNCwgdmFsdWU6IDAuMiB9LFxuICAgIHsgem9vbTogMTYsIHZhbHVlOiAxIH1cbiAgXTtcbiAgY29uc3QgcHJvcGVydHkgPSAoX2ggPSBvcHRpb25zLnByb3BlcnR5KSAhPSBudWxsID8gX2ggOiBudWxsO1xuICBjb25zdCBwcm9wZXJ0eVZhbHVlV2VpZ2h0ID0gKF9pID0gb3B0aW9ucy53ZWlnaHQpICE9IG51bGwgPyBfaSA6IDE7XG4gIGxldCBoZWF0bWFwV2VpZ2h0ID0gMTtcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eVZhbHVlV2VpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBoZWF0bWFwV2VpZ2h0ID0gcHJvcGVydHlWYWx1ZVdlaWdodDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53ZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIG9wdGlvbiBgLnByb3BlcnR5YCBpcyBpZ25vcmVkIHdoZW4gYC5wcm9wZXJ0eVZhbHVlV2VpZ2h0c2AgaXMgbm90IG9mIHR5cGUgYFByb3BlcnR5VmFsdWVXZWlnaHRzYFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5VmFsdWVXZWlnaHQpKSB7XG4gICAgICBoZWF0bWFwV2VpZ2h0ID0gcmFtcGVkUHJvcGVydHlWYWx1ZVdlaWdodChwcm9wZXJ0eVZhbHVlV2VpZ2h0LCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgb3B0aW9uIGAucHJvcGVydHlgIGlzIGlnbm9yZWQgd2hlbiBgLnByb3BlcnR5VmFsdWVXZWlnaHRzYCBpcyBub3Qgb2YgdHlwZSBgUHJvcGVydHlWYWx1ZVdlaWdodHNgXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHlWYWx1ZVdlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaGVhdG1hcFdlaWdodCA9IHByb3BlcnR5VmFsdWVXZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5VmFsdWVXZWlnaHQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlIG9wdGlvbnMgYC5wcm9wZXJ0eVZhbHVlV2VpZ2h0c2AgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGAucHJvcGVydHlgIGlzIHByb3ZpZGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWZhdWx0UmFkaXVzWm9vbVJhbXBpbmcgPSBbXG4gICAgeyB6b29tOiAwLCB2YWx1ZTogNTAgKiAwLjAyNSB9LFxuICAgIHsgem9vbTogMiwgdmFsdWU6IDUwICogMC4wNSB9LFxuICAgIHsgem9vbTogNCwgdmFsdWU6IDUwICogMC4xIH0sXG4gICAgeyB6b29tOiA4LCB2YWx1ZTogNTAgKiAwLjI1IH0sXG4gICAgeyB6b29tOiAxNiwgdmFsdWU6IDUwIH1cbiAgXTtcbiAgY29uc3QgcmFkaXVzID0gKF9qID0gb3B0aW9ucy5yYWRpdXMpICE9IG51bGwgPyBfaiA6IHpvb21Db21wZW5zYXRpb24gPyBkZWZhdWx0UmFkaXVzWm9vbVJhbXBpbmcgOiAxMDtcbiAgbGV0IHJhZGl1c0hlYXRtYXAgPSAxO1xuICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gXCJudW1iZXJcIikge1xuICAgIHJhZGl1c0hlYXRtYXAgPSByYWRpdXM7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyYWRpdXMpICYmIFwiem9vbVwiIGluIHJhZGl1c1swXSkge1xuICAgIHJhZGl1c0hlYXRtYXAgPSByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhyYWRpdXMpO1xuICB9IGVsc2UgaWYgKHByb3BlcnR5ICYmIEFycmF5LmlzQXJyYXkocmFkaXVzKSAmJiBcInByb3BlcnR5VmFsdWVcIiBpbiByYWRpdXNbMF0pIHtcbiAgICByYWRpdXNIZWF0bWFwID0gcmFkaXVzRHJpdmVuQnlQcm9wZXJ0eUhlYXRtYXAoXG4gICAgICByYWRpdXMsXG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIHpvb21Db21wZW5zYXRpb25cbiAgICApO1xuICB9IGVsc2UgaWYgKCFwcm9wZXJ0eSAmJiBBcnJheS5pc0FycmF5KHJhZGl1cykgJiYgXCJwcm9wZXJ0eVZhbHVlXCIgaW4gcmFkaXVzWzBdKSB7XG4gICAgcmFkaXVzSGVhdG1hcCA9IHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjKFxuICAgICAgZGVmYXVsdFJhZGl1c1pvb21SYW1waW5nXG4gICAgKTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlRoZSBvcHRpb24gYC5yYWRpdXNgIGNhbiBvbmx5IGJlIHByb3BlcnR5LWRyaXZlbiBpZiB0aGUgb3B0aW9uIGAucHJvcGVydHlgIGlzIHByb3ZpZGVkLlwiXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByYWRpdXNIZWF0bWFwID0gcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWMoXG4gICAgICBkZWZhdWx0UmFkaXVzWm9vbVJhbXBpbmdcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldHVybmVkSW5mbyA9IHtcbiAgICBoZWF0bWFwTGF5ZXJJZDogbGF5ZXJJZCxcbiAgICBoZWF0bWFwU291cmNlSWQ6IHNvdXJjZUlkXG4gIH07XG4gIGlmIChvcHRpb25zLmRhdGEgJiYgIW1hcC5nZXRTb3VyY2Uoc291cmNlSWQpKSB7XG4gICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGlzVVVJRChkYXRhKSkge1xuICAgICAgZGF0YSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke2RhdGF9L2ZlYXR1cmVzLmpzb24/a2V5PSR7Y29uZmlnLmFwaUtleX1gO1xuICAgIH1cbiAgICBtYXAuYWRkU291cmNlKHNvdXJjZUlkLCB7XG4gICAgICB0eXBlOiBcImdlb2pzb25cIixcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBtYXAuYWRkTGF5ZXIoe1xuICAgIGlkOiBsYXllcklkLFxuICAgIHR5cGU6IFwiaGVhdG1hcFwiLFxuICAgIHNvdXJjZTogc291cmNlSWQsXG4gICAgbWluem9vbSxcbiAgICBtYXh6b29tLFxuICAgIHBhaW50OiB7XG4gICAgICBcImhlYXRtYXAtd2VpZ2h0XCI6IGhlYXRtYXBXZWlnaHQsXG4gICAgICBcImhlYXRtYXAtaW50ZW5zaXR5XCI6IHR5cGVvZiBpbnRlbnNpdHkgPT09IFwibnVtYmVyXCIgPyBpbnRlbnNpdHkgOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhcbiAgICAgICAgaW50ZW5zaXR5XG4gICAgICApLFxuICAgICAgXCJoZWF0bWFwLWNvbG9yXCI6IGhlYXRtYXBJbnRlbnNpdHlGcm9tQ29sb3JSYW1wKGNvbG9yUmFtcCksXG4gICAgICBcImhlYXRtYXAtcmFkaXVzXCI6IHJhZGl1c0hlYXRtYXAsXG4gICAgICBcImhlYXRtYXAtb3BhY2l0eVwiOiB0eXBlb2Ygb3BhY2l0eSA9PT0gXCJudW1iZXJcIiA/IG9wYWNpdHkgOiByYW1wZWRPcHRpb25zVG9MYXllclBhaW50U3BlYyhcbiAgICAgICAgb3BhY2l0eVxuICAgICAgKVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXR1cm5lZEluZm87XG59XG5cbmNvbnN0IGhlbHBlcnMgPSB7XG4gIGFkZFBvbHlsaW5lLFxuICBhZGRQb2x5Z29uLFxuICBhZGRQb2ludCxcbiAgYWRkSGVhdG1hcFxufTtcblxuY29uc3Qge1xuICAvLyBzdXBwb3J0ZWQsXG4gIHNldFJUTFRleHRQbHVnaW4sXG4gIGdldFJUTFRleHRQbHVnaW5TdGF0dXMsXG4gIExuZ0xhdCxcbiAgTG5nTGF0Qm91bmRzLFxuICBNZXJjYXRvckNvb3JkaW5hdGUsXG4gIEV2ZW50ZWQsXG4gIEFKQVhFcnJvcixcbiAgcHJld2FybSxcbiAgY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXMsXG4gIHZlcnNpb24sXG4gIHdvcmtlckNvdW50LFxuICBtYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMsXG4gIHdvcmtlclVybCxcbiAgYWRkUHJvdG9jb2wsXG4gIHJlbW92ZVByb3RvY29sXG59ID0gbWFwbGlicmVnbF9fZGVmYXVsdDtcbmNvbnN0IE1hcE1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0Lk1hcDtcbmNvbnN0IE1hcmtlck1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0Lk1hcmtlcjtcbmNvbnN0IFBvcHVwTUxHTCA9IG1hcGxpYnJlZ2xfX2RlZmF1bHQuUG9wdXA7XG5jb25zdCBTdHlsZU1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0LlN0eWxlO1xuY29uc3QgQ2FudmFzU291cmNlTUxHTCA9IG1hcGxpYnJlZ2xfX2RlZmF1bHQuQ2FudmFzU291cmNlO1xuY29uc3QgR2VvSlNPTlNvdXJjZU1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0Lkdlb0pTT05Tb3VyY2U7XG5jb25zdCBJbWFnZVNvdXJjZU1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0LkltYWdlU291cmNlO1xuY29uc3QgUmFzdGVyVGlsZVNvdXJjZU1MR0wgPSBtYXBsaWJyZWdsX19kZWZhdWx0LlJhc3RlclRpbGVTb3VyY2U7XG5jb25zdCBSYXN0ZXJERU1UaWxlU291cmNlTUxHTCA9IG1hcGxpYnJlZ2xfX2RlZmF1bHQuUmFzdGVyREVNVGlsZVNvdXJjZTtcbmNvbnN0IFZlY3RvclRpbGVTb3VyY2VNTEdMID0gbWFwbGlicmVnbF9fZGVmYXVsdC5WZWN0b3JUaWxlU291cmNlO1xuY29uc3QgVmlkZW9Tb3VyY2VNTEdMID0gbWFwbGlicmVnbF9fZGVmYXVsdC5WaWRlb1NvdXJjZTtcbm1hcGxpYnJlZ2xfX2RlZmF1bHQuTmF2aWdhdGlvbkNvbnRyb2w7XG5tYXBsaWJyZWdsX19kZWZhdWx0Lkdlb2xvY2F0ZUNvbnRyb2w7XG5tYXBsaWJyZWdsX19kZWZhdWx0LkF0dHJpYnV0aW9uQ29udHJvbDtcbm1hcGxpYnJlZ2xfX2RlZmF1bHQuTG9nb0NvbnRyb2w7XG5tYXBsaWJyZWdsX19kZWZhdWx0LlNjYWxlQ29udHJvbDtcbm1hcGxpYnJlZ2xfX2RlZmF1bHQuRnVsbHNjcmVlbkNvbnRyb2w7XG5tYXBsaWJyZWdsX19kZWZhdWx0LlRlcnJhaW5Db250cm9sO1xuXG5leHBvcnQgeyBBSkFYRXJyb3IsIEF0dHJpYnV0aW9uQ29udHJvbCwgQ2FudmFzU291cmNlLCBDYW52YXNTb3VyY2VNTEdMLCBDb2xvclJhbXAsIENvbG9yUmFtcENvbGxlY3Rpb24sIEV2ZW50ZWQsIEZ1bGxzY3JlZW5Db250cm9sLCBHZW9KU09OU291cmNlLCBHZW9KU09OU291cmNlTUxHTCwgR2VvbG9jYXRlQ29udHJvbCwgR2VvbG9jYXRpb25UeXBlLCBJbWFnZVNvdXJjZSwgSW1hZ2VTb3VyY2VNTEdMLCBMYW5ndWFnZSwgTG5nTGF0LCBMbmdMYXRCb3VuZHMsIExvZ29Db250cm9sLCBNYXAsIE1hcE1MR0wsIE1hcHRpbGVyR2VvbG9jYXRlQ29udHJvbCwgTWFwdGlsZXJMb2dvQ29udHJvbCwgTWFwdGlsZXJOYXZpZ2F0aW9uQ29udHJvbCwgTWFwdGlsZXJUZXJyYWluQ29udHJvbCwgTWFya2VyLCBNYXJrZXJNTEdMLCBNZXJjYXRvckNvb3JkaW5hdGUsIE5hdmlnYXRpb25Db250cm9sLCBQb2ludCwgUG9wdXAsIFBvcHVwTUxHTCwgUmFzdGVyREVNVGlsZVNvdXJjZSwgUmFzdGVyREVNVGlsZVNvdXJjZU1MR0wsIFJhc3RlclRpbGVTb3VyY2UsIFJhc3RlclRpbGVTb3VyY2VNTEdMLCBTY2FsZUNvbnRyb2wsIFNka0NvbmZpZywgU3R5bGUsIFN0eWxlTUxHTCwgVGVycmFpbkNvbnRyb2wsIFZlY3RvclRpbGVTb3VyY2UsIFZlY3RvclRpbGVTb3VyY2VNTEdMLCBWaWRlb1NvdXJjZSwgVmlkZW9Tb3VyY2VNTEdMLCBhZGRQcm90b2NvbCwgY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXMsIGNvbmZpZywgZ2V0QnJvd3Nlckxhbmd1YWdlLCBnZXRSVExUZXh0UGx1Z2luU3RhdHVzLCBncHgsIGdweE9yS21sLCBoYXNDaGlsZE5vZGVXaXRoTmFtZSwgaGVscGVycywgaXNMYW5ndWFnZVN1cHBvcnRlZCwga21sLCBtYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMsIHByZXdhcm0sIHJlbW92ZVByb3RvY29sLCBzZXRSVExUZXh0UGx1Z2luLCBzdHIyeG1sLCB2ZXJzaW9uLCB3b3JrZXJDb3VudCwgd29ya2VyVXJsLCB4bWwyc3RyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXB0aWxlci1zZGsubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs\n");

/***/ })

};
;